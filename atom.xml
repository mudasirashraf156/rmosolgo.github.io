<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2020-07-27T16:05:47-04:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Books I Read in 2019]]></title>
    <link href="http://rmosolgo.github.io/blog/2020/02/04/books-i-read-in-2019/"/>
    <updated>2020-02-04T14:19:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2020/02/04/books-i-read-in-2019</id>
    <content type="html"><![CDATA[<p>I thought I&rsquo;d try to remember what I read last year.</p>

<!-- more -->


<p>In roughly chronological order:</p>

<ul>
<li><em>That Distant Land</em>, Wendell Berry</li>
<li><em>The Good Shepherd and the Child</em>, Sofia Cavaletti et al</li>
<li><em>Albemarle, Jefferson&rsquo;s County, 1727-1976</em>, John Hammond Moore</li>
<li><em>Perelandra</em>, C.S. Lewis</li>
<li><em>Modern Technology and the Human Future: A Christian Perspective</em>, Craig Gay</li>
<li><em>Grass Productivity</em>, Andre Voisin</li>
<li><em>American Farmstead Cheese</em>, Paul Kindstedt</li>
<li><em>A River Runs Through It</em>, Norman Maclean</li>
<li><em>The Art and Science of Grazing</em>, Sarah Flack</li>
<li><em>The New Organic Grower</em>, Elliot Coleman</li>
<li><em>Out of the Silent Planet</em>, C.S. Lewis</li>
<li><em>That Hideous Strength</em>, C.S. Lewis</li>
<li><em>The Abolition of Man</em>, C.S. Lewis</li>
<li><em>Small-Scale Dairy</em>, Gianaclis Caldwell</li>
<li><em>Man&rsquo;s Search for Meaning</em>, Viktor Frankl</li>
<li><em>Jayber Crow</em>, Wendell Berry</li>
<li><em>La Fromagerie a la Ferme</em>, Patrick Anglade</li>
<li><em>Sex, Freedom, Economy, and Community</em>, Wendell Berry</li>
<li><em>How (Not) to Be Secular</em>, James Smith</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Finding implicit returns with Rubocop]]></title>
    <link href="http://rmosolgo.github.io/blog/2019/11/14/finding-implicit-returns-with-rubocop/"/>
    <updated>2019-11-14T09:57:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2019/11/14/finding-implicit-returns-with-rubocop</id>
    <content type="html"><![CDATA[<p>Some notes on a refactor implemented with a Cop.</p>

<!-- more -->


<p>I&rsquo;ve developed a real affection for Rubocop over the last couple of years. (Sorry to my old coworkers and friends at Planning Center, who put up with my complaining about it back then!) What I&rsquo;ve come to appreciate is:</p>

<ul>
<li><strong>No fights about style.</strong> If it passes the linter, it&rsquo;s ok to ship.</li>
<li><strong>Enforcing usage coventions.</strong> For example, we have a cop to make sure that some risky methods aren&rsquo;t used in the codebase.</li>
<li><strong>Upgrading old code.</strong> For example, we realized we were sometimes using <code>Promise.all(...) do</code> instead of <code>Promise.all(...).then do</code>. The old code didn&rsquo;t work at all. We added a Cop with an <code>autocorrect</code> implementation, so we could upgrade any mistakes automatically!</li>
</ul>


<h2>The Refactor: Returning Promises</h2>

<p>We have some GraphQL/GraphQL-Batch code for making authorization checks. It looks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Types</span><span class="o">::</span><span class="no">Repository</span>
</span><span class='line'>  <span class="c1"># This is GraphQL-Ruby&#39;s authorization API</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">authorized?</span><span class="p">(</span><span class="n">repository</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># Load some data which is required for the check:</span>
</span><span class='line'>    <span class="n">batch_load</span><span class="p">(</span><span class="n">repository</span><span class="p">,</span> <span class="ss">:owner</span><span class="p">)</span><span class="o">.</span><span class="n">then</span> <span class="k">do</span> <span class="o">|</span><span class="n">owner</span><span class="o">|</span>
</span><span class='line'>      <span class="c1"># Call the authorization code:</span>
</span><span class='line'>      <span class="no">Authorization</span><span class="o">.</span><span class="n">can_see?</span><span class="p">(</span><span class="n">ctx</span><span class="o">[</span><span class="ss">:viewer</span><span class="o">]</span><span class="p">,</span> <span class="n">repository</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <code>authorized?</code> check returns a <code>Promise</code> (for GraphQL-Batch), and inside that promise, <code>.can_see?</code> returns <code>true</code> or <code>false</code> (synchronously).</p>

<p>However, to improve data access, we wanted to implement a new authorization code path:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Returns Promise&lt;true|false&gt;</span>
</span><span class='line'><span class="no">Authorization</span><span class="o">.</span><span class="n">async_can_see?</span><span class="p">(</span><span class="n">viewer</span><span class="p">,</span> <span class="n">repo</span><span class="p">,</span> <span class="n">owner</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>This new code path would improve the database access under the hood to use our batch loading system.</p>

<p>After implementing the codepath, how could we update the ~1000 call sites to use the new method?</p>

<h2>The Problem: Boolean Logic</h2>

<p>The easiest solution would be find-and-replace, but that doesn&rsquo;t quite work because of boolean logic with Promises. Some of our authorization checks combined two checks like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Require both checks to pass:</span>
</span><span class='line'><span class="no">Authorization</span><span class="o">.</span><span class="n">can_see?</span><span class="p">(</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="no">Authorization</span><span class="o">.</span><span class="n">can_see?</span><span class="p">(</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>If we updated that to <code>async_can_see?</code>, that code would break. It would break because <code>async_can_see?</code> <em>always</em> returns a <code>Promise</code>, which is truthy. That is:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">promise_1</span> <span class="o">&amp;&amp;</span> <span class="n">promise_2</span>
</span></code></pre></td></tr></table></div></figure>


<p>That code <em>always</em> returns true, even if one of the promises <em>would</em> resolve to <code>false</code>. (The Ruby <code>Promise</code> object is truthy, and we don&rsquo;t have access to the returned value until we call <code>promise.sync</code>.)</p>

<p>So, we have to figure out <em>which code paths</em> can be automatically upgraded.</p>

<h2>The Solution, In Theory</h2>

<p>Roughly, the answer is:</p>

<blockquote><p>If an authorization <em>returns the value</em> of <code>.can_see?</code>, then we can replace that call with <code>.async_can_see?</code>.</p></blockquote>

<p>This is true because GraphQL-Ruby is happy to receive <code>Promise&lt;true|false&gt;</code> &ndash; it will use its batching system to resolve it as late as possible.</p>

<p>So, how can we find cases when <code>.can_see?</code> is used as a return value? There are roughly two possibilities:</p>

<ul>
<li>explicit <code>return</code>s, which we don&rsquo;t use often</li>
<li>implicit returns, which are the last expressions of any branches in the method body.</li>
</ul>


<p>This post covers that <em>second case</em>, implicit returns. We want to find implicit returns which are <em>just</em> calls to <code>.can_see?</code>, and automatically upgrade them. (Some calls will be left over, we&rsquo;ll upgrade those by hand.)</p>

<p>We assume that any code which is <em>more complicated</em> than <em>just</em> a call to <code>.can_see?</code> can&rsquo;t be migrated, because it might depend on the synchronous return of <code>true|false</code>. We&rsquo;ll revisit those by hand.</p>

<h2>The Implementation: A Cop</h2>

<p>I knew I wanted two things:</p>

<ul>
<li>For new code, require <code>async_can_see?</code> whenever possible</li>
<li>For existing code, upgrade to <code>async_can_see?</code> whenever it&rsquo;s possible</li>
</ul>


<p>Rubocop will do both of these things:</p>

<ul>
<li>A linting rule will fail the build if invalid code is added to the project, addressing the first goal</li>
<li>A well-implemented <code>def autocorrect</code> will fix existing violations, addressing the second goal</li>
</ul>


<p>But it all depends on implementing the check well: can I find implicit returns? Fortunately, I only need to find them <em>well enough</em>: it doesn&rsquo;t have to find <em>every possible</em> Ruby implicit return; it only has to find the ones actually used in the codebase!</p>

<p>By an approach of trial and error, here&rsquo;s what I ended up with:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># frozen_string_literal: true</span>
</span><span class='line'><span class="k">class</span> <span class="nc">AsyncCanSeeWhenPossible</span> <span class="o">&lt;</span> <span class="ss">Rubocop</span><span class="p">:</span><span class="ss">:Cop</span>
</span><span class='line'>  <span class="no">MSG</span> <span class="o">=</span> <span class="o">&lt;&lt;-</span><span class="no">ERR</span>
</span><span class='line'><span class="sh">When `.can_see?` is the last call inside an authorization method, use</span>
</span><span class='line'><span class="sh">`.async_can_see?` instead so that the underlying data access can be batched.</span>
</span><span class='line'><span class="no">ERR</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># If the given node is a call to `:can_see?`, it&#39;s yielded</span>
</span><span class='line'>  <span class="n">def_node_matcher</span> <span class="ss">:can_see_call</span><span class="p">,</span> <span class="s2">&quot;$(send s(:const, {nil (cbase)}, :Authorization) :can_see? ...)&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># Look for nested promises -- treat the body of a nested promise just like the method body.</span>
</span><span class='line'>  <span class="c1"># (That is, the implicit return of the block is like the implicit return of the method)</span>
</span><span class='line'>  <span class="n">def_node_matcher</span> <span class="ss">:then_block</span><span class="p">,</span> <span class="s2">&quot;(block (send _ :then) _ $({begin send block if case} ...))&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># Check for `def self.authorized?` and call the cop on that method</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">on_defs</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</span><span class='line'>    <span class="n">_self</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">_args</span><span class="p">,</span> <span class="n">method_body</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">method_name</span> <span class="o">==</span> <span class="ss">:authorized?</span>
</span><span class='line'>      <span class="n">check_implicit_return</span><span class="p">(</span><span class="n">method_body</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># Replace `.can_see?` with `.async_can_see?`</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">autocorrect</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">lambda</span> <span class="k">do</span> <span class="o">|</span><span class="n">corrector</span><span class="o">|</span>
</span><span class='line'>      <span class="n">_receiver</span><span class="p">,</span> <span class="n">method_name</span><span class="p">,</span> <span class="o">*</span><span class="n">rest</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span>
</span><span class='line'>      <span class="n">corrector</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">location</span><span class="o">.</span><span class="n">selector</span><span class="p">,</span> <span class="s2">&quot;async_can_see?&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="kp">private</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># Continue traversing `node` until you get to the last expression.</span>
</span><span class='line'>  <span class="c1"># If that expression is a call to `.can_see?`, then add an offense.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">check_implicit_return</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
</span><span class='line'>    <span class="k">case</span> <span class="n">node</span><span class="o">.</span><span class="n">type</span>
</span><span class='line'>    <span class="k">when</span> <span class="ss">:begin</span>
</span><span class='line'>      <span class="c1"># This node is a series of expressions.</span>
</span><span class='line'>      <span class="c1"># The last one is the implicit return.</span>
</span><span class='line'>      <span class="o">*</span><span class="n">_prev_exps</span><span class="p">,</span> <span class="n">last_expression</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span>
</span><span class='line'>      <span class="n">check_implicit_return</span><span class="p">(</span><span class="n">last_expression</span><span class="p">)</span>
</span><span class='line'>    <span class="k">when</span> <span class="ss">:block</span>
</span><span class='line'>      <span class="c1"># It&#39;s a method call that receives a block.</span>
</span><span class='line'>      <span class="c1"># If it&#39;s a then-block, check its body for implicit returns.</span>
</span><span class='line'>      <span class="n">then_block</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">block_body</span><span class="o">|</span>
</span><span class='line'>        <span class="n">check_implicit_return</span><span class="p">(</span><span class="n">block_body</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">when</span> <span class="ss">:if</span>
</span><span class='line'>      <span class="c1"># Check each branch of an `if ...` expression, because</span>
</span><span class='line'>      <span class="c1"># each branch may be an implicit return</span>
</span><span class='line'>      <span class="c1"># (elsif is part of the `else_exp`)</span>
</span><span class='line'>      <span class="n">_check</span><span class="p">,</span> <span class="n">if_exp</span><span class="p">,</span> <span class="n">else_exp</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span>
</span><span class='line'>      <span class="n">check_implicit_return</span><span class="p">(</span><span class="n">if_exp</span><span class="p">)</span>
</span><span class='line'>      <span class="c1"># This can be null if there is no else expression</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">else_exp</span>
</span><span class='line'>        <span class="n">check_implicit_return</span><span class="p">(</span><span class="n">else_exp</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">when</span> <span class="ss">:case</span>
</span><span class='line'>      <span class="c1"># Check each branch of the case statement, since each one</span>
</span><span class='line'>      <span class="c1"># could be an implicit return.</span>
</span><span class='line'>      <span class="n">_subject</span><span class="p">,</span> <span class="o">*</span><span class="n">when_exps</span><span class="p">,</span> <span class="n">else_exp</span> <span class="o">=</span> <span class="o">*</span><span class="n">node</span>
</span><span class='line'>      <span class="n">when_exps</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">when_exp</span><span class="o">|</span>
</span><span class='line'>        <span class="o">*</span><span class="n">_when_conditions</span><span class="p">,</span> <span class="n">condition_body</span> <span class="o">=</span> <span class="o">*</span><span class="n">when_exp</span>
</span><span class='line'>        <span class="n">check_implicit_return</span><span class="p">(</span><span class="n">condition_body</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>      <span class="c1"># There may or may not be an `else` branch.</span>
</span><span class='line'>      <span class="k">if</span> <span class="n">else_exp</span>
</span><span class='line'>        <span class="n">check_implicit_return</span><span class="p">(</span><span class="n">else_exp</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">when</span> <span class="ss">:send</span>
</span><span class='line'>      <span class="c1"># This is a method call -- if it&#39;s a plain call to `.can_see?`, flag it.</span>
</span><span class='line'>      <span class="n">can_see_call</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="k">do</span> <span class="o">|</span><span class="n">bad_call</span><span class="o">|</span>
</span><span class='line'>        <span class="n">add_offense</span><span class="p">(</span><span class="n">bad_call</span><span class="p">,</span> <span class="ss">location</span><span class="p">:</span> <span class="ss">:selector</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="c1"># We&#39;ve reached an implicit return which is not:</span>
</span><span class='line'>      <span class="c1">#</span>
</span><span class='line'>      <span class="c1"># - An expression containing other implicit returns</span>
</span><span class='line'>      <span class="c1"># - An expression calling `.can_see?`, which we know to upgrade</span>
</span><span class='line'>      <span class="c1">#</span>
</span><span class='line'>      <span class="c1"># So, ignore this implicit return.</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>With this cop, <code>rubocop -a</code> will upgrade the easy cases in existing code, then I&rsquo;ll track down the harder ones by hand.</p>

<p>I think the implementation could be improved by:</p>

<ul>
<li><strong>Also checking explicit <code>return</code>s.</strong> It wasn&rsquo;t important for me because there weren&rsquo;t any in this code base. <code>next</code> Could probably be treated the same way, since it exists <code>then</code> blocks.</li>
<li><strong>Flagging <em>any</em> use of <code>.can_see?</code>,</strong> not only the easy ones. I expect that some usages are inevitable, but better to require a <code>rubocop:disable</code> in that case to mark that it&rsquo;s not best-practice.</li>
</ul>


<p>(Full disclosure: we haven&rsquo;t shipped this refactor yet. But I enjoyed the work on it so far, so I thought I&rsquo;d write up what I learned!)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Breaking out of a yield with return]]></title>
    <link href="http://rmosolgo.github.io/blog/2019/09/02/breaking-out-of-a-yield-with-return/"/>
    <updated>2019-09-02T11:28:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2019/09/02/breaking-out-of-a-yield-with-return</id>
    <content type="html"><![CDATA[<p>Did you know that calling <code>return</code> in one Ruby method could affect the flow of another method? I discovered it today while hunting a <a href="https://github.com/rmosolgo/graphql-ruby/commit/400bb71bc">GraphQL-Ruby bugfix</a>. You can get more reliable behavior with <code>ensure</code>, if it&rsquo;s appropriate.</p>

<!-- more -->


<h3>Instrumentating a block</h3>

<p>Let&rsquo;s imagine a simple instrumentation system, where method wraps a block of code and tags it with a name:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">instrument_event</span><span class="p">(</span><span class="n">event_name</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;begin    </span><span class="si">#{</span><span class="n">event_name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="n">result</span> <span class="o">=</span> <span class="k">yield</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;end      </span><span class="si">#{</span><span class="n">event_name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="n">result</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>You could use this to instrument a method call, for example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">do_stuff_with_instrumentation</span>
</span><span class='line'>  <span class="n">instrument_event</span><span class="p">(</span><span class="s2">&quot;do-stuff&quot;</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">do_stuff</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">do_stuff_with_instrumentation</span>
</span><span class='line'><span class="c1"># begin    do-stuff</span>
</span><span class='line'><span class="c1"># end      do-stuff</span>
</span></code></pre></td></tr></table></div></figure>


<p>It prints the <code>begin</code> message, then the <code>end</code> message.</p>

<h3>Returning early</h3>

<p>But what if you return early from the block? For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># @param return_early [Boolean] if true, return before actually doing the stuff</span>
</span><span class='line'><span class="k">def</span> <span class="nf">do_stuff_with_instrumentation</span><span class="p">(</span><span class="n">return_early</span><span class="p">:)</span>
</span><span class='line'>  <span class="n">instrument_event</span><span class="p">(</span><span class="s2">&quot;do-stuff&quot;</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>    <span class="k">if</span> <span class="n">return_early</span>
</span><span class='line'>      <span class="c1"># Return from this method ... but also return from the `do ... end` instrumentation block</span>
</span><span class='line'>      <span class="k">return</span>
</span><span class='line'>    <span class="k">else</span>
</span><span class='line'>      <span class="n">do_stuff</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>If you instrument it <em>without</em> returning from inside the block, it logs normally:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">do_stuff_with_instrumentation</span><span class="p">(</span><span class="n">return_early</span><span class="p">:</span> <span class="kp">false</span><span class="p">)</span>
</span><span class='line'><span class="c1"># begin    do-stuff</span>
</span><span class='line'><span class="c1"># end      do-stuff</span>
</span></code></pre></td></tr></table></div></figure>


<p>But, if you return early, you only get <em>half</em> the log:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">do_stuff_with_instrumentation</span><span class="p">(</span><span class="n">return_early</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span>
</span><span class='line'><span class="c1"># begin    do-stuff</span>
</span></code></pre></td></tr></table></div></figure>


<p>Where&rsquo;s the <code>end</code> message?</p>

<h3>It Jumped!</h3>

<p>Apparently, the <code>return</code> inside the inner method (<code>#do_stuff_with_instrumentation</code>) broke out of its own method <em>and</em> out of <code>#instrument_event</code>. I don&rsquo;t know why it works like that.</p>

<h3>With Ensure</h3>

<p>If you refactor the instrumentation to use <code>ensure</code>, it won&rsquo;t have this issue. Here&rsquo;s the refactor:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">instrument_event</span><span class="p">(</span><span class="n">event_name</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;begin    </span><span class="si">#{</span><span class="n">event_name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="k">yield</span>
</span><span class='line'><span class="k">ensure</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;end      </span><span class="si">#{</span><span class="n">event_name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then, it prints normally:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">do_stuff_with_instrumentation</span><span class="p">(</span><span class="n">return_early</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span>
</span><span class='line'><span class="c1"># begin    do-stuff</span>
</span><span class='line'><span class="c1"># end      do-stuff</span>
</span></code></pre></td></tr></table></div></figure>


<p>Of course, this also changes the behavior of the method when errors happen. The <code>ensure</code> code will be called <em>even if</em> <code>yield</code> raises an error. So, it might not always be the right choice. (I bet you could use <code>$!</code> to detect a currently-raised error, though.)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How I Make Yogurt]]></title>
    <link href="http://rmosolgo.github.io/blog/2019/03/28/how-i-make-yogurt/"/>
    <updated>2019-03-28T09:25:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2019/03/28/how-i-make-yogurt</id>
    <content type="html"><![CDATA[<p>Yesterday I excitedly recommended to a friend that he try making some yogurt at home. Then I realized that my personal recipe is a bit of a hodge-podge, so I thought I&rsquo;d try writing it out.</p>

<!-- more -->


<p>This recipe isn&rsquo;t perfect: when using raw milk, a bit of the cream still separates to the top while it&rsquo;s culturing. (I&rsquo;d rather have it all mixed in, but I guess you could call it &ldquo;cream top&rdquo;!)</p>

<p>My sources are:</p>

<ul>
<li><a href="https://fankhauserblog.wordpress.com/2010/04/03/yogurt-making-illustrated/">Dr. Fankhauser&rsquo;s &ldquo;Yogurt Making, Illustrated&rdquo;</a></li>
<li><a href="https://brodandtaylor.com/custard-style-yogurt-recipe/">Brod &amp; Taylor&rsquo;s &ldquo;Custard-Style Yogurt Recipe&rdquo;</a></li>
</ul>


<p>I&rsquo;d like to add pictures someday, but for now, I recommend the pictures on Fankhauser&rsquo;s blog.</p>

<h2>Prep and sterilize</h2>

<p>Yogurt will only be as good as what you put in it. I generally <strong>sterilize everything</strong> I&rsquo;ll need for the recipe:</p>

<ul>
<li>A spoon for working with the starter culture</li>
<li>A bowl for mixing starter with milk</li>
<li>Jars for holding the yogurt, and their lids</li>
<li>A ladle for bottling</li>
<li>A funnel for bottling</li>
</ul>


<p>To sterilize these items, I either:</p>

<ul>
<li>Put everything in the dishwasher (without soap) ad let it run until the &ldquo;sterilized&rdquo; light is green; or</li>
<li>Put everything in a big pot with a few inches of water at the bottom. Boil the water and keep a slow boil for 10 minutes. (This technique is from Fankhauser, above.)</li>
</ul>


<p>Sometimes I forget an item at this step, in which case I wash it as welll as I can and hope for the best. I&rsquo;ve never had anything really <em>spoil</em>, but I did have a batch that had a bit of kefir taste to it! I assume it had some yeast contamination. I still ate it 🤷‍.</p>

<h2>Heat the milk &amp; hold</h2>

<p>Fankhauser recommends this step for pasteurization purposes, to kill unwanted bacteria. Brod &amp; Taylor&rsquo;s recipe prescribes a higher temperature (195°F) and a longer holding time in order to mess with the proteins and get a thicker yogurt. (I really don&rsquo;t know <em>how</em> it accomplishes that. I read that it &ldquo;denatures whey proteins&rdquo;, and anyhow, I&rsquo;m convinced because this is the same temperature you use to make whey ricotta, so there must be something to it.)</p>

<p>Anyway, first, <strong>heat the milk to 190°F and then take it off of the heat for 20 minutes</strong>.</p>

<p>The real trick is not to burn the milk. Whenever I cook it in a pot on the stove, I burn it on the bottom, no matter how much I use low heat and stir. Burning the milk is a double-whammy: it caramelizes some milk sugar, giving a hint of weird taste to the yogurt, and it sticks like cement to the bottom of the pot (adding insult to injury).</p>

<p>Finally, I found an approach that doesn&rsquo;t burn the milk. I put a 2-gallon pot of milk inside my canner (without a lid) and fill the canner with water, then use it like a giant double-boiler. Just like a double-boiler, the hot water will buffer the temperature (it can&rsquo;t go above boiling), and as a bonus, it heats the milk faster and more evenly, since the pot is surrounded with hot water. When the milk reaches the target temperature, I take it out of the double-boiler and set it aside.</p>

<h2>Cool the milk</h2>

<p>The milk is now ready to become delicious yogurt, but it&rsquo;s too hot for yogurt cultures to survive. <strong>Cool the milk to 120°F</strong> by placing it a sink of ice water. Stir frequently to equalize the temperature of the milk, and remove it when it reaches the target temperature.</p>

<h2>Inoculate</h2>

<p>Now, add the starter culture to the pot of milk. I&rsquo;ve done it two ways:</p>

<ul>
<li><strong>Add a <a href="https://cheesemaking.com/products/thermophilic-starter-culture-for-cheese-making">packet of thermophilic starter</a></strong>. This is easy and reliable. I buy the starter at Fifth Season Gardening downtown. The downside is, it&rsquo;s more expensive than&hellip;</li>
<li><strong>Or, add 1 cup of yogurt per gallon of milk</strong> (this is Fankauser&rsquo;s ratio from the recipe above). You can use yogurt from your own previous batch, or use store-bought: find plain yogurt labeled with &ldquo;active cultures&rdquo; and a &ldquo;use-by&rdquo; date in the far future (so it&rsquo;s fresh). When adding yogurt this way, first mix equal parts yogurt and warmed milk (from the pot) in a bow, and stir until the consistency is even. Then, pour this mixture back into the pot and stir. (This is Fankhauser&rsquo;s technique. I assume it&rsquo;s to ensure that the culture is evenly distributed.)</li>
</ul>


<h2>Bottle it</h2>

<p>Now that your yogurt is inoculated, <strong>distribute it into your jars</strong> (or whatever) to culture. I make 2 gallons at a time, so I use 8 quart jars.</p>

<h2>Set it</h2>

<p><strong>Put your jars in a cooler, and fill the cooler with 120°F water.</strong> (Actually, I prep the cooler by adding some hot water first, then dumping it out and refilling this. I hope it warms up the cooler ahead-of-time.)</p>

<p>I used to really fuss with the water temperature, checking it from time to time and heating it back up to keep it close to 120°F. But then, I read in the Brod &amp; Taylor recipe (linked above) that you might get a better texture by reducing the temperature after 1 hour.</p>

<p>I don&rsquo;t follow that recipe, but I do close the cooler and forget about it. It cools off on its own and seems to turn out fine. I also read somewhere (don&rsquo;t remember where?) that temperature variance helps complementary cultures (Bulgaricus and Thermophilus) get their own time to work on the milk. Something like, one of the bacteria does better on the higher range, while the other does better on the lower range.</p>

<h2>Forget it</h2>

<p>I <strong>leave it for 8-16 hours</strong>, roughly all day or overnight. &ldquo;Done&rdquo; is a matter of taste. More culturing will make a tangier yogurt that separates whey more. Less time will make a sweeter yogurt with less whey separation.</p>

<p>I used to leave it for 24-ish hours, but I realized that the sweeter yogurt is tart enough and takes less time. Besides, I read on <a href="https://brodandtaylor.com/how-to-maintain-a-yogurt-culture/">Brod &amp; Taylor&rsquo;s &ldquo;How to Maintain a Yogurt Culture&rdquo;</a> that the culture will last longer if it has more lactose to digest while it&rsquo;s in the fridge. I don&rsquo;t follow all the steps in that article, but I hope it will keep my culture going strong for longer.</p>

<h2>Eat it</h2>

<p><strong>Dry off the jars and put them in the fridge</strong>. They&rsquo;re sterilized and pasteurized, so besides the yogurt bacteria continuing to process the lactose, they don&rsquo;t really spoil. I make yogurt once every month or two.</p>

<p>We end up eating yogurt as:</p>

<ul>
<li>milk for cereal</li>
<li>a vehicle for jam or honey</li>
<li>strained, as a replacement for sour cream</li>
<li>mixed into various sauces (herbs, garlic, etc)</li>
</ul>


<p>I&rsquo;d like to try making <em>frozen</em> yogurt, but I haven&rsquo;t yet!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[A New Runtime in GraphQL-Ruby 1.9]]></title>
    <link href="http://rmosolgo.github.io/blog/2019/01/29/a-new-runtime-in-graphql-ruby-1-dot-9/"/>
    <updated>2019-01-29T07:22:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2019/01/29/a-new-runtime-in-graphql-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>GraphQL-Ruby 1.9.0 introduces a new runtime called <code>GraphQL::Execution::Interpreter</code>. It offers better performance and some new features.</p>

<!-- more -->


<p>In <a href="https://github.com/rmosolgo/graphql-ruby/issues/861#issuecomment-458533219">isolated benchmarks</a>, the new runtime is about 50% faster. We saw about a 10% speedup in GitHub when we migrated.</p>

<p>You can opt in by adding to your schema:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">MySchema</span> <span class="o">&lt;</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Schema</span>
</span><span class='line'>  <span class="c1"># To use the new runtime</span>
</span><span class='line'>  <span class="n">use</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Execution</span><span class="o">::</span><span class="no">Interpreter</span>
</span><span class='line'>  <span class="c1"># To skip preprocessing (you can use the interpreter without adding this)</span>
</span><span class='line'>  <span class="n">use</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Analysis</span><span class="o">::</span><span class="no">AST</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>But why rewrite?</p>

<h2>Problem 1: per-field context objects</h2>

<p>Previously, each field evaluated by GraphQL-Ruby got its own instance of <code>GraphQL::Query::Context::FieldResolutionContext</code>. This was introduced so that fields using <code>graphql-batch</code>-style Promises could reliably access context values (like <code>ctx.path</code>) <em>after</em> returning from the resolver (ie, when the promise was synced.)</p>

<p>The problem was, the bigger the response, the more <code>ctx</code> objects would be created &ndash; and most of the time (for example, plain scalar fields), they were never <em>used</em> by application code. So, we allocated, initialized, then GCed these objects for nothing!</p>

<p>In fact, it wasn&rsquo;t for <em>nothing</em>. As time passed, I started using those context objects inside execution code. For example, null propagation was implemented by climbing <em>up</em> the tree of context objects. So you couldn&rsquo;t just <em>stop</em> creating them &ndash; the runtime depended on them.</p>

<h3>Solution: one mutable context</h3>

<p>To remove this performance issue, I went <em>back</em> to creating a single <code>Query::Context</code> object and passing it to resolvers. If you&rsquo;re using the new class-based API, you might have noticed that <code>self.context</code> is a <code>Query::Context</code>, not a <code>Query::Context::FieldResolutionContext</code>. I did it this way to pave the way for removing this bottleneck.</p>

<p>But what about access to runtime information?</p>

<h3>Solution: explicit requests for runtime info</h3>

<p>For fields that <em>want</em> runtime info (like <code>path</code> or <code>ast_node</code>), they can opt into it with <code>extras: [...]</code>, for example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:items</span><span class="p">,</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="n">,</span> <span class="ss">extras</span><span class="p">:</span> <span class="o">[</span><span class="ss">:path</span><span class="o">]</span>
</span></code></pre></td></tr></table></div></figure>


<p>By adding that configuration, the requested value will be injected into the resolver:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">items</span><span class="p">(</span><span class="ss">path</span><span class="p">:)</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>path</code> will be a frozen Array describing the current point in the GraphQL response.</p>

<h3>Solution: reimplementing the runtime</h3>

<p>Finally, since <code>FieldResolutionContext</code>s aren&rsquo;t necessary for user code, we can rewrite execution to <em>not</em> create or use them anymore. Under the hood, <code>GraphQL::Execution::Interpreter</code> doesn&rsquo;t create those <code>ctx</code> objects. Instead, null propagation is implemented manually and all necessary values are passed from method to method.</p>

<h2>Problem 2: inefficient preprocessing</h2>

<p>Years ago, someone requested the feature of <em>rejecting a query before running it</em>. They wanted to analyze the incoming query, and if it was too big or too complicated, reject it.</p>

<p>How could this be implemented? You could provide user access to the AST, but that would leave some difficult processing to user code, for example, merging fragments on interfaces.</p>

<p>So, I added <code>GraphQL::InternalRepresentation</code> as a normalized, pre-processed query structure. Before running a query, the AST was transformed into a tree of <code>irep_node</code>s. Users could analyze that structure and reject queries if desired.</p>

<p>In execution code, why throw away the result of that preprocessing? The runtime also used <code>irep_node</code>s to save re-calculating fragment merging.</p>

<p>In fact, even <em>static validation</em> used the <code>irep_node</code> tree. At some point, rather than re-implement fragment merging, I decided to hook into that rewritten tree to implement <code>FragmentsWillMerge</code>. After all, why throw away that work?</p>

<p>(As it turns out, someone should fire the GraphQL-Ruby maintainer. These layers of code were <em>not</em> well-isolated!!)</p>

<h3>Problem 2.1: Preparing the <code>irep_node</code>s was slow and often a waste</h3>

<p>Since the <code>irep_node</code> tree was built for <em>analysis</em>, it generated branches for <em>every</em> possible combination of interfaces, objects, and unions. This meant that, even for a query returning very simple data, the pre-processing step might be <em>very</em> complex.</p>

<p>To make matters worse, the complexity of this preprocessing would grow as the schema grew. The more implementers an interface has, the longer it takes to calculate the possible branches in a fragment.</p>

<h3>Problem 2.2: Runtime features were implemented during preprocessing</h3>

<p>Not only was the work complex, but it also couldn&rsquo;t be cached. This is because, while building the <code>irep_node</code> tree, <code>@skip</code> and <code>@include</code> would be evaluated with the current query variables. If nodes were skipped, they were left out of the <code>irep_node</code> tree.</p>

<p>This means that, for the <em>same</em> query in your code base, you <em>couldn&rsquo;t</em> reuse the <code>irep_node</code> tree, since the values for those query variables might be different from one execution to the next. Boo, hiss!</p>

<h3>Problem 2.3: A wacky preprocessing step is hard to understand</h3>

<p>I want to empower people to use GraphQL-Ruby in creative ways, but throwing a wacky, custom data structure in the mix doesn&rsquo;t make it easy. I think an easier execution model will encourage people to learn how it works and build cool new stuff!</p>

<h3>Solution: No preprocessing</h3>

<p>The new runtime evaluates the AST directly. Runtime features (<code>@skip</code> and <code>@include</code>, for example) are implemented at, well, <em>runtime</em>!</p>

<h3>Solution: AST Analyzers</h3>

<p>Since you can&rsquo;t use the <code>irep_node</code> tree for analysis anymore, the library includes a new module, <code>GraphQL::Analysis::AST</code>, for preprocessing queries. Shout out to <a href="https://github.com/xuorig">@xuorig</a> for this module!</p>

<h3>Solution: Moving ahead-of-time checks to runtime</h3>

<p>For GitHub, we moved a lot of analyzer behavior to runtime. We did this because it&rsquo;s easier to maintain and requires less GraphQL-specific knowledge to understand and modify. Although the client experience is <em>slightly</em> different, it&rsquo;s still good.</p>

<p>For example, we had an analyzer to check that pagination parameters (eg <code>first</code> and <code>last</code>) were valid. We moved this to runtime, adding it to our connection tooling.</p>

<h3>Solution: <code>GraphQL::Execution::Lookahead</code></h3>

<p><code>irep_node</code>s <em>were</em> useful for looking ahead in a query to see what fields would be selected next. (Honestly, they weren&rsquo;t <em>that good</em>, but they were the only thing we had, beside using the AST directly).</p>

<p>To support that use, we now have <code>extras: [:lookahead]</code> which will inject an instance of <code>GraphQL::Execution::Lookahead</code>, with an API <em>explicitly for</em> checking fields later in the query.</p>

<h2>Other considerations</h2>

<h3>Resolve procs are out</h3>

<p>As part of the change with removing <code>FieldResolutionContext</code>, the new runtime doesn&rsquo;t support proc-style resolvers <code>-&gt;(obj, args, ctx) {...}</code>. Besides <code>ctx</code>, the <code>args</code> objects (<code>GraphQL::Query::Arguments</code>) are not created by the interpreter either. Instead, the interpreter uses plain hashes.</p>

<p>Instead of procs, methods on Object type classes should be used.</p>

<p>This means that proc-based features are also not supported. Field instrumenters and middlewares won&rsquo;t be called; a new feature called field extensions should be used instead.</p>

<h3><code>.to_graphql</code> is <em>almost</em> out</h3>

<p>When the class-based schema API was added to GraphQL-Ruby, there was a little problem. The class-based API was great for developers, but the execution API expected legacy-style objects. The bridge was crossed via a compatibility layer: each type class had a <code>def self.to_graphql</code> method which returned a legacy-style object based on that class. Internally, the class and legacy object were cached together.</p>

<p>The interpreter <em>doesn&rsquo;t</em> use those legacy objects, only classes. So, any type extensions that you&rsquo;ve built will have to be supported on those <em>classes</em>.</p>

<p>The catch is, I&rsquo;m not <em>100% sure</em> that uses of legacy objects have all been migrated. In GitHub, we transitioned by delegating methods from the legacy objects to their source classes, and I haven&rsquo;t removed those delegations yet. So, there might still be uses of legacy objects 😅.</p>

<p>In a future version, I want to remove the use of those objects <em>completely</em>!</p>

<h1>Conclusion</h1>

<p>I hope this post has clarified some of the goals and approaches toward adding the new runtime. I&rsquo;m already building new features for it, like custom directives and better subscription support. If you have a question or concern, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> to discuss!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Notes on Small is Beautiful]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/11/16/notes-on-small-is-beautiful/"/>
    <updated>2018-11-16T10:10:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/11/16/notes-on-small-is-beautiful</id>
    <content type="html"><![CDATA[<p>I just finished reading <a href="https://en.wikipedia.org/wiki/Small_Is_Beautiful">E.F. Schumacher&rsquo;s <em>Small Is Beautiful: A Study of Economics As If People Mattered</em></a>, so I thought I&rsquo;d jot down a few impressions before I forgot them.</p>

<!-- more -->


<h2>Background</h2>

<p><a href="https://en.wikipedia.org/wiki/E._F._Schumacher">Schumacher</a> was a post-WWII British economist. He advised the British National Coal Board (the nationalized coal company) and rebuilding of postwar Germany.</p>

<p>The book was published in 1973, the same year as the <a href="https://en.wikipedia.org/wiki/1973_oil_crisis">oil crisis</a>, which raised some questions about our dependence on imported petroleum.</p>

<h2>Greed and Capitalism</h2>

<p>Schumacher returns again and again to a <a href="https://en.wikiquote.org/wiki/John_Maynard_Keynes#Economic_Possibilities_for_our_Grandchildren_(1930">quote from John Maynard Keynes</a>):</p>

<blockquote><p>For at least another hundred years we must pretend to ourselves and to everyone that fair is foul and foul is fair; for foul is useful and fair is not. Avarice and usury and precaution must be our gods for a little longer still.</p></blockquote>

<p>In context, Keynes is claiming that eventually, people will recognize will give up a love of money because they find that it doesn&rsquo;t satisfy. But first, a capitalist order must create material abundance.</p>

<p>For Schumacher, this triggers a series of conclusions:</p>

<ul>
<li>Capitalism is predicated on greed.</li>
<li>Greed may &ldquo;benefit&rdquo; the greedy, but it doesn&rsquo;t benefit other individuals or communities.</li>
<li>Since capitalism is built on greed, we shouldn&rsquo;t expect a rising tide to lift all boats. On the contrary, we can expect &ldquo;winners&rdquo; to build boat lifts to raise their own boats.</li>
<li>As a society, when we set our sights on accumulating wealth (for example, by celebrating the rich), we <em>promote</em> greed among ourselves. We shouldn&rsquo;t expect this to ever lead to the renunciation of material wealth.</li>
<li>Since the system is predicated on having <em>more</em>, we should never expect to have <em>enough</em>, and consequently, we shouldn&rsquo;t expect this order to bring any kind of peace.</li>
</ul>


<p>As a modern person, I ask myself, are we arriving at Keynes&rsquo;s expected conclusion? He wrote:</p>

<blockquote><p>When the accumulation of wealth is no longer of high social importance, there will be great changes in the code of morals.</p></blockquote>

<p>I wonder when that &ldquo;When&hellip;&rdquo; is/was expected to arrive.</p>

<h2>Human and Inhuman, Freedom and Order</h2>

<p>Schumacher&rsquo;s understanding of social malaise and environmental destruction boils down to a claim about organizational structure, something like: when an enterprise becomes so big that <em>ownership</em> becomes isolated from <em>execution</em>, it becomes inhuman (in the sense that decision-making can&rsquo;t be made with human-to-human perspective), and as a result, workers are reduced to cogs, natural resources are reduced to consumable inputs, and and the like.</p>

<p>Schumacher assumes (observes?) that when humans make decisions regarding their neighbors and hometowns, they are more likely to consider the non-economic factors of their decisions. For example, a non-economic factor might be a beautiful landscape, a creatively engaging endeavor, or caring for something (or someone) who can&rsquo;t care for itself. For a profit-oriented calculation at headquarters, these factors might be weighed less heavily.</p>

<p>To simplify one of Schumacher&rsquo;s maxims to address this issue, he suggests that <em>nothing should be centralized if it can be decentralized</em>. He acknowledges that some order is required in order for our larger societal goals to be accomplished, but also, he warns that <em>too much</em> order stunts many non-quantifiable joys in life. So, by decentralizing, you can engage human entrepreneurial spirit in a way that is healthy for the localities it impacts.</p>

<h2>Intermediate Technology</h2>

<p>A large section of the book (&ldquo;The Third World&rdquo;) addresses development in poor countries. Schumacher criticizes the dominant mode of development, namely, the installation of capital-intensive heavy industries in large cities. He cites several problems:</p>

<ul>
<li>The purchase of capital (eg, a factory) requires the poor country to take on debt from the rich country, leading to a kind of economic bondage</li>
<li>High-tech industries require a highly-educated workforce, which is often not available locally, so foreign workers (from rich countries) are employed instead of local people. Since Schumacher considers work (at its best) to be an edifying and satisfying experience, this deprives local people of an important benefit of the development.</li>
<li>High-tech, city-oriented development leads to a two-fold economy, where a metropolitan elite exists in a different sphere than their rural compatriots.</li>
<li>High-tech products can&rsquo;t be purchased locally, so they must be exported. This doesn&rsquo;t strengthen the local economy (eg, it doesn&rsquo;t foster more local businesses). Similarly, high-tech industries may require very refined inputs which are not available locally, so instead of using local inputs, the enterprise will depend on imports from elsewhere.</li>
</ul>


<p>Schumacher espouses a different approach, &ldquo;intermediate technology&rdquo;. In this approach, <em>gradual improvements</em> in technology are applied to slowly raise the level of economic activity in a community. For example, if human labor is readily available, a more low-capital, labor-intensive solution might be preferred to a high-capital, low-labor solution. For example, consumer goods might be made by hand instead of by machine, since that will employ more local people and can adapt to a greater variety of inputs. Additionally, <em>several</em> enterprises should be fostered, and they should target local markets, so that newly-employed people can participate in commerce with one another.</p>

<p>I have left out specific examples; the book is full of them.</p>

<p>You can see how this hangs on Schumacher&rsquo;s conviction that work can be good for people. In &ldquo;Buddhist Economics&rdquo;, he highlights some possible benefits of employment, for example:</p>

<ul>
<li>It challenges our ego by reminding us that we work together to accomplish things</li>
<li>It fosters social connections by bringing us into necessary contact with one another</li>
<li>It benefits individuals by developing their skill and wisdom</li>
<li>Finally, it produces the things a community needs to survive</li>
</ul>


<p>All these goods focus on the <em>people</em> involved in the enterprise, not the capital or products. Capital should be used in service to the <em>people</em>, not people in service to capital.</p>

<h2>Metaphysical Underpinnings for Economics</h2>

<p>In &ldquo;The Greatest Resource - Education&rdquo;, Schumacher points out the any economic theory rests on a &ldquo;meta-economics&rdquo;, that is, a set of assumptions about what <em>things are</em> and what <em>they mean</em>. He describes it as</p>

<blockquote><p>ideas that would make the world, and [our] own lives, intelligible to [us]; when a thing is intelligible, you have a sense of participation; when a thing is unintelligible, you have a sense of estrangement.</p></blockquote>

<p>Importantly, these things are absorbed and transmitted without our active recognition of it. Our minds are &ldquo;furnished&rdquo; by our communities without our awareness (much less our permission!).</p>

<p>When it comes to our own &ldquo;meta-economics&rdquo;, outlines several of our assumptions about the world:</p>

<ul>
<li>The universe is &ldquo;the outcome of accidental collocations of atoms&rdquo; (he quotes Bertand Russell)</li>
<li>The &ldquo;higher manifestations of life &hellip; are nothing but &hellip; a superstructure erected to disguise and promote economic interest&rdquo;, an application of reductionism to the human experience</li>
<li>&ldquo;[R]elativism, denying all absolutes, dissolving all norms and standards, leading to the total undermining of the idea of truth in pragmatism&hellip;&rdquo; I think this means, rejecting historical understandings of &ldquo;right&rdquo; and replacing them with &ldquo;might is right&rdquo;.</li>
<li>The notion that &ldquo;valid knowledge can be attained only through the natural sciences and hence that no knowledge is genuine unless it is based on generally observable facts.&rdquo; This may be contrasted with the claim that knowledge may be gained through qualitative means, like experience over time or intuitive exploration.</li>
</ul>


<p>For Schumacher, since these ideas give rise to our economics, they can also be understood as the source of our social ills. Since they&rsquo;re responsible for our sense of powerlessness, our quickness to consume and destroy the earth, and our dissatisfaction with these things, we can&rsquo;t expect <em>more</em> of the same to remedy those ills.</p>

<p>Schumacher also prescribes a suite of assumptions which he think will give rise to the kind of economics he espouses:</p>

<ul>
<li>The universe has a hierarchical structure (he says, &ldquo;Levels of Being&rdquo; or &ldquo;Grades of Significance&rdquo;) and it is &ldquo;[our] task &ndash; or simply, if you like, [our] happiness &ndash; to attain a higher degree of realization of [our] potentialities, a higher level of being or &lsquo;grade of significance&rsquo; than that which comes to [us] &lsquo;naturally&rsquo;.&rdquo;</li>
<li>Many important tasks in life require the <em>reconciliation of opposites</em>, and these tasks are not impossible. (&ldquo;How can one reconcile the demands of freedom and discipline in education? Countless mothers and teachers, in fact, do it, but no one can write down a solution.&rdquo;) These tasks (&ldquo;divergent&rdquo;) are contrasted with &ldquo;convergent&rdquo; tasks, such as solving equations or taking measurements, which require finding a solution without clear problem space.</li>
<li>There are virtues and vices. Virtues, which benefit individuals and communities, should be pursued oneself and encouraged in others, while vices, which injure individuals and communities, should be challenged within oneself and discouraged in others.</li>
</ul>


<p>Schumacher points to examples of these assumptions in several philosophical traditions outside post-Enlightenment Western thought.</p>

<p>(This post sat as a draft for a long time. I filled in the last part after returning the book.)</p>

<h2>A Theory of Large Organizations</h2>

<p>At the end of the book, Schumacher provides a <em>positive</em> theory of large organizations. Since I&rsquo;ve returned the book, I&rsquo;ll write the maxim that really stuck with me: anything that <em>can</em> be decentralized <em>should</em> be decentralized.</p>

<p>Toward the end of engaging peoples&#8217; entrepreneurial spirit, underlings should be given as much autonomy and authority as possible. Besides doing better work, the boots-on-the-ground folks can make more appropriate consideration of local context.</p>

<p>Schumacher also imagined a really interesting relationship between government and big business. He pointed out that the current arrangement of taxation creates some bizarre incentives: since only profit is taxed, companies work to hide profit from the government. It&rsquo;s impractical that the governemnt <em>builds</em> the infrastructure for businesses to thrive, then puts itself in the position of a bandit, trying to recapture (via taxation) its fair share of the gain.</p>

<p>What if, instead, big companies had the local government as a 50% shareholder? Shumacher proposes that the government party would be observer-only, except in circumstances when the local common good would require some representation. But, the government party would be entitled to 50% of the profit <em>instead</em> of taxing the business. In an arrangement like that, the business is incentivized to grow its profits, and the government doesn&rsquo;t have to fight to recapture its investment in business infrastructure.</p>

<p>I don&rsquo;t have any experience in that kind of large-scale thinking, but I found it an interesting scenario to imagine.</p>

<h2>Schumacher&rsquo;s Foundation</h2>

<p>Interestingly, Schumacher clearly builds his vision on a Christian understanding of humans and work. He sees humans as reflecting their creator&rsquo;s nature: creative, social, loving, and capable. At its best, work is not a necessary evil, but instead, it&rsquo;s a <em>good</em> part of culture where people can engage those attributes. That perspective orients his thoughts towards goals other than &ldquo;putting food on the table&rdquo; (although sustenance <em>is</em> a goal), for example, engendering pride in one&rsquo;s work, connections between neighbors, and the development and exercise of human skill.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trampolining]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/09/23/trampolining/"/>
    <updated>2018-09-23T21:04:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/09/23/trampolining</id>
    <content type="html"><![CDATA[<p>As part of my work on <a href="https://github.com/rmosolgo/graphql-ruby/pull/1394">improving GraphQL-Ruby&rsquo;s runtime performance</a>, I&rsquo;ve been reading <a href="http://www.eopl3.com/"><em>Essentials of Programming Languages</em></a>. Here, I try to apply their lesson about &ldquo;trampolining&rdquo;.</p>

<!-- more -->


<p><strong>TL;DR:</strong> I applied a thing I read in a textbook and it:</p>

<ul>
<li>reduced the stack trace size by 80%</li>
<li>reduced the live object count by 15%</li>
<li>kept the same runtime speed</li>
</ul>


<p>You can see the diff and benchmark results here: <a href="https://github.com/rmosolgo/graphql-ruby/compare/1b306fad...eef73b1">https://github.com/rmosolgo/graphql-ruby/compare/1b306fad&#8230;eef73b1</a></p>

<h2>The Problem</h2>

<p>It&rsquo;s a bit funny, but it&rsquo;s not <em>totally clear</em> to me what the book is trying to get at here. In the book, they talk about <em>control context</em> or <em>continuations</em> in a way that I would talk about &ldquo;stack frames&rdquo;. I think the problem is this: when you implement a programming language as an interpreter, you end up with recursive method calls, and that recursion builds up a big stack in the host language. This is bad because it hogs memory.</p>

<p>I can definitely <em>imagine</em> that this is a problem in Ruby, although I haven&rsquo;t measured it. GraphQL-Ruby uses recursion to execute GraphQL queries, and I can <em>imagine</em> that those recursive backtrace frames hog memory for a couple reasons:</p>

<ul>
<li>The control frames themselves (managed by YARV or something) take up memory in their own right</li>
<li>The control frames each have a lexical scope (<code>binding</code>), which, since it&rsquo;s still on the stack, can&rsquo;t be GCed. So, Ruby holds on to a lot of objects which <em>could</em> be garbaged collected if the library was written better.</li>
</ul>


<p>Besides that, the long backtrace adds a lot of noise when debugging.</p>

<h2>Trampolining</h2>

<p>In the book, they say, &ldquo;move your recursive calls to tail position, then, assuming your language has tail-call optimization, you won&rsquo;t have this problem.&rdquo; Well, my language <em>doesn&rsquo;t</em> have tail-call optimization, so I <em>do</em> have this problem! (Ok, it&rsquo;s an <a href="https://ruby-doc.org/core-2.4.0/RubyVM/InstructionSequence.html#method-c-compile_option-3D">option</a>.)</p>

<p>Luckily for me, they describe a technique for solving the problem <em>without</em> tail-call optimization. It&rsquo;s called <em>trampolining</em>, and it works roughly like this:</p>

<blockquote><p>When a method <em>would</em> make a recursive call, instead, return a <code>Bounce</code>. Then, the top-level method, which previously received the <code>FinalValue</code> of the interpreter&rsquo;s work, should be extended to accept <em>either</em> a <code>FinalValue</code> or a <code>Bounce</code>. In the case of a <code>FinalValue</code>, it returns the value as previously. In the case of a <code>Bounce</code>, it re-enters the interpreter using the &ldquo;bounced&rdquo; value.</p></blockquote>

<p>Using this technique, a previously-recursive method now <em>returns</em>, giving the caller some information about how to take the next step.</p>

<p>Let&rsquo;s give it a try.</p>

<h2>The Setup</h2>

<p>I want to test impact in two ways: memory consumption and backtrace size. I want to measure these values <em>during</em> GraphQL execution, so what better way to do it but build a GraphQL schema!</p>

<p>You can see the <a href="https://github.com/rmosolgo/graphql-ruby/compare/1b306fad...eef73b1#diff-7a29575d7b0f8a35812f9323ee46febe">whole benchmark</a>, but in short, we&rsquo;ll run a deeply-nested query, and at the deepest point, measure the <em>backtrace size</em> and the number of live objects in the heap:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">nestedMetric</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">nestedMetric</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">nestedMetric</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1"># ... more nesting ...</span>
</span><span class='line'>        <span class="n">nestedMetric</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">backtraceSize</span>
</span><span class='line'>          <span class="n">objectCount</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Where the fields are implemented by:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">backtrace_size</span>
</span><span class='line'>  <span class="nb">caller</span><span class="o">.</span><span class="n">size</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">object_count</span>
</span><span class='line'>  <span class="c1"># Make a GC pass</span>
</span><span class='line'>  <span class="no">GC</span><span class="o">.</span><span class="n">start</span>
</span><span class='line'>  <span class="c1"># Count how many objects are alive in the heap,</span>
</span><span class='line'>  <span class="c1"># subtracting the number of live objects before we started</span>
</span><span class='line'>  <span class="no">GC</span><span class="o">.</span><span class="n">stat</span><span class="o">[</span><span class="ss">:heap_live_slots</span><span class="o">]</span> <span class="o">-</span> <span class="nb">self</span><span class="o">.</span><span class="n">class</span><span class="o">.</span><span class="n">object_count_baseline</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;ll use these measurements to assess the impact of the refactor.</p>

<h2>The Pledge: Recursive calls</h2>

<p>To begin with, the interpreter is implemented as a set of recursive methods. The methods do things like:</p>

<ul>
<li>Given an object and a set of selections, resolve the selected fields on that object</li>
<li>Given a value and a type, prepare the value for a GraphQL response according to the type</li>
</ul>


<p>These methods are <em>recursive</em> in the case of fields that return GraphQL objects. The first method resolves a field and calls the second method; then the second method, in order to prepare an object as a GraphQL response, calls back to the first method, to resolve selections on that object. For example, execution might work like this:</p>

<ul>
<li>Resolve selections on the root object

<ul>
<li>One of the selections returned a User

<ul>
<li>Resolve selections on the User

<ul>
<li>One of the selections returns a Repository

<ul>
<li>Resolve selections on the Repository

<ul>
<li>&hellip;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>


<p>Do you see how the same procedure is being applied over and over, in a nested way? That&rsquo;s implemented with recursive calls in GraphQL-Ruby.</p>

<p>We can run our test to see how the Ruby execution context looks in this case:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># $ ruby test.rb</span>
</span><span class='line'><span class="mi">1</span><span class="n">b306fad3b6b35dd06248028883cd8a3ec4bdefd</span>
</span><span class='line'><span class="p">{</span><span class="s2">&quot;backtraceSize&quot;</span><span class="o">=&gt;</span><span class="mi">282</span><span class="p">,</span> <span class="s2">&quot;objectCount&quot;</span><span class="o">=&gt;</span><span class="mi">812</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is the baseline for backtrace size and object count, which we&rsquo;re using to measure <em>memory overhead</em> in GraphQL execution. (This describes behavior at <a href="https://github.com/rmosolgo/graphql-ruby/commit/2401afc4a19f2e5616e1e155f953ec403bf4896c">this commit</a>.)</p>

<h2>The Turn: Moving Recursive Calls into Tail Position</h2>

<p>As a requirement for the final refactor, we have to do some code reorganization. In the current code, the recursive calls require some setup and teardown around them. For example, we track the GraphQL &ldquo;path&rdquo;, which is the list of fields that describe where we are in the response. Here&rsquo;s a field with its &ldquo;path&rdquo;:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="n">a</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">b</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">c</span> <span class="c1"># The path of this field [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>In the code, it looks something like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Append to the path for the duration of the nested call</span>
</span><span class='line'><span class="vi">@path</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
</span><span class='line'><span class="c1"># Continue executing, with the new path in context</span>
</span><span class='line'><span class="n">execute_recursively</span><span class="p">(</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">)</span>
</span><span class='line'><span class="c1"># Remove the entry from `path`, since we&#39;re done here</span>
</span><span class='line'><span class="vi">@path</span><span class="o">.</span><span class="n">pop</span>
</span></code></pre></td></tr></table></div></figure>


<p>The problem is, if I want to refactor <code>execute_recursively</code> to become a <code>Bounce</code>, it won&rsquo;t do me any good, because the value of <code>execute_recursively</code> <em>isn&rsquo;t returned</em> from the method. It&rsquo;s not the last call in the method, so its value isn&rsquo;t returned. Instead, the value of <code>@path.pop</code> is returned. (It&rsquo;s not used for anything.)</p>

<p>This is to say: <code>@path.pop</code> is in <em>tail position</em>, the last call in the method. But I want <code>execute_recursively</code> to be in tail position.</p>

<h3>A Hack Won&rsquo;t Work</h3>

<p>The easiest way to &ldquo;fix&rdquo; that would be to refactor the method to return the value of <code>execute_recursively</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Append to the path for the duration of the nested call</span>
</span><span class='line'><span class="vi">@path</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
</span><span class='line'><span class="c1"># Continue executing</span>
</span><span class='line'><span class="n">return_value</span> <span class="o">=</span> <span class="n">execute_recursively</span><span class="p">(</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">)</span>
</span><span class='line'><span class="c1"># Remove the entry from `path`, since we&#39;re done here</span>
</span><span class='line'><span class="vi">@path</span><span class="o">.</span><span class="n">pop</span>
</span><span class='line'><span class="c1"># Manually return the execution value</span>
</span><span class='line'><span class="n">return_value</span>
</span></code></pre></td></tr></table></div></figure>


<p>The problem is, when <code>execute_recursively</code> is refactored to be a <code>Bounce</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Append to the path for the duration of the nested call</span>
</span><span class='line'><span class="vi">@path</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">field_name</span><span class="p">)</span>
</span><span class='line'><span class="c1"># Continue executing</span>
</span><span class='line'><span class="n">bounce</span> <span class="o">=</span> <span class="n">prepare_bounce</span><span class="p">(</span><span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">)</span>
</span><span class='line'><span class="c1"># Remove the entry from `path`, since we&#39;re done here</span>
</span><span class='line'><span class="vi">@path</span><span class="o">.</span><span class="n">pop</span>
</span><span class='line'><span class="c1"># Manually return the execution value</span>
</span><span class='line'><span class="n">bounce</span>
</span></code></pre></td></tr></table></div></figure>


<p>By the time the <code>bounce</code> is actually executed, <code>path</code> <em>won&rsquo;t have</em> the changes I need in it. The value is pushed <em>and popped</em> before the bounce is actually called.</p>

<h3>Pass the Path as Input</h3>

<p>The solution is to remove the need for <code>@path.pop</code>. This can be done by creating a <em>new path</em> and passing it as input.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Create a new path for nested execution</span>
</span><span class='line'><span class="n">new_path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="o">[</span><span class="n">field_name</span><span class="o">]</span>
</span><span class='line'><span class="c1"># Pass it as an input</span>
</span><span class='line'><span class="n">execute_recursively</span><span class="p">(</span><span class="n">new_path</span><span class="p">,</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, <code>execute_recursively</code> is in tail position!</p>

<p>(The actual refactor is here: <a href="https://github.com/rmosolgo/graphql-ruby/commit/ef6e94283ecf280b14fe5417a4ee6896a06ebe69">https://github.com/rmosolgo/graphql-ruby/commit/ef6e94283ecf280b14fe5417a4ee6896a06ebe69</a>)</p>

<h2>The Prestige: Make it Bounce</h2>

<p>Now, we want to replace recursive calls with a <em>bounce</em>, where a bounce is an object with enough information to continue execution at a later point in time.</p>

<p>Since my recursive interpreter is implemented with a bunch of stateless methods (they&rsquo;re stateless since the refactor above), I can create a Bounce class that will continue by calling the same method:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Bounce</span>
</span><span class='line'>  <span class="c1"># Take the inputs required to call the next method</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="nb">method</span><span class="p">,</span> <span class="o">*</span><span class="n">arguments</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@object</span> <span class="o">=</span> <span class="n">object</span>
</span><span class='line'>    <span class="vi">@method</span> <span class="o">=</span> <span class="nb">method</span>
</span><span class='line'>    <span class="vi">@arguments</span> <span class="o">=</span> <span class="n">arguments</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># Continue by calling the method with the given inputs</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">continue</span>
</span><span class='line'>    <span class="vi">@object</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="vi">@method</span><span class="p">,</span> <span class="o">*</span><span class="vi">@arguments</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then, I replace the tail-position recursive calls with bounces:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'><span class="gd">- execute_recursively(...)</span>
</span><span class='line'><span class="gi">+ Bounce.new(self, :execute_recursively, ...)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Instead of <em>growing</em> the backtrace by calling another method, we&rsquo;ll be <em>shrinking</em> the backtrace by returning from the current method with a Bounce.</p>

<p>You can see the refactor here: <a href="https://github.com/rmosolgo/graphql-ruby/commit/b8e51573652b736d67235080e8b450d6fc9cc92e">https://github.com/rmosolgo/graphql-ruby/commit/b8e51573652b736d67235080e8b450d6fc9cc92e</a></p>

<h3>How&rsquo;d it work?</h3>

<p>Let&rsquo;s run the test:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># $ ruby test.rb</span>
</span><span class='line'><span class="n">b8e51573652b736d67235080e8b450d6fc9cc92e</span>
</span><span class='line'><span class="p">{</span><span class="s2">&quot;backtraceSize&quot;</span><span class="o">=&gt;</span><span class="mi">55</span><span class="p">,</span> <span class="s2">&quot;objectCount&quot;</span><span class="o">=&gt;</span><span class="mi">686</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>It&rsquo;s a success! The <code>backtraceSize</code> decreased from 282 to 55. The <code>objectCount</code> decreased from <code>812</code> to <code>686</code>.</p>

<h3>Implementation Considerations</h3>

<p><strong>&ldquo;Trampolining&rdquo;</strong> is the process of taking each bounce and continuing it. In my first implementation, <code>def trampoline</code> looked like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Follow all the bounces until there aren&#39;t any left</span>
</span><span class='line'><span class="k">def</span> <span class="nf">trampoline</span><span class="p">(</span><span class="n">bounce</span><span class="p">)</span>
</span><span class='line'>  <span class="k">case</span> <span class="n">bounce</span>
</span><span class='line'>  <span class="k">when</span> <span class="no">Bounce</span>
</span><span class='line'>    <span class="n">trampoline</span><span class="p">(</span><span class="n">bounce</span><span class="o">.</span><span class="n">continue</span><span class="p">)</span>
</span><span class='line'>  <span class="k">when</span> <span class="nb">Array</span>
</span><span class='line'>    <span class="n">bounce</span><span class="o">.</span><span class="n">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">b</span><span class="o">|</span> <span class="n">trampoline</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="c1"># not a bounce, do nothing</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>My test indicated no improvement in memory overhead, so I frustratedly called it quits. While brushing my teeth before bed, it hit me! I had unwittingly <em>re-introduced</em> recursive method calls. So, I hurried downstairs and reimplemented <code>def trampoline</code> to use a <code>while</code> loop and a buffer of bounces, an approach which didn&rsquo;t grow the Ruby execution context. Then the test result was much better.</p>

<p>Another consideration is the <em>overhead of Bounces</em> themselves. My first implementation creates a bounce before resolving each field. For very large responses, this will add a lot of overhead, especially when the field is a simple leaf value. This should be improved somehow.</p>

<h2>What about Speed?</h2>

<p>It turns out that visitors to the website don&rsquo;t care about backtrace size or Ruby heap size, they just care about waiting for webpages to load. Lucky for me, my benchmark includes some runtime measurements, and the results were basically the same:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'># before
</span><span class='line'>Calculating -------------------------------------
</span><span class='line'>                         92.144  (±10.9%) i/s -    456.000  in   5.022617s
</span><span class='line'># after
</span><span class='line'>Calculating -------------------------------------
</span><span class='line'>                        113.529  (± 7.9%) i/s -    567.000  in   5.031847s
</span></code></pre></td></tr></table></div></figure>


<p>The runtime performance was very similar, almost within the margin of error. However, the consideration of Bounce overhead described above could cause <em>worse</em> performance in some cases.</p>

<h2>What&rsquo;s next?</h2>

<p>This code isn&rsquo;t <em>quite</em> ready for GraphQL-Ruby, but I think it&rsquo;s promising for a few reasons:</p>

<ul>
<li>The reduction of memory overhead and backtrace noise could pay off for very large, nested queries</li>
<li>I might be able to leverage bounces to give the caller more control over how GraphQL queries are executed. For example, at GitHub, we use GraphQL queries when rendering HTML pages. With some work, maybe we could alternate between bouncing GraphQL and rendering HTML, so we&rsquo;d get a better progressive rendering experience on the front end.</li>
</ul>


<p>However, one serious issue still needs to be addressed: what about the <code>Bounce</code>&rsquo;s <em>own</em> overhead? Allocating a new object for <em>every field execution</em> is already a performance issue in GraphQL-Ruby, and I&rsquo;m trying hard to remove it. So the implementation will need to be more subtle in that regard.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Trip Report: Balkan Ruby 2018]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/06/14/trip-report-balkan-ruby-2018/"/>
    <updated>2018-06-14T15:02:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/06/14/trip-report-balkan-ruby-2018</id>
    <content type="html"><![CDATA[<p>This May, I had the opportunity to attend <a href="https://balkanruby.com/">Balkan Ruby</a> and present on my work with <a href="https://github.com/rmosolgo/graphql-ruby">graphql-ruby</a>.</p>

<!-- more -->


<p>Here are a few thoughts about the trip.</p>

<h2>The Conference</h2>

<p>Balkan Ruby was a big hit. Personally, some of my favorites were:</p>

<ul>
<li>Zach Holman&rsquo;s opening talk about datetimes and timezones (which became a <a href="https://zachholman.com/talk/utc-is-enough-for-everyone-right">blog post</a> and inspired a <a href="https://github.com/rmosolgo/graphql-ruby/pull/1566">GraphQL-Ruby ISO8601 scalar type</a>)</li>
<li>Sameer Deshmukh&rsquo;s presentation about various <a href="https://github.com/sciruby">SciRuby</a> projects</li>
<li>Marko Bogdanović&rsquo;s talk about <a href="https://rubybench.org/">RubyBench</a>, which was a really cool project and made me want something like it for GraphQL-Ruby.</li>
</ul>


<p>One of my favorite parts of the conference was the code challenges set up by <a href="">Receipt Bank</a>, one of the sponsors.</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/challenge.png" width="500"></p>

<p>Every few hours, a new, wacky challenge would go live. Although I didn&rsquo;t do well on them, I enjoyed working with a few new friends on different solutions, and seeing the creative things that other attendees submitted!</p>

<h2>The City</h2>

<p>Sofia was <strong>great</strong>. A beautiful city with interesting architecture, tons of trees and tasty food.</p>

<p>The Nevski Cathedral was built in the early 1900s to celebrate Russia&rsquo;s liberation of Bulgaria from the Ottomans:</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/nevski.png" width="500"></p>

<p>Inside, a mural of Abraham and Isaac:</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/abraham.png" width="500"></p>

<p>And St. Cyril and St. Methodius, creators of the Cyrillic alphabet, who are quite popular around here:</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/saints.png" width="500"></p>

<p>I really enjoyed the different cathedrals. There&rsquo;s something cool about the different instructive artwork and &ldquo;sacred&rdquo; feeling of a beautiful building with incense burning. I wonder if modern American churches could do more to engage all of our senses.</p>

<p>Also, a bit of Soviet history found in a nearby park:</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/soviet.png" width="500"></p>

<p>And here, some recently excavated Roman ruins, and the one remaining Turkish mosque downtown:</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/ruins.png" width="500"></p>

<p>The mosque was right beside ruins of an old bathhouse. Apparently that&rsquo;s why Sofia was founded here &ndash; there were hot springs on the road between Rome and Constantinople, so the Romans set up camp (and called it Serdica).</p>

<p>And a fairly typical meal during my time there, a <em>shopska</em> salad (veggies with cheese, oil, and vinegar):</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/food.png" width="500"></p>

<p>I can&rsquo;t say enough good things about the local dairy products. The cheese was soft and fresh and the yogurt was tart and refreshing.</p>

<h2>The Organizers</h2>

<p>My favorite part about programming conferences is meeting the smart, caring folks who make them possible, and Balkan Ruby was no exception.</p>

<p>The two main organizers, <a href="https://twitter.com/gsamokovarov">Genadi</a> and <a href="https://twitter.com/vestimir">Vestimir</a> were fantastic hosts (and experienced, since they got their start with Euruko a few years back). Besides that, I really enjoyed meeting the volunteers and learning a bit about life in Sofia.</p>

<p>One thing that stood out to me was the tradition behind the local liquor, rakia. It turns out that many families make it themselves, despite a law against owning stills. I&rsquo;ve been reading that peach wine was the traditional alcoholic drink for the earliest European arrivals to my area, so I decided to give it a shot this summer!</p>

<p>A big bonus was when Vestimir played trail guide for our hike up the nearby mountain, Mt. Vitosha. It turned out to be a gray day, but we had a blast anyways.</p>

<p>Some pictures of the trail:</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/trail1.png" width="500"></p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/trail2.png" width="500"></p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/trail3.png" width="500"></p>

<p>Beautiful! But you could say were were <em>a bit</em> underdressed XD</p>

<p>At the summit, we were happy to find a lodge where some food was served.</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/hut.png" width="500"></p>

<p>Some traditional bean soup, bread, <a href="https://en.wikipedia.org/wiki/Ljutenica">lyutenitsa</a>, cheese tea, and rakia never tasted so good.</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/snack.png" width="500"></p>

<p>Enjoying a rest:</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/group.png" width="500"></p>

<p>(Left-to-right: Andreas, Nynne, Sameer, Me and Vestimir)</p>

<p>And, pleasantly, we caught a nice view of Sofia on the way back down:</p>

<p><img src="http://rmosolgo.github.io/images/balkan_ruby_2018/overlook.png" width="500"></p>

<p>(You can even see the Nevski cathedral if you look closely!)</p>

<h2>Closing Thoughts</h2>

<p>Balkan Ruby was a big hit on all fronts: great people, great city, great technical content. Especially as a dairy lover, I&rsquo;ll take the next chance I get to go back! And I loved making some new friends, who I hope to see at future Ruby events.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How Ripper parses variables]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/05/21/how-ripper-parses-variables/"/>
    <updated>2018-05-21T14:11:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/05/21/how-ripper-parses-variables</id>
    <content type="html"><![CDATA[<p>Ruby has a few different kinds of variables, and Ripper expresses them with a few different nodes.</p>

<!-- more -->


<p>Here are the different variables in Ruby:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">a</span>   <span class="c1"># Local variable (or method call on self)</span>
</span><span class='line'><span class="vg">$a</span>  <span class="c1"># Global variable</span>
</span><span class='line'><span class="n">A</span>   <span class="c1"># Constant</span>
</span><span class='line'><span class="vi">@a</span>  <span class="c1"># Instance variable</span>
</span><span class='line'><span class="vc">@@a</span> <span class="c1"># Class variable</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Bonus, not variables:</span>
</span><span class='line'><span class="n">a</span><span class="p">()</span>       <span class="c1"># explicit method call (with parens) on implicit self</span>
</span><span class='line'><span class="n">a</span> <span class="n">b</span>       <span class="c1"># explicit method call (with args) on implicit self</span>
</span><span class='line'><span class="nb">self</span><span class="o">.</span><span class="n">a</span>    <span class="c1"># explicit method call (with dot) on explicit self</span>
</span></code></pre></td></tr></table></div></figure>


<p>Here is how Ripper parses the above code:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Ripper.sexp_raw(...) =&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">[</span><span class="ss">:program</span><span class="p">,</span>
</span><span class='line'> <span class="o">[</span><span class="ss">:stmts_add</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:stmts_add</span><span class="p">,</span>
</span><span class='line'>   <span class="o">[</span><span class="ss">:stmts_add</span><span class="p">,</span>
</span><span class='line'>    <span class="o">[</span><span class="ss">:stmts_add</span><span class="p">,</span>
</span><span class='line'>     <span class="o">[</span><span class="ss">:stmts_add</span><span class="p">,</span>
</span><span class='line'>      <span class="o">[</span><span class="ss">:stmts_add</span><span class="p">,</span>
</span><span class='line'>       <span class="o">[</span><span class="ss">:stmts_add</span><span class="p">,</span>
</span><span class='line'>        <span class="o">[</span><span class="ss">:stmts_add</span><span class="p">,</span> <span class="o">[</span><span class="ss">:stmts_new</span><span class="o">]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:vcall</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]]</span><span class="p">,</span>
</span><span class='line'>        <span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@gvar</span><span class="p">,</span> <span class="s2">&quot;$a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]]</span><span class="p">,</span>
</span><span class='line'>       <span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@const</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]]</span><span class="p">,</span>
</span><span class='line'>      <span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ivar</span><span class="p">,</span> <span class="s2">&quot;@a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]]</span><span class="p">,</span>
</span><span class='line'>     <span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@cvar</span><span class="p">,</span> <span class="s2">&quot;@@a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]]</span><span class="p">,</span>
</span><span class='line'>    <span class="o">[</span><span class="ss">:method_add_arg</span><span class="p">,</span> <span class="o">[</span><span class="ss">:fcall</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:arg_paren</span><span class="p">,</span> <span class="kp">nil</span><span class="o">]]]</span><span class="p">,</span>
</span><span class='line'>   <span class="o">[</span><span class="ss">:command</span><span class="p">,</span>
</span><span class='line'>    <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]</span><span class="p">,</span>
</span><span class='line'>    <span class="o">[</span><span class="ss">:args_add_block</span><span class="p">,</span>
</span><span class='line'>     <span class="o">[</span><span class="ss">:args_add</span><span class="p">,</span> <span class="o">[</span><span class="ss">:args_new</span><span class="o">]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:vcall</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="o">]]]]</span><span class="p">,</span>
</span><span class='line'>     <span class="kp">false</span><span class="o">]]]</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:call</span><span class="p">,</span> <span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@kw</span><span class="p">,</span> <span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]</span><span class="p">,</span> <span class="ss">:&quot;.&quot;</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5</span><span class="o">]]]]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>(<a href="https://ripper-preview.herokuapp.com/?code=a+++%23+Local+variable+%28or+method+call+on+self%29%0D%0A%24a++%23+Global+variable%0D%0AA+++%23+Constant%0D%0A%40a++%23+Instance+varaible%0D%0A%40%40a+%23+Class+variable%0D%0A%0D%0A%23+Bonus%2C+not+variables%3A%0D%0Aa%28%29+++++++%23+explicit+method+call+%28with+parens%29+on+implicit+self%0D%0Aself.a++++%23+explicit+method+call+%28with+dot%29+on+explicit+self">Ripper-preview</a>)</p>

<p>Let&rsquo;s check out those nodes.</p>

<h3>:vcall</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># a</span>
</span><span class='line'><span class="o">[</span><span class="ss">:vcall</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>A <code>:vcall</code> is a bareword, either a local variable lookup <em>or</em> a method call on self. Used alone, this can only be determined at runtime, depending on the binding. If there&rsquo;s a local variable, it will be used. My guess is that <code>:vcall</code> is short for &ldquo;variable/call&rdquo;</p>

<p>Interestingly, there is a single-expression case which <em>could</em> be disambiguated statically, but Ripper still uses <code>:vcall</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># a b</span>
</span><span class='line'><span class="o">[</span><span class="ss">:command</span><span class="p">,</span>
</span><span class='line'> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]</span><span class="p">,</span>
</span><span class='line'> <span class="o">[</span><span class="ss">:args_add_block</span><span class="p">,</span>
</span><span class='line'>  <span class="o">[</span><span class="ss">:args_add</span><span class="p">,</span> <span class="o">[</span><span class="ss">:args_new</span><span class="o">]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:vcall</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">]]]]</span><span class="p">,</span>
</span><span class='line'>  <span class="kp">false</span><span class="o">]]]]</span>
</span></code></pre></td></tr></table></div></figure>


<h3>:var_ref</h3>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># $a</span>
</span><span class='line'><span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@gvar</span><span class="p">,</span> <span class="s2">&quot;$a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]</span>
</span><span class='line'><span class="c1"># A</span>
</span><span class='line'><span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@const</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]</span>
</span><span class='line'><span class="c1"># @a</span>
</span><span class='line'><span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ivar</span><span class="p">,</span> <span class="s2">&quot;@a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]</span>
</span><span class='line'><span class="c1"># @@aa</span>
</span><span class='line'><span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@cvar</span><span class="p">,</span> <span class="s2">&quot;@@a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]</span>
</span></code></pre></td></tr></table></div></figure>


<p><code>:var_ref</code> (presumably &ldquo;variable reference&rdquo;) is shared by many of these examples, and can always be resolved to a <em>variable</em> lookup, never a method call.
Its argument tells what kind of lookup to do (global, constant, instance, class), and what name to look up.</p>

<h3>Method calls</h3>

<p>Some Ruby can be statically known to be a method call, <em>not</em> a variable lookup:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># a(), explicit method call (with parens) on implicit self</span>
</span><span class='line'><span class="o">[</span><span class="ss">:method_add_arg</span><span class="p">,</span> <span class="o">[</span><span class="ss">:fcall</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:arg_paren</span><span class="p">,</span> <span class="kp">nil</span><span class="o">]]</span>
</span><span class='line'><span class="c1"># self.a, explicit method call (with dot) on explicit self</span>
</span><span class='line'><span class="o">[</span><span class="ss">:call</span><span class="p">,</span> <span class="o">[</span><span class="ss">:var_ref</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@kw</span><span class="p">,</span> <span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]]</span><span class="p">,</span> <span class="ss">:&quot;.&quot;</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="o">]]]</span>
</span><span class='line'><span class="c1"># a b, explicit method call (with arguments) on implicit self</span>
</span><span class='line'><span class="o">[</span><span class="ss">:command</span><span class="p">,</span>
</span><span class='line'>   <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="o">]]</span><span class="p">,</span>
</span><span class='line'>   <span class="o">[</span><span class="ss">:args_add_block</span><span class="p">,</span>
</span><span class='line'>    <span class="o">[</span><span class="ss">:args_add</span><span class="p">,</span> <span class="o">[</span><span class="ss">:args_new</span><span class="o">]</span><span class="p">,</span> <span class="o">[</span><span class="ss">:vcall</span><span class="p">,</span> <span class="o">[</span><span class="ss">:@ident</span><span class="p">,</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="o">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">2</span><span class="o">]]]]</span><span class="p">,</span>
</span><span class='line'>    <span class="kp">false</span><span class="o">]]]</span>
</span></code></pre></td></tr></table></div></figure>


<p>In these cases, <code>:fcall</code>, <code>:call</code> and <code>:command</code> are used to represent definite method sends.</p>

<p>Interestingly, <code>:var_ref</code> is used for <code>self</code>, too.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Updating GitHub to GraphQL 1.8.0]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0/"/>
    <updated>2018-04-09T09:52:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0</id>
    <content type="html"><![CDATA[<p>GraphQL 1.8.0 was designed and built largely as a part of my work at GitHub. Besides designing the <a href="http://graphql-ruby.org/schema/class_based_api">new Schema definition API</a>, I migrated our codebase to use it. Here are some field notes from my migration.</p>

<!-- more -->


<p>If you want to know more about the motivations behind this work, check out this <a href="http://rmosolgo.github.io/blog/2018/03/25/why-a-new-schema-definition-api/">previous post</a>.</p>

<p>Below, I&rsquo;ll cover:</p>

<ul>
<li>The Process: in general, how I went about migrating our code</li>
<li>The Upgrader: how to run it and roughly how it&rsquo;s organized</li>
<li>Custom Transforms: extensions I made for the upgrader to work on GitHub-specific code</li>
<li>Fixes By Hand: bits of code that needed more work (some of these could be automated, but aren&rsquo;t yet!)</li>
<li>Porting Relay Types: using the class-based API for connections and edges</li>
<li>Migrating DSL extensions: how to support custom GraphQL extension in the new API</li>
</ul>


<h2>The Process</h2>

<p>GitHub&rsquo;s type definitions are separated into folders by type, for example: <code>objects/</code>, <code>unions/</code>, <code>enums/</code> (and <code>mutations/</code>). I worked through them one folder at a time. The <code>objects/</code> folder was big, so I did it twenty or thirty files at a time.</p>

<p>I had to do <code>interfaces/</code> last because of the nature of the new class-based schema. Interfaces modules&#8217; methods can&rsquo;t be added to legacy-style GraphQL object types. So, by doing interfaces last, I didn&rsquo;t have to worry about this compatibility issue.</p>

<p>Now that I remember it, I did the schema <em>first</em>, and by hand. It was a pretty easy upgrade.</p>

<p>When I started each section, I created a base class by hand. (There is some automated support for this, but I didn&rsquo;t use it.) Then, I ran the upgrader on some files and tried to run the test suite. There were usually two kinds of errors:</p>

<ul>
<li>Parse- or load-time errors which prevented the app from booting</li>
<li>Runtime errors which resulted in unexpected behavior or raised errors</li>
</ul>


<p>More on these errors below.</p>

<p>After upgrading a section of the schema, I opened a PR for review from the team. This was crucial: since I was working at such a large scale, it was easy for me to miss the trees for the forest. My teammates caught a lot of things during the process!</p>

<p>After a review, the PR would be merged into master. Since GraphQL 1.8.0 supports incremental migration, I could work through the code in chunks without a long running branch or feature flags.</p>

<h2>About the Upgrader</h2>

<p>Here&rsquo;s an overview of how the upgrader works. After reading the overview, if you want some specific examples, check out the <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/upgrader/member.rb">source code</a>.</p>

<h3>Running The Upgrader</h3>

<p>The gem includes an auto-upgrader, spearheaded by the folks at <a href="https://hackerone.com">HackerOne</a> and refined during my use of it. It&rsquo;s encapsulated in a class, <code>GraphQL::Upgrader::Member</code>.</p>

<p>To use the upgrader, I added a Ruby script to the code base called <code>graphql-update.rb</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Usage:</span>
</span><span class='line'><span class="c1">#   ruby graphql-update.rb path/to/type_definition.rb</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1"># Example:</span>
</span><span class='line'><span class="c1">#   # Upgrade `BlameRange`</span>
</span><span class='line'><span class="c1">#   ruby graphql-update.rb lib/platform/objects/blame_range.rb</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1">#   # Upgrade based on a pattern (use quotes)</span>
</span><span class='line'><span class="c1">#   ruby graphql-update.rb &quot;lib/platform/objects/blob_\*.rb&quot;</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1">#   # Upgrade one more file in this pattern (use quotes)</span>
</span><span class='line'><span class="c1">#   ruby graphql-update.rb 1 &quot;lib/platform/objects/**.rb&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Load the upgrader from local code, for easier trial-and-error development</span>
</span><span class='line'><span class="c1"># require &quot;~/code/graphql-ruby/lib/graphql/upgrader/member&quot;</span>
</span><span class='line'><span class="c1"># Load the upgrader from the Gem:</span>
</span><span class='line'><span class="nb">require</span> <span class="s2">&quot;graphql/upgrader/member&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Accept two arguments: next_files (optional), file_pattern (required)</span>
</span><span class='line'><span class="n">file_pattern</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span>
</span><span class='line'><span class="k">if</span> <span class="n">file_pattern</span> <span class="o">=~</span> <span class="sr">/\d+/</span>
</span><span class='line'>  <span class="n">next_files</span> <span class="o">=</span> <span class="n">file_pattern</span><span class="o">.</span><span class="n">to_i</span>
</span><span class='line'>  <span class="n">next_files_pattern</span> <span class="o">=</span> <span class="no">ARGV</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span>
</span><span class='line'>  <span class="s2">&quot;Upgrading </span><span class="si">#{</span><span class="n">next_files</span><span class="si">}</span><span class="s2"> more files in </span><span class="si">#{</span><span class="n">next_files_pattern</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="n">filenames</span> <span class="o">=</span> <span class="no">Dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">next_files_pattern</span><span class="p">)</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="n">filenames</span> <span class="o">=</span> <span class="no">Dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">file_pattern</span><span class="p">)</span>
</span><span class='line'>  <span class="n">next_files</span> <span class="o">=</span> <span class="kp">nil</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;Upgrading </span><span class="si">#{</span><span class="n">filenames</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;, &quot;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># ...</span>
</span><span class='line'><span class="c1"># Lots of custom rules here, see below</span>
</span><span class='line'><span class="c1"># ...</span>
</span><span class='line'>
</span><span class='line'><span class="no">CUSTOM_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">type_transforms</span><span class="p">:</span> <span class="n">type_transforms</span><span class="p">,</span>
</span><span class='line'>  <span class="n">field_transforms</span><span class="p">:</span> <span class="n">field_transforms</span><span class="p">,</span>
</span><span class='line'>  <span class="n">clean_up_transforms</span><span class="p">:</span> <span class="n">clean_up_transforms</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">skip</span><span class="p">:</span> <span class="no">CustomSkip</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">upgraded</span> <span class="o">=</span> <span class="o">[]</span>
</span><span class='line'><span class="n">filenames</span><span class="o">.</span><span class="n">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">filename</span><span class="o">|</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;Begin (</span><span class="si">#{</span><span class="n">filename</span><span class="si">}</span><span class="s2">)&quot;</span>
</span><span class='line'>  <span class="c1"># Read the file into a string</span>
</span><span class='line'>  <span class="n">original_text</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># Create an Upgrader with the set of custom transforms</span>
</span><span class='line'>  <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Upgrader</span><span class="o">::</span><span class="no">Member</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">original_text</span><span class="p">,</span> <span class="o">**</span><span class="no">CUSTOM_TRANSFORMS</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># Generate updated text</span>
</span><span class='line'>  <span class="n">transformed_text</span> <span class="o">=</span> <span class="n">upgrader</span><span class="o">.</span><span class="n">upgrade</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">transformed_text</span> <span class="o">==</span> <span class="n">original_text</span>
</span><span class='line'>    <span class="c1"># No upgrade was performed</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="c1"># If the upgrade was successful, update the source file</span>
</span><span class='line'>    <span class="no">File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">transformed_text</span><span class="p">)</span>
</span><span class='line'>    <span class="n">upgraded</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;Done (</span><span class="si">#{</span><span class="n">filename</span><span class="si">}</span><span class="s2">)&quot;</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">next_files</span> <span class="o">&amp;&amp;</span> <span class="n">upgraded</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">next_files</span>
</span><span class='line'>    <span class="c1"># We&#39;ve upgraded as many as we said we would</span>
</span><span class='line'>    <span class="k">break</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="nb">puts</span> <span class="s2">&quot;Upgraded </span><span class="si">#{</span><span class="n">upgraded</span><span class="o">.</span><span class="n">size</span><span class="si">}</span><span class="s2"> files: </span><span class="se">\n</span><span class="si">#{</span><span class="n">upgraded</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>This script has two basic parts:</p>

<ul>
<li>Using <code>GraphQL::Upgrader::Member</code> with a set of custom transformations</li>
<li>Supporting code: accepting input, counting files, logging, etc</li>
</ul>


<p>In your own script, you can write whatever supporting code you want. The key part from GraphQL-Ruby is:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Create an Upgrader with the set of custom transforms</span>
</span><span class='line'><span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Upgrader</span><span class="o">::</span><span class="no">Member</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">original_text</span><span class="p">,</span> <span class="o">**</span><span class="no">CUSTOM_TRANSFORMS</span><span class="p">)</span>
</span><span class='line'><span class="c1"># Generate updated text</span>
</span><span class='line'><span class="n">transformed_text</span> <span class="o">=</span> <span class="n">upgrader</span><span class="o">.</span><span class="n">upgrade</span>
</span></code></pre></td></tr></table></div></figure>


<h3>The Pipeline</h3>

<p>The upgrader is structured as a pipeline: each step accepts a big string of input and returns a big string of output. Sometimes, a step does nothing and so its returned string is the same as the input string. In general, the transforms consist of two steps:</p>

<ul>
<li>Check whether the transform applies to the given input</li>
<li>If it does, copy the string and apply a find-and-replace to it (sometimes using RegExp, other times using the excellent <code>parser</code> gem.)</li>
</ul>


<p>You have a few options for customizing the transformation pipeline:</p>

<ul>
<li>Write new transforms and add them to the pipeline</li>
<li>Remove transforms from the pipeline</li>
<li>Re-use the built-in transforms, but give them different parameters, then replace the built-in one with your custom instance</li>
</ul>


<p>(The &ldquo;pipeline&rdquo; is just an array of instances or subclasses of <code>GraphQL::Upgrader::Transform</code>.)</p>

<p>We&rsquo;ll see cases of each below.</p>

<h3>Kinds of Transforms</h3>

<p>The upgrader accepts several types of transform pipelines:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">CUSTOM_TRANSFORMS</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">type_transforms</span><span class="p">:</span> <span class="n">type_transforms</span><span class="p">,</span>
</span><span class='line'>  <span class="n">field_transforms</span><span class="p">:</span> <span class="n">field_transforms</span><span class="p">,</span>
</span><span class='line'>  <span class="n">clean_up_transforms</span><span class="p">:</span> <span class="n">clean_up_transforms</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">skip</span><span class="p">:</span> <span class="no">CustomSkip</span><span class="p">,</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><code>type_transforms</code> are run first, on the <em>entire</em> file.</li>
<li><code>field_transforms</code> are run second, but they receive <em>parts</em> of the type definition. They receive calls to <code>field</code>, <code>connection</code>, <code>return_field</code>, <code>input_field</code>, and <code>argument</code>. Fine-grained changes to field definition or argument definition go here.</li>
<li><code>clean_up_transforms</code> are run last, on the <em>entire</em> file. For example, there&rsquo;s a built-in <code>RemoveExcessWhitespaceTransform</code> which cleans up trailing spaces after other transforms have run.</li>
<li><code>skip:</code> has a special function: its <code>#skip?(input)</code> method is called and if it returns true, the text is not transformed at all. This allows the transformer to be idempotent: by default, if you run it on the same file over and over, it will update the file only <em>once</em>.</li>
</ul>


<h2>Custom Transforms</h2>

<p>Here are some custom transforms applied to our codebase.</p>

<h3>Handle a custom type-definition DSL</h3>

<p>We had a wrapper around <code>ObjectType.define</code> which attached metadata, linking the object type to a specific Rails model. The helper was called <code>define_active_record_type</code>. I wanted to take this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Platform</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Objects</span>
</span><span class='line'>    <span class="no">Issue</span> <span class="o">=</span> <span class="n">define_active_record_type</span><span class="p">(</span><span class="o">-&gt;</span> <span class="p">{</span> <span class="o">::</span><span class="no">Issue</span> <span class="p">})</span> <span class="k">do</span>
</span><span class='line'>      <span class="c1"># ...</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>And make it this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Platform</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Objects</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">Issue</span> <span class="o">&lt;</span> <span class="ss">Platform</span><span class="p">:</span><span class="ss">:Objects</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>      <span class="n">model_name</span> <span class="s2">&quot;Issue&quot;</span>
</span><span class='line'>      <span class="c1"># ...</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Fortunately, this can be done with a pretty straightforward regular expression substitution. Here&rsquo;s the transform:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Create a custom transform for our `define_active_record_type` factory:</span>
</span><span class='line'><span class="k">class</span> <span class="nc">ActiveRecordTypeToClassTransform</span> <span class="o">&lt;</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Upgrader</span><span class="o">::</span><span class="no">Transform</span>
</span><span class='line'>  <span class="c1"># Capture: leading whitespace, type name, model name</span>
</span><span class='line'>  <span class="no">FIND_PATTERN</span> <span class="o">=</span> <span class="sr">/^( +)([a-zA-Z_0-9:]*) = define_active_record_type\(-&gt; ?\{ ?:{0,2}([a-zA-Z_0-9:]*) ?\} ?\) do/</span>
</span><span class='line'>  <span class="c1"># Restructure as a class, using the leading whitespace and adding the `model_name` DSL</span>
</span><span class='line'>  <span class="no">REPLACE_PATTERN</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">1class </span><span class="se">\\</span><span class="s2">2 &lt; Platform::Objects::Base</span><span class="se">\n\\</span><span class="s2">1  model_name </span><span class="se">\&quot;\\</span><span class="s2">3</span><span class="se">\&quot;</span><span class="s2">&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="n">input_text</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># It&#39;s safe to apply this transform to _all_ input,</span>
</span><span class='line'>    <span class="c1"># since it&#39;s a no-op if `FIND_PATTERN` is missing.</span>
</span><span class='line'>    <span class="n">input_text</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="no">FIND_PATTERN</span><span class="p">,</span> <span class="no">REPLACE_PATTERN</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then, in <code>graphql-update.rb</code>, this transform was put <em>first</em> in the list:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># graphql-update.rb</span>
</span><span class='line'><span class="n">type_transforms</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Upgrader</span><span class="o">::</span><span class="ss">Member</span><span class="p">:</span><span class="ss">:DEFAULT_TYPE_TRANSFORMS</span><span class="o">.</span><span class="n">dup</span>
</span><span class='line'><span class="n">type_transforms</span><span class="o">.</span><span class="n">unshift</span><span class="p">(</span><span class="no">ActiveRecordTypeToClassTransform</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Also, for this to work, I added the <code>def self.model_name(name)</code> helper to the base class.</p>

<h3>Renaming a Custom Field Method</h3>

<p>We have a helper for adding URL fields called <code>define_url_field</code>. I decided to rename this to <code>url_fields</code>, since these days it creates <em>two</em> fields.</p>

<p>The arguments are the same, so it was a simple substitution:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">UrlFieldTransform</span> <span class="o">&lt;</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Upgrader</span><span class="o">::</span><span class="no">Transform</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="n">input_text</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># Capture the leading whitespace and the rest of the line,</span>
</span><span class='line'>    <span class="c1"># then insert the new name where the old name used to be</span>
</span><span class='line'>    <span class="n">input_text</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/^( +)define_url_field( |\()/</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\\</span><span class="s2">1url_fields</span><span class="se">\\</span><span class="s2">2&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>This transform didn&rsquo;t interact with any other transforms, so I added it to <code>clean_up_transforms</code>, so it would run last:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Make a copy of the built-in arry</span>
</span><span class='line'><span class="n">clean_up_transforms</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Upgrader</span><span class="o">::</span><span class="ss">Member</span><span class="p">:</span><span class="ss">:DEFAULT_CLEAN_UP_TRANSFORMS</span><span class="o">.</span><span class="n">dup</span>
</span><span class='line'><span class="c1"># Add my custom transform to the end of the array</span>
</span><span class='line'><span class="n">clean_up_transforms</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="no">UrlFieldTransform</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Moving DSL methods to keywords</h3>

<p>We have a few DSL methods that, at the time, were easier to implement as keyword arguments. (Since then, the API has changed a bit. You can implement DSL methods on your fields by extending <code>GraphQL::Schema::Field</code> and setting that class as <code>field_class</code> on your base Object, Interface and Mutation classes.)</p>

<p>I wanted to transform:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:secretStuff</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">String</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">visibility</span> <span class="ss">:secret</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>To:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:secretStuff</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">String</span><span class="p">,</span> <span class="ss">visibility</span><span class="p">:</span> <span class="ss">:secret</span>
</span></code></pre></td></tr></table></div></figure>


<p>(Later, a built-in upgrader would change <code>secretStuff</code> to <code>secret_stuff</code> and <code>types.String</code> to <code>String, null: true</code>.)</p>

<p>To accomplish this, I reused a built-in transform, <code>ConfigurationToKwargTransform</code>, adding it to <code>field_transforms</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Make a copy of the built-in list of defaults</span>
</span><span class='line'><span class="n">field_transforms</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Upgrader</span><span class="o">::</span><span class="ss">Member</span><span class="p">:</span><span class="ss">:DEFAULT_FIELD_TRANSFORMS</span><span class="o">.</span><span class="n">dup</span>
</span><span class='line'><span class="c1"># Put my custom transform at the beginning of the list</span>
</span><span class='line'><span class="n">field_transforms</span><span class="o">.</span><span class="n">unshift</span><span class="p">(</span><span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Upgrader</span><span class="o">::</span><span class="no">ConfigurationToKwargTransform</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="ss">kwarg</span><span class="p">:</span> <span class="s2">&quot;visibility&quot;</span><span class="p">))</span>
</span></code></pre></td></tr></table></div></figure>


<p>In fact, there were several configuration methods moved this way.</p>

<h3>Custom Skip</h3>

<p>As I was working through the code, some files were tougher than others. So, I decided to skip them. I decided that a magic comment:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># @skip-auto-upgrade</span>
</span></code></pre></td></tr></table></div></figure>


<p>would cause a file to be skipped. To implement this, I made a custom skip class:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">CustomSkip</span> <span class="o">&lt;</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Upgrader</span><span class="o">::</span><span class="no">SkipOnNullKeyword</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">skip?</span><span class="p">(</span><span class="n">input_text</span><span class="p">)</span>
</span><span class='line'>    <span class="k">super</span><span class="p">(</span><span class="n">input_text</span><span class="p">)</span> <span class="o">||</span> <span class="n">input_text</span><span class="o">.</span><span class="n">include?</span><span class="p">(</span><span class="s2">&quot;@skip-auto-upgrade&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>And passed it as <code>skip:</code> to the upgrader. Then, later, I removed the comment and tried again. (Fortunately, my procrastination paid off because the upgrader was improved in the meantime!)</p>

<h2>Fixes by Hand</h2>

<p>As I worked, I improved the upgrader to cover as many cases as I could, but there are still a few cases that I had to upgrade by hand. I&rsquo;ll list them here. If you&rsquo;re really dragged down by them, consider opening an issue on GraphQL-Ruby to talk about fixing them. I&rsquo;m sure they <em>can</em> be fixed, I just didn&rsquo;t get to it!</p>

<p>If you want to fix one of these issues, try to replicate the issue by adding to an example <code>spec/fixtures/upgrader</code> and then getting a failing test. Then, you could update the upgrader code to fix that broken test.</p>

<h3>Accessing Arguments By Method</h3>

<p>Arguments could be accessed by method to avoid typos. However, now, since arguments are a Ruby keyword hash, they don&rsquo;t have methods corresponding to their keys.</p>

<p>Unfortunately, the upgrader doesn&rsquo;t do anything about this, it just leaves them there and you get a <code>NoMethodError</code> on <code>Hash</code>.</p>

<p>This could almost certainly be fixed by improving this find-and-replace in <code>ResolveProcToMethodTransform</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Update Argument access to be underscore and symbols</span>
</span><span class='line'><span class="c1"># Update `args[...]` and `args.key?`</span>
</span><span class='line'><span class="n">method_body</span> <span class="o">=</span> <span class="n">method_body</span><span class="o">.</span><span class="n">gsub</span><span class="p">(</span><span class="sr">/</span><span class="si">#{</span><span class="n">args_arg_name</span><span class="si">}</span><span class="sr">(?&lt;method_begin&gt;\.key\?\(?|\[)[&quot;&#39;:](?&lt;arg_name&gt;[a-zA-Z0-9_]+)[&quot;&#39;]?(?&lt;method_end&gt;\]|\))?/</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'> <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>It only updates a few methods on <code>args</code>, but I bet a similar find-and-replace could replace <em>other</em> method calls, too.</p>

<h3>Argument Usages Outside of Type Definitions</h3>

<p>Sometimes, we take GraphQL arguments and pass them to helper methods:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">resolve</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="ss">Some</span><span class="p">:</span><span class="ss">:Helper</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>However when this was transformed to:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">do_stuff</span><span class="p">(</span><span class="o">**</span><span class="n">arguments</span><span class="p">)</span>
</span><span class='line'>  <span class="ss">Some</span><span class="p">:</span><span class="ss">:Helper</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="vi">@object</span><span class="p">,</span> <span class="n">arguments</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>It would break, because the new <code>arguments</code> value is a Ruby hash with underscored, symbol keys. So, if <code>Some::Helper</code> was using camelized strings to get values, it would stop working.</p>

<p>The upgrader can&rsquo;t really do anything there, since it&rsquo;s not analyzing the codebase. In my case, these were readily apparent because of failing tests, so I went and fixed them.</p>

<h3>context.add_error</h3>

<p>We have some fields that add to the <code>"errors"</code> key <em>and</em> return values, they used <code>ctx.add_error</code> to do so:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">resolve</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">begin</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">.</span><span class="n">count_things</span>
</span><span class='line'>  <span class="k">rescue</span> <span class="no">BackendIsBrokenError</span>
</span><span class='line'>    <span class="n">ctx</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:ExecutionError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;Not working!&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="mi">0</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>When upgraded, it doesn&rsquo;t work quite right:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">count_things</span>
</span><span class='line'>  <span class="k">begin</span>
</span><span class='line'>    <span class="vi">@object</span><span class="o">.</span><span class="n">count_things</span>
</span><span class='line'>  <span class="k">rescue</span> <span class="no">BackendIsBrokenError</span>
</span><span class='line'>    <span class="vi">@context</span><span class="o">.</span><span class="n">add_error</span><span class="p">(</span><span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:ExecutionError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;Not working!&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="mi">0</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>(If you don&rsquo;t have to return a value, use <code>raise</code> instead, then you can stop reading this part!)</p>

<p>The problem is that <code>@context</code> is not a <em>field-specific</em> context anymore. Instead, it&rsquo;s the query-level context. (This is downside of the new API: we don&rsquo;t have a great way to pass in the field context anymore.)</p>

<p>To address this kind of issues, <code>field</code> accepts a keyword called <code>extras:</code>, which contains a array of symbols. In the case above, we could use <code>:execution_errors</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:count_things</span><span class="p">,</span> <span class="nb">Integer</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">false</span><span class="p">,</span> <span class="ss">extras</span><span class="p">:</span> <span class="o">[</span><span class="ss">:execution_errors</span><span class="o">]</span>
</span><span class='line'><span class="k">def</span> <span class="nf">count_things</span><span class="p">(</span><span class="n">execution_errors</span><span class="p">:)</span>
</span><span class='line'>  <span class="vi">@object</span><span class="o">.</span><span class="n">count_things</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">BackendIsBrokenError</span>
</span><span class='line'>  <span class="n">execution_errors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;Not working!&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="mi">0</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, <code>execution_errors</code> was injected into the field as a keyword. It <em>is</em> field-level, so adding errors there works as before.</p>

<p>Other extras are <code>:irep_node</code>, <code>:parent</code>, <code>:ast_node</code>, and <code>:arguments</code>. It&rsquo;s a bit of a hack, but we need <em>something</em> for this!</p>

<h3>Accessing Connection Arguments</h3>

<p>By default, connection arguments (like <code>first</code>, <code>after</code>, <code>last</code>, <code>before</code>) are <em>not</em> passed to the Ruby methods for implementing fields. This is because they&rsquo;re generally used by the automagical (😖) connection wrappers, not the resolve functions.</p>

<p>But, sometimes you just <em>need</em> those old arguments!</p>

<p>If you use <code>extras: [:arguments]</code>, the legacy-style arguments will be injected as a keyword:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># `arguments` is the legacy-style Query::Arguments instance</span>
</span><span class='line'><span class="c1"># `field_arguments` is a Ruby hash with symbol, underscored keys.</span>
</span><span class='line'><span class="k">def</span> <span class="nf">things</span><span class="p">(</span><span class="ss">arguments</span><span class="p">:,</span> <span class="o">**</span><span class="n">field_arguments</span><span class="p">)</span>
</span><span class='line'>  <span class="n">arguments</span><span class="o">[</span><span class="ss">:first</span><span class="o">]</span> <span class="c1"># =&gt; 5</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>Fancy String Descriptions</h3>

<p>The upgrader does fine when the description is a <code>"..."</code> or <code>'...'</code> string. But in other cases, it was a bit wacky.</p>

<p>Strings built up with <code>+</code> or <code>\</code> always broke. I had to go back by hand and join them into one string.</p>

<p>Heredoc strings often <em>worked</em>, but only by chance. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:stuff</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">Int</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">description</span> <span class="o">&lt;&lt;~</span><span class="no">MD</span>
</span><span class='line'>    <span class="no">Here</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">the</span> <span class="n">stuff</span>
</span><span class='line'>  <span class="no">MD</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Would be transformed to:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:stuff</span><span class="p">,</span> <span class="nb">Integer</span><span class="p">,</span> <span class="ss">description</span><span class="p">:</span> <span class="o">&lt;&lt;~</span><span class="no">MD</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">true</span>
</span><span class='line'>    <span class="no">Here</span><span class="err">&#39;</span><span class="n">s</span> <span class="n">the</span> <span class="n">stuff</span>
</span><span class='line'>  <span class="no">MD</span>
</span></code></pre></td></tr></table></div></figure>


<p>This is valid Ruby, but a bit tricky. This could definitely be improved: since I started my project, GraphQL 1.8 was extended to support <code>description</code> as a <em>method</em> as well as a keyword. So, the upgrader could be improved to leave descriptions in place if they&rsquo;re fancy strings.</p>

<h3>Removed Comments From the Start of Resolve Proc</h3>

<p>I hacked around with the <code>parser</code> gem to transform <code>resolve</code> procs into instance methods, but there&rsquo;s a bug. A proc like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">resolve</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1"># Do stuff</span>
</span><span class='line'>  <span class="n">obj</span><span class="o">.</span><span class="n">do_stuff</span> <span class="p">{</span> <span class="n">stuff</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Will be transformed to:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">stuff</span>
</span><span class='line'>  <span class="vi">@object</span><span class="o">.</span><span class="n">do_stuff</span> <span class="p">{</span> <span class="n">stuff</span> <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Did you see how the comment was removed? I think I&rsquo;ve somehow wrongly detected the start of the proc body, so that the comment was left out.</p>

<p>In my case, I re-added those comments by hand. But it could probably be fixed in <code>GraphQL::Upgrader::ResolveProcToMethodTransform</code>.</p>

<h3>Hash Reformating?</h3>

<p>I&rsquo;m not sure why, but sometimes a hash of arguments like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">obj</span><span class="o">.</span><span class="n">do_stuff</span><span class="p">(</span>
</span><span class='line'>  <span class="ss">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">d</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>would be reorganized to</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">obj</span><span class="o">.</span><span class="n">do_stuff</span><span class="p">(</span>
</span><span class='line'>  <span class="ss">a</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
</span><span class='line'>  <span class="ss">b</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="ss">c</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="ss">d</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
</span><span class='line'><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>I have no idea why, and I didn&rsquo;t look into it, I just fixed it by hand.</p>

<h3>Issues with Connection DSL</h3>

<p>We have a DSL for making connections, like:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">Connections</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="ss">Objects</span><span class="p">:</span><span class="ss">:Issue</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Sometimes, when this connection was inside a proc, it would be wrongly transformed to:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:issues</span><span class="p">,</span> <span class="no">Connections</span><span class="o">.</span><span class="n">define</span><span class="p">(</span><span class="ss">Objects</span><span class="p">:</span><span class="ss">:Issue</span><span class="p">)</span> <span class="p">},</span> <span class="p">,</span><span class="ss">null</span><span class="p">:</span> <span class="kp">true</span>
</span></code></pre></td></tr></table></div></figure>


<p>This was invalid Ruby, so the app wouldn&rsquo;t boot, and I would fix it by hand.</p>

<h2>Porting Relay Types</h2>

<p>Generating connection and edge types with the <code>.connection_type</code>/<code>.define_connection</code> and <code>.edge_type</code>/<code>.define_edge</code> methods will work fine with the new API, but if you want to migrate them to classes, you can do it.</p>

<p>It&rsquo;s on my radar because I want to remove our DSL extensions, and that requires updating our custom connection edge types.</p>

<p>Long story, short, it Just Work™ed with the class-based API. The approach was:</p>

<ul>
<li>Add a base class inheriting from our <code>BaseObject</code></li>
<li>Use the new base class&rsquo;s <code>def self.inherited</code> hook to add connection- and edge-related behaviors</li>
<li>Run the upgrader on edge and connection types, then go back and do some manual find-and-replaces to make them work right</li>
</ul>


<p>So, I will share my base classes in case that helps. Sometime it will be nice to upstream this to GraphQL-Ruby, but I&rsquo;m not sure how to do it now.</p>

<p>Base connection class:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Platform</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Connections</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">Base</span> <span class="o">&lt;</span> <span class="ss">Platform</span><span class="p">:</span><span class="ss">:Objects</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>      <span class="c1"># For some reason, these are needed, they call through to the underlying connection wrapper.</span>
</span><span class='line'>      <span class="kp">extend</span> <span class="no">Forwardable</span>
</span><span class='line'>      <span class="n">def_delegators</span> <span class="ss">:@object</span><span class="p">,</span> <span class="ss">:cursor_from_node</span><span class="p">,</span> <span class="ss">:parent</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1"># When this class is extended, add the default connection behaviors.</span>
</span><span class='line'>      <span class="c1"># This adds a new `graphql_name` and description, and searches</span>
</span><span class='line'>      <span class="c1"># for a corresponding edge type.</span>
</span><span class='line'>      <span class="c1"># See `.edge_type` for how the fields are added.</span>
</span><span class='line'>      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">inherited</span><span class="p">(</span><span class="n">child_class</span><span class="p">)</span>
</span><span class='line'>        <span class="c1"># We have a convention that connection classes _don&#39;t_ end in `Connection`, which</span>
</span><span class='line'>        <span class="c1"># is a bit confusing and results in naming conflicts.</span>
</span><span class='line'>        <span class="c1"># To avoid a GraphQL conflict, override `graphql_name` to end in `Connection`.</span>
</span><span class='line'>        <span class="n">type_name</span> <span class="o">=</span> <span class="n">child_class</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">last</span>
</span><span class='line'>        <span class="n">child_class</span><span class="o">.</span><span class="n">graphql_name</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">type_name</span><span class="si">}</span><span class="s2">Connection&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1"># Use `require_dependency` so that the types will be loaded, if they exist.</span>
</span><span class='line'>        <span class="c1"># Otherwise, `const_get` may reach a top-level constant (eg, `::Issue` model instead of `Platform::Objects::Issue`).</span>
</span><span class='line'>        <span class="c1"># That behavior is removed in Ruby 2.5, then we can remove these require_dependency calls too.</span>
</span><span class='line'>        <span class="k">begin</span>
</span><span class='line'>          <span class="c1"># Look for a custom edge whose name matches this connection&#39;s name</span>
</span><span class='line'>          <span class="n">require_dependency</span> <span class="s2">&quot;lib/platform/edges/</span><span class="si">#{</span><span class="n">type_name</span><span class="o">.</span><span class="n">underscore</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>          <span class="n">wrapped_edge_class</span> <span class="o">=</span> <span class="ss">Platform</span><span class="p">:</span><span class="ss">:Edges</span><span class="o">.</span><span class="n">const_get</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
</span><span class='line'>          <span class="n">wrapped_node_class</span> <span class="o">=</span> <span class="n">wrapped_edge_class</span><span class="o">.</span><span class="n">fields</span><span class="o">[</span><span class="s2">&quot;node&quot;</span><span class="o">].</span><span class="n">type</span>
</span><span class='line'>        <span class="k">rescue</span> <span class="no">LoadError</span> <span class="o">=&gt;</span> <span class="n">err</span>
</span><span class='line'>          <span class="c1"># If the custom edge file doesn&#39;t exist, look for an object</span>
</span><span class='line'>          <span class="k">begin</span>
</span><span class='line'>            <span class="n">require_dependency</span> <span class="s2">&quot;lib/platform/objects/</span><span class="si">#{</span><span class="n">type_name</span><span class="o">.</span><span class="n">underscore</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>            <span class="n">wrapped_node_class</span> <span class="o">=</span> <span class="ss">Platform</span><span class="p">:</span><span class="ss">:Objects</span><span class="o">.</span><span class="n">const_get</span><span class="p">(</span><span class="n">type_name</span><span class="p">)</span>
</span><span class='line'>            <span class="n">wrapped_edge_class</span> <span class="o">=</span> <span class="n">wrapped_node_class</span><span class="o">.</span><span class="n">edge_type</span>
</span><span class='line'>          <span class="k">rescue</span> <span class="no">LoadError</span> <span class="o">=&gt;</span> <span class="n">err</span>
</span><span class='line'>            <span class="c1"># Assume that `edge_type` will be called later</span>
</span><span class='line'>          <span class="k">end</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1"># If a default could be found using constant lookups, generate the fields for it.</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">wrapped_edge_class</span>
</span><span class='line'>          <span class="k">if</span> <span class="n">wrapped_edge_class</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:ObjectType</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">wrapped_edge_class</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">wrapped_edge_class</span> <span class="o">&lt;</span> <span class="ss">Platform</span><span class="p">:</span><span class="ss">:Edges</span><span class="o">::</span><span class="no">Base</span><span class="p">)</span>
</span><span class='line'>            <span class="n">child_class</span><span class="o">.</span><span class="n">edge_type</span><span class="p">(</span><span class="n">wrapped_edge_class</span><span class="p">,</span> <span class="n">node_type</span><span class="p">:</span> <span class="n">wrapped_node_class</span><span class="p">)</span>
</span><span class='line'>          <span class="k">else</span>
</span><span class='line'>            <span class="k">raise</span> <span class="no">TypeError</span><span class="p">,</span> <span class="s2">&quot;Missed edge type lookup, didn&#39;t find a type definition: </span><span class="si">#{</span><span class="n">type_name</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2"> =&gt; </span><span class="si">#{</span><span class="n">wrapped_edge_class</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>          <span class="k">end</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1"># Configure this connection to return `edges` and `nodes` based on `edge_type_class`.</span>
</span><span class='line'>      <span class="c1">#</span>
</span><span class='line'>      <span class="c1"># This method will use the inputs to create:</span>
</span><span class='line'>      <span class="c1"># - `edges` field</span>
</span><span class='line'>      <span class="c1"># - `nodes` field</span>
</span><span class='line'>      <span class="c1"># - description</span>
</span><span class='line'>      <span class="c1">#</span>
</span><span class='line'>      <span class="c1"># It&#39;s called when you subclass this base connection, trying to use the</span>
</span><span class='line'>      <span class="c1"># class name to set defaults. You can call it again in the class definition</span>
</span><span class='line'>      <span class="c1"># to override the default (or provide a value, if the default lookup failed).</span>
</span><span class='line'>      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">edge_type</span><span class="p">(</span><span class="n">edge_type_class</span><span class="p">,</span> <span class="n">edge_class</span><span class="p">:</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Relay</span><span class="o">::</span><span class="no">Edge</span><span class="p">,</span> <span class="n">node_type</span><span class="p">:</span> <span class="kp">nil</span><span class="p">)</span>
</span><span class='line'>        <span class="c1"># Add the edges field, can be overridden later</span>
</span><span class='line'>        <span class="n">field</span> <span class="ss">:edges</span><span class="p">,</span> <span class="o">[</span><span class="n">edge_type_class</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">true</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>          <span class="ss">null</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span>
</span><span class='line'>          <span class="ss">description</span><span class="p">:</span> <span class="s2">&quot;A list of edges.&quot;</span><span class="p">,</span>
</span><span class='line'>          <span class="nb">method</span><span class="p">:</span> <span class="ss">:edge_nodes</span><span class="p">,</span>
</span><span class='line'>          <span class="n">edge_class</span><span class="p">:</span> <span class="n">edge_class</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1"># Try to figure out what the node type is, if it wasn&#39;t provided:</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">node_type</span><span class="o">.</span><span class="n">nil?</span>
</span><span class='line'>          <span class="k">if</span> <span class="n">edge_type_class</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">Class</span><span class="p">)</span>
</span><span class='line'>            <span class="n">node_type</span> <span class="o">=</span> <span class="n">edge_type_class</span><span class="o">.</span><span class="n">fields</span><span class="o">[</span><span class="s2">&quot;node&quot;</span><span class="o">].</span><span class="n">type</span>
</span><span class='line'>          <span class="k">elsif</span> <span class="n">edge_type_class</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:ObjectType</span><span class="p">)</span>
</span><span class='line'>            <span class="c1"># This was created with `.edge_type`</span>
</span><span class='line'>            <span class="n">node_type</span> <span class="o">=</span> <span class="ss">Platform</span><span class="p">:</span><span class="ss">:Objects</span><span class="o">.</span><span class="n">const_get</span><span class="p">(</span><span class="n">edge_type_class</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s2">&quot;Edge&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
</span><span class='line'>          <span class="k">else</span>
</span><span class='line'>            <span class="k">raise</span> <span class="no">ArgumentError</span><span class="p">,</span> <span class="s2">&quot;Can&#39;t get node type from edge type: </span><span class="si">#{</span><span class="n">edge_type_class</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>          <span class="k">end</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1"># If it&#39;s a non-null type, remove the wrapper</span>
</span><span class='line'>        <span class="k">if</span> <span class="n">node_type</span><span class="o">.</span><span class="n">respond_to?</span><span class="p">(</span><span class="ss">:of_type</span><span class="p">)</span>
</span><span class='line'>          <span class="n">node_type</span> <span class="o">=</span> <span class="n">node_type</span><span class="o">.</span><span class="n">of_type</span>
</span><span class='line'>        <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1"># Make the `nodes` shortcut field, which can be overridden later</span>
</span><span class='line'>        <span class="n">field</span> <span class="ss">:nodes</span><span class="p">,</span> <span class="o">[</span><span class="n">node_type</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">true</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>          <span class="ss">null</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span>
</span><span class='line'>          <span class="ss">description</span><span class="p">:</span> <span class="s2">&quot;A list of nodes.&quot;</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1"># Make a nice description</span>
</span><span class='line'>        <span class="n">description</span><span class="p">(</span><span class="s2">&quot;The connection type for </span><span class="si">#{</span><span class="n">node_type</span><span class="o">.</span><span class="n">graphql_name</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="n">field</span> <span class="ss">:page_info</span><span class="p">,</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Relay</span><span class="o">::</span><span class="no">PageInfo</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">false</span><span class="p">,</span> <span class="ss">description</span><span class="p">:</span> <span class="s2">&quot;Information to aid in pagination.&quot;</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1"># By default this calls through to the ConnectionWrapper&#39;s edge nodes method,</span>
</span><span class='line'>      <span class="c1"># but sometimes you need to override it to support the `nodes` field</span>
</span><span class='line'>      <span class="k">def</span> <span class="nf">nodes</span>
</span><span class='line'>        <span class="vi">@object</span><span class="o">.</span><span class="n">edge_nodes</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Base edge class:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">Platform</span>
</span><span class='line'>  <span class="k">module</span> <span class="nn">Edges</span>
</span><span class='line'>    <span class="k">class</span> <span class="nc">Base</span> <span class="o">&lt;</span> <span class="ss">Platform</span><span class="p">:</span><span class="ss">:Objects</span><span class="o">::</span><span class="no">Base</span>
</span><span class='line'>      <span class="c1"># A description which is inherited and may be overridden</span>
</span><span class='line'>      <span class="n">description</span> <span class="s2">&quot;An edge in a connection.&quot;</span>
</span><span class='line'>
</span><span class='line'>      <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">inherited</span><span class="p">(</span><span class="n">child_class</span><span class="p">)</span>
</span><span class='line'>        <span class="c1"># We have a convention that edge classes _don&#39;t_ end in `Edge`,</span>
</span><span class='line'>        <span class="c1"># which is a little bit confusing, and would result in a naming conflict by default.</span>
</span><span class='line'>        <span class="c1"># Avoid the naming conflict by overriding `graphql_name` to include `Edge`</span>
</span><span class='line'>        <span class="n">wrapped_type_name</span> <span class="o">=</span> <span class="n">child_class</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;::&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">last</span>
</span><span class='line'>        <span class="n">child_class</span><span class="o">.</span><span class="n">graphql_name</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">#{</span><span class="n">wrapped_type_name</span><span class="si">}</span><span class="s2">Edge&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="c1"># Add a default `node` field, assuming the object type name matches.</span>
</span><span class='line'>        <span class="c1"># If it doesn&#39;t match, you can override this in subclasses</span>
</span><span class='line'>        <span class="n">child_class</span><span class="o">.</span><span class="n">field</span> <span class="ss">:node</span><span class="p">,</span> <span class="s2">&quot;Platform::Objects::</span><span class="si">#{</span><span class="n">wrapped_type_name</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">true</span><span class="p">,</span> <span class="ss">description</span><span class="p">:</span> <span class="s2">&quot;The item at the end of the edge.&quot;</span>
</span><span class='line'>      <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>      <span class="c1"># A cursor field which is inherited</span>
</span><span class='line'>      <span class="n">field</span> <span class="ss">:cursor</span><span class="p">,</span> <span class="nb">String</span><span class="p">,</span>
</span><span class='line'>        <span class="ss">null</span><span class="p">:</span> <span class="kp">false</span><span class="p">,</span>
</span><span class='line'>        <span class="ss">description</span><span class="p">:</span> <span class="s2">&quot;A cursor for use in pagination.&quot;</span>
</span><span class='line'>    <span class="k">end</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Migrating DSL Extensions</h2>

<p>We have several extensions to the GraphQL-Ruby <code>.define</code> DSL, for example, <code>visibility</code> controls who can see certain types and fields and <code>scopes</code> maps OAuth scopes to GraphQL types.</p>

<p>The difficulty in porting extensions comes from the implementation details of the new API. For now, definition classes are factories for legacy-style type instances. Each class has a <code>.to_graphql</code> method which is called <em>once</em> to return a legacy-style definition. To maintain compatibility, you have to either:</p>

<ul>
<li>Modify the derived legacy-style definition to reflect configurations on the class-based definition; OR</li>
<li>Update your runtime code to <em>stop</em> checking for configurations on the legacy-style definition and <em>start</em> checking for configurations on the class-based definition.</li>
</ul>


<p>Eventually, legacy-style definitions will be phased out of GraphQL-Ruby, but for now, they both exist in this way in order to maintain backwards compatibility and gradual adoptability.</p>

<p>In the mean time, you can go between class-based and legacy-style definitions using <code>.graphql_defintion</code> and <code>.metadata[:type_class]</code>, for example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Project</span> <span class="o">&lt;</span> <span class="no">BaseObject</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">legacy_type</span> <span class="o">=</span> <span class="no">Project</span><span class="o">.</span><span class="n">graphql_definition</span>
</span><span class='line'><span class="c1"># #&lt;GraphQL::ObjectType&gt; instance</span>
</span><span class='line'><span class="n">legacy_type</span><span class="o">.</span><span class="n">metadata</span><span class="o">[</span><span class="ss">:type_class</span><span class="o">]</span>
</span><span class='line'><span class="c1"># `Project` class</span>
</span></code></pre></td></tr></table></div></figure>


<h3>The Easy Way: <code>.redefine</code></h3>

<p>The easiest way to retain compatibility is to:</p>

<ul>
<li>Add a class method to your base classes which accept some configuration and put it in instance variables</li>
<li>Override <code>.to_graphql</code> to call super, and then pass the configuration to <code>defn.redefine(...)</code>, then return the redefined type.</li>
</ul>


<p>After my work on our code, I extracted this into a <a href="http://graphql-ruby.org/type_definitions/extensions.html#customization-compatibility">backport of <code>accepts_definition</code></a></p>

<p>You can take that approach for a try, for example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">BaseObject</span> <span class="o">&lt;</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Schema</span><span class="o">::</span><span class="no">Object</span>
</span><span class='line'>  <span class="c1"># Add a configuration method</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">visibility</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
</span><span class='line'>    <span class="vi">@visibility</span> <span class="o">=</span> <span class="n">level</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'>
</span><span class='line'>  <span class="c1"># Re-apply the configuration</span>
</span><span class='line'>  <span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">to_graphql</span>
</span><span class='line'>    <span class="n">type_defn</span> <span class="o">=</span> <span class="k">super</span>
</span><span class='line'>    <span class="c1"># Call through to the old extension:</span>
</span><span class='line'>    <span class="n">type_defn</span> <span class="o">=</span> <span class="n">type_defn</span><span class="o">.</span><span class="n">redefine</span><span class="p">(</span><span class="ss">visibilty</span><span class="p">:</span> <span class="vi">@visibility</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># Return the redefined type:</span>
</span><span class='line'>    <span class="n">type_defn</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Then, use it in type definitions:</span>
</span><span class='line'><span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">BaseObject</span>
</span><span class='line'>  <span class="n">visibility</span><span class="p">(</span><span class="ss">:secret</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<h3>The Hard Way: <code>.metadata[:type_class]</code></h3>

<p>An approach I haven&rsquo;t tried yet, but I will soon, is to move the &ldquo;source of truth&rdquo; to the the class-based definition. The challenge here is that class-based definitions are not really used during validation and execution, so how can you reach configuration values on those classes?</p>

<p>The answer is that if a legacy-style type was derived from a class, that class is stored as <code>metadata[:type_class]</code>. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Project</span> <span class="o">&lt;</span> <span class="no">BaseObject</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="n">legacy_defn</span> <span class="o">=</span> <span class="no">Project</span><span class="o">.</span><span class="n">graphql_definition</span> <span class="c1"># Instance of GraphQL::ObjectType, just like `.define`</span>
</span><span class='line'><span class="n">legacy_defn</span><span class="o">.</span><span class="n">metadata</span><span class="o">[</span><span class="ss">:type_class</span><span class="o">]</span> <span class="c1"># `Project` class from above</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, you could update runtime code to read configurations from <code>type_defn.metadata[:type_class]</code>.</p>

<p>Importantly, <code>metadata[:type_class]</code> will be <code>nil</code> if the type <em>wasn&rsquo;t</em> derived from a class, so this approach is tough to use if some definitions are still using the <code>.define</code> API.</p>

<p>I haven&rsquo;t implemented this yet, but I will be doing it in the next few weeks so we can simplify our extensions and improve boot time.</p>

<h2>The End</h2>

<p>I&rsquo;m still wrapping up some loose ends in the codebase, but I thought I&rsquo;d share these notes in case they help you in your upgrade. If you run into trouble on anything mentioned here, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> on GraphQL-Ruby! I really want to support a smooth transition to this new API.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why a New Schema Definition API?]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/03/25/why-a-new-schema-definition-api/"/>
    <updated>2018-03-25T13:59:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/03/25/why-a-new-schema-definition-api</id>
    <content type="html"><![CDATA[<p>GraphQL-Ruby <code>1.8.0</code> will have a new class-based API for defining your schema. Let&rsquo;s investigate the design choices in the new API.</p>

<!-- more -->


<p>The new API is backwards-compatible and can coexist with type definitions in the old format. See <a href="https://github.com/rmosolgo/graphql-ruby/blob/1.8-dev/guides/schema/class_based_api.md#compatibility--migration-overview">the docs</a> for details. <code>1.8.0.pre</code> versions are available on RubyGems now and are very stable &ndash; that&rsquo;s what we&rsquo;re running at GitHub!</p>

<h2>Problems Worth Fixing</h2>

<p>Since starting at GitHub last May, I&rsquo;ve entered into the experience of a huge-scale GraphQL system. Huge scale in lots of ways: huge schema, huge volume, and huge developer base. One of the problems that stood out to me (and to lots of us) was that GraphQL-Ruby simply <em>didn&rsquo;t help</em> us be productive. Elements of schema definition hindered us rather than helped us.</p>

<p>So, our team set out on remaking the GraphQL-Ruby schema definition API. We wanted to address a few specific issues:</p>

<ul>
<li><strong>Familiarity</strong>. GraphQL-Ruby&rsquo;s schema definition API reflected GraphQL and JavaScript more than it reflected Ruby. (The JavaScript influence comes from <code>graphql-js</code>, the reference implementation.) Ruby developers couldn&rsquo;t bring their usual practices into schema development; instead, they had to learn a bunch of new APIs and figure out how to work them together.</li>
<li><strong>Rails Compatibility</strong>, especially constant loading. A good API would work seamlessly with Rails development configurations, but the current API has some gotchas regarding circular dependencies and reloading.</li>
<li><strong>Hackability</strong>. Library code is fine <em>until it isn&rsquo;t</em>, and one of the best (and worst) things about Ruby is that all code is open to extension (or monkey-patching 🙈). At best, this means that library users can customize the library code in straightforward ways to better suit their use cases. However, GraphQL-Ruby didn&rsquo;t support this well: to support special use cases, customizations had to be hacked in in odd ways that were hard to maintain and prone to breaking during gem updates.</li>
</ul>


<p>Besides all that, we needed a <em>safe</em> transition, so it had to support a gradual adoption.</p>

<p>After trying a few different possibilities, the team decided to take a class-based approach to defining GraphQL schemas. I&rsquo;m really thankful for their support in the design process, and I&rsquo;m indebted to the folks at Shopify, who used a class-based schema definition system from the start (as a layer on top of GraphQL-Ruby) and <a href="https://www.youtube.com/watch?v=Wlu_PWCjc6Y">presented their work</a> early on.</p>

<h2>The new API, from 10,000 feet</h2>

<p>In short, GraphQL types used to be singleton instances, built with a <a href="https://twitter.com/krainboltgreene/status/971797438070599680">block-based API</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">Types</span><span class="p">:</span><span class="ss">:Post</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:ObjectType</span><span class="o">.</span><span class="n">define</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, GraphQL types are classes, with a DSL implemented as class methods:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Types</span><span class="o">::</span><span class="no">Post</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Field resolution was previously defined using Proc literals:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:comments</span><span class="p">,</span> <span class="n">types</span><span class="o">[</span><span class="ss">Types</span><span class="p">:</span><span class="ss">:Comments</span><span class="o">]</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">argument</span> <span class="ss">:orderBy</span><span class="p">,</span> <span class="ss">Types</span><span class="p">:</span><span class="ss">:CommentOrder</span>
</span><span class='line'>  <span class="n">resolve</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="n">obj</span><span class="o">.</span><span class="n">comments</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">args</span><span class="o">[</span><span class="ss">:orderBy</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, field resolution is defined with an instance method:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:comments</span><span class="p">,</span> <span class="o">[</span><span class="ss">Types</span><span class="p">:</span><span class="ss">:Comments</span><span class="o">]</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">true</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">argument</span> <span class="ss">:order_by</span><span class="p">,</span> <span class="ss">Types</span><span class="p">:</span><span class="ss">:CommentOrder</span><span class="p">,</span> <span class="ss">required</span><span class="p">:</span> <span class="kp">false</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">comments</span><span class="p">(</span><span class="n">order_by</span><span class="p">:</span> <span class="kp">nil</span><span class="p">)</span>
</span><span class='line'>  <span class="n">object</span><span class="o">.</span><span class="n">comments</span><span class="o">.</span><span class="n">order</span><span class="p">(</span><span class="n">order_by</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>How does this address the issues listed above?</p>

<h2>More Familiarity</h2>

<p>First, using classes reduces the &ldquo;WTF&rdquo; factor of GraphQL definition code. A seasoned Ruby developer might (rightly) smell foul play and reject GraphQL-Ruby on principle. (I was not seasoned enough to detect this when I designed the API!)</p>

<p>Proc literals are rare in Ruby, but common in GraphQL-Ruby&rsquo;s <code>.define { ... }</code> API. Their lexical scoping rules are different than method scoping rules, making it hard to remember what <em>was</em> and <em>wasn&rsquo;t</em> in scope during field resolution (for example, what was <code>self</code>?). To make matters worse, <em>some</em> of the blocks in the <code>.define</code> API were <code>instance_eval</code>&rsquo;d, so their <code>self</code> would be overridden. Practically, this meant that typos in development resulted in strange <code>NoMethodError</code>s.</p>

<p>Proc literals also have performance downsides: they&rsquo;re not optimized by CRuby, so they&rsquo;re <a href="https://gist.github.com/rmosolgo/6c6a7d787e0f1666f4c6d858c8402a01#gistcomment-1843329">slower than method calls</a>. Since they capture a lexical scope, they may also have <a href="https://github.com/github/graphql-client/pull/139">unexpected impacts on memory footprint</a> (any local variable may be retained, since it might be accessed by the proc). The solutions here are simple: just use methods, the way Ruby wants you to! 😬</p>

<p>In the new class-based API, there are no proc literals (although they&rsquo;re supported for compatibility&rsquo;s sake). There are some <code>instance_eval</code>&rsquo;d blocks (<code>field(...) { }</code>, for example), but field resolution is <em>just an instance method</em> and the type definition is a normal class, so module scoping works normally. (Contrast that with the constant assignment in <code>Types::Post = GraphQL::ObjectType.define { ... }</code>, where no module scope is used). Several hooks that were previously specified as procs are now class methods, such as <code>resolve_type</code> and <code>coerce_input</code> (for scalars).</p>

<p>Overriding <code>!</code> is another particular no-no I&rsquo;m correcting. At the time, I thought, &ldquo;what a cool way to bring a GraphQL concept into Ruby!&rdquo; This is because GraphQL non-null types are expressed with <code>!</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># This field always returns a User, never `null`</span>
</span><span class='line'><span class="ss">author</span><span class="p">:</span> <span class="no">User</span><span class="o">!</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, why not express the concept with Ruby&rsquo;s <code>!</code> method (which is usually used for negation)?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:author</span><span class="p">,</span> <span class="o">!</span><span class="no">User</span>
</span></code></pre></td></tr></table></div></figure>


<p>As it turns out, there are several good reasons for <em>why not</em>!</p>

<ul>
<li>Overriding <code>!</code> breaks the negation operator. ActiveSupport&rsquo;s <code>.present?</code> didn&rsquo;t work with type objects, because <code>!</code> didn&rsquo;t return <code>false</code>, it returned a non-null type.</li>
<li>Overriding the <code>!</code> operator throws people off. When a newcomer sees GraphQL-Ruby sample code, they have a WTF moment, followed by the dreadful memory (or discovery) that Ruby allows you to override <code>!</code>.</li>
<li>There&rsquo;s very little value in importing GraphQL concepts into Ruby. GraphQL-Ruby developers are generally seasoned Ruby developers who are just learning GraphQL, so they don&rsquo;t gain anything by the similarity to GraphQL.</li>
</ul>


<p>So, overriding <code>!</code> didn&rsquo;t deliver any value, but it did present a roadblock to developers and break some really essential code.</p>

<p>In the new API, nullability is expressed with the options <code>null:</code> and <code>required:</code> instead of with <code>!</code>. (But, you can re-activate that override for compatibility while you transition to the new API.)</p>

<p>By switching to Ruby&rsquo;s happy path of classes and methods, we can help Ruby developers feel more at home in GraphQL definitions. Additionally, we avoid some unfamiliar gotchas of procs and clear a path for removing the <code>!</code> override.</p>

<h2>Rails Compatibility</h2>

<p>Rails&#8217; automatic constant loading is wonderful &hellip; until it&rsquo;s <em>not</em>! GraphQL-Ruby didn&rsquo;t play well with Rails&#8217; constant loading especially when it came to cyclical dependencies, and here&rsquo;s why.</p>

<p>Imagine a typical <code>.define</code>-style type definition, like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">Types</span><span class="p">:</span><span class="ss">:T</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:ObjectType</span><span class="o">.</span><span class="n">define</span> <span class="p">{</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>We&rsquo;re assigning the constant <code>Types::T</code> to the return value of <code>.define { ... }</code>. Consequently, the constant is not defined <em>until</em> <code>.define</code> returns.</p>

<p>Let&rsquo;s expand the example to two type definitions:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">Types</span><span class="p">:</span><span class="ss">:T1</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:ObjectType</span><span class="o">.</span><span class="n">define</span> <span class="p">{</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>
</span><span class='line'><span class="ss">Types</span><span class="p">:</span><span class="ss">:T2</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:ObjectType</span><span class="o">.</span><span class="n">define</span> <span class="p">{</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>If <code>T1</code> depends on <code>T2</code>, <em>and</em> <code>T2</code> depends on <code>T1</code>, how can this work? (For example, imagine a <code>Post</code> type whose <code>author</code> field returns a <code>User</code>, and a <code>User</code> type whose <code>posts</code> field returns a list of <code>Post</code>s. This kind of cyclical dependency is common!) GraphQL-Ruby&rsquo;s solution was to adopt a JavaScriptism, a <em>thunk</em>. (Technically, I guess it&rsquo;s a functional programming-ism, but I got it from <code>graphql-js</code>.) A <em>thunk</em> is an anonymous function used to defer the resolution of a value. For example, if we have code like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">Types</span><span class="p">:</span><span class="ss">:User</span>
</span><span class='line'><span class="c1"># NameError: uninitialized constant Types::User</span>
</span></code></pre></td></tr></table></div></figure>


<p>GraphQL-Ruby would accept this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">field</span> <span class="ss">:author</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="ss">Types</span><span class="p">:</span><span class="ss">:User</span> <span class="p">}</span>
</span><span class='line'><span class="c1"># Thanks for the function, I will call it later to get the value!</span>
</span></code></pre></td></tr></table></div></figure>


<p>Later, GraphQL-Ruby would <code>.call</code> the proc and get the value. At that type, <code>Types::User</code> would properly resolve to the correct type. This <em>worked</em> but it had two big downsides:</p>

<ul>
<li>It added an unfamiliar construct (<code>Proc</code>) in an unfamiliar context (a method argument), so it was frustrating and disorienting.</li>
<li>It added visual noise to the source code.</li>
</ul>


<p>How does switching to classes resolve this issue? To ask the same question, how come we don&rsquo;t experience this problem with normal Rails models?</p>

<p>Part of the answer has to do with <em>how classes are evaluated</em>. Consider two classes in two different files:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># app/graphql/types/post.rb</span>
</span><span class='line'><span class="k">module</span> <span class="nn">Types</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">BaseObject</span>
</span><span class='line'>    <span class="n">field</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">Types</span><span class="p">:</span><span class="ss">:User</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">false</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'><span class="c1"># app/graphql/types/user.rb</span>
</span><span class='line'><span class="k">module</span> <span class="nn">Types</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">BaseObject</span>
</span><span class='line'>    <span class="n">field</span> <span class="ss">:posts</span><span class="p">,</span> <span class="o">[</span><span class="ss">Types</span><span class="p">:</span><span class="ss">:Post</span><span class="o">]</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">false</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Notice that <code>Post</code> depends on <code>User</code>, and <code>User</code> depends on <code>Post</code>. The difference is how these lines are evaluated, and when the constants become defined. Here&rsquo;s the same code, with numbering to indicate the order that lines are evaluated:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Let&#39;s assume that `Post` is loaded first.</span>
</span><span class='line'><span class="c1"># app/graphql/types/post.rb</span>
</span><span class='line'><span class="k">module</span> <span class="nn">Types</span>                                  <span class="c1"># 1, evaluation starts here</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">Post</span> <span class="o">&lt;</span> <span class="no">BaseObject</span>                     <span class="c1"># 2, and naturally flows here, constant `Types::Post` is initialized as a class extending BaseObject</span>
</span><span class='line'>    <span class="n">field</span> <span class="ss">:author</span><span class="p">,</span> <span class="ss">Types</span><span class="p">:</span><span class="ss">:User</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">false</span>   <span class="c1"># 3, but when evaluating `Types::User`, jumps down below</span>
</span><span class='line'>  <span class="k">end</span>                                         <span class="c1"># 9, execution resumes here after loading `Types::User`</span>
</span><span class='line'><span class="k">end</span>                                           <span class="c1"># 10</span>
</span><span class='line'><span class="c1"># app/graphql/types/user.rb</span>
</span><span class='line'><span class="k">module</span> <span class="nn">Types</span>                                  <span class="c1"># 4, Rails opens this file looking for `Types::User`</span>
</span><span class='line'>  <span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">BaseObject</span>                     <span class="c1"># 5, constant `Types::User` is initialized</span>
</span><span class='line'>    <span class="n">field</span> <span class="ss">:posts</span><span class="p">,</span> <span class="o">[</span><span class="ss">Types</span><span class="p">:</span><span class="ss">:Post</span><span class="o">]</span><span class="p">,</span> <span class="ss">null</span><span class="p">:</span> <span class="kp">false</span>  <span class="c1"># 6, this line finishes without jumping, because `Types::Post` is _already_ initialized (see `# 2` above)</span>
</span><span class='line'>  <span class="k">end</span>                                         <span class="c1"># 7</span>
</span><span class='line'><span class="k">end</span>                                           <span class="c1"># 8</span>
</span></code></pre></td></tr></table></div></figure>


<p>Since <code>Types::Post</code> is <em>initialized</em> first, then built-up by the following lines of code, it&rsquo;s available to <code>Types::User</code> in the case of a circular dependency. As a result, the thunk is not necessary.</p>

<p>This approach isn&rsquo;t a silver bullet &ndash; <code>Types::Post</code> is not fully initialized by the time <code>Types::User</code> needs it &ndash; but it reduces visual friction and generally plays nice with Rails out of the box.</p>

<h2>Hackability</h2>

<p>I&rsquo;ve used a naughty word here, but in fact, I&rsquo;m talking about something very good. Have you ever been stuck with some dependency that didn&rsquo;t quite fit your application? (Or, maybe you were stuck on an old version, or your app needed a new feature that wasn&rsquo;t quite supported by the library.) Like it or not, sometimes the only way forward in a case like that is to hack it: reopen classes, redefine methods, mess with the inheritance chain, etc. Yes, those choices come with maintenance downsides, but sometimes they&rsquo;re really the best way forward.</p>

<p>On the other hand, really flexible libraries are <em>ready</em> for you to come and extend them. For example, they might provide base classes for you to extend, with the assumption that you&rsquo;ll override and implement certain methods. In that case, the same hacking techniques listed above have found their time to shine.</p>

<p><code>ActiveRecord::Base</code> is a great example of both cases: plenty of libraries hack methods right into the built-in class (for example, <code>acts_as_{whatever}</code>), and also, lots of Rails apps use an <code>ApplicationRecord</code> class for their application-specific customizations.</p>

<p>Since GraphQL-Ruby didn&rsquo;t use the familiar arrangement of classes and methods, it was closed to this kind of extension. (Ok, you <em>could</em> do it, but it was a lot of work! And who wants to do that!?) In place of this, GraphQL-Ruby had yet-another-API for extending its DSL. Yet another thing to learn, with more Proc literals 😪.</p>

<p>Using classes simplifies this process because you can use familiar Ruby techniques to build your GraphQL schema. For example, if you want to share code between field resolvers, you can <code>include</code> a module and call its methods. If you want to make shorthands for common cases in your app, you can use your <code>Base</code> type classes. If you want to add special configuration to your types, you can use class methods. And, whenever that day should come, when you need to monkey-patch GraphQL-Ruby internals, I hope you&rsquo;ll be able to find the right spot to do it!</p>

<h2>Stay Classy</h2>

<p>GraphQL-Ruby is three years old now, and I&rsquo;ve learned a LOT during that time! I&rsquo;m really thankful for the opportunity to focus on <em>developer productivity</em> in the last few months, learning how I&rsquo;ve prevented it and working on ways to improve it. I hope to keep working on topics like this &ndash; how to make GraphQL more productive for Ruby developers &ndash; in the next year, especially, so if you have feedback on this new API, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> to share it!</p>

<p>I&rsquo;m excited to see how this new API changes the way people think about GraphQL in Ruby, and I hope it will foster more creativity and stability.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Type Checking Roundup]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/10/06/ruby-type-checking-roundup/"/>
    <updated>2017-10-06T09:00:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/10/06/ruby-type-checking-roundup</id>
    <content type="html"><![CDATA[<p>This fall, several people presented their work on Ruby type checkers. So let&rsquo;s take a look: what&rsquo;s the big deal, and what have they been up to?</p>

<!-- more -->


<h2>Why Type Check?</h2>

<p>Part of Ruby&rsquo;s appeal is to be <em>free</em> of the cruft of its predecessors. So why is there so much interest in <em>adding</em> types to Ruby?</p>

<ul>
<li>Large, sprawling projects are becoming more common. At Ruby&rsquo;s inception, there were no 10-year-old Rails apps which people struggled to maintain, only greenfield Ruby scripts for toy projects.</li>
<li>Programmers have experienced excellent type systems in other languages, and want those benefits in Ruby.</li>
<li><em>Optional</em>, gradual type systems have been introduced to Python and JavaScript and they&rsquo;re big successes.</li>
</ul>


<p>What are the benefits?</p>

<ul>
<li><strong>Correctness</strong>: Type checking, like testing, is a way to be confident that your codebase is functioning properly. Employing a type checker can help you find bugs during development and prevent those bugs from going to production.</li>
<li><strong>Confidence</strong>: Since an incorrect program won&rsquo;t pass type checking, developers can refactor with more confidence. Common errors such as typos and argument errors can be caught by the type checker.</li>
<li><strong>Design</strong>: The type system gives you a way to think about the program. Specifically, types document and define the <em>boundaries</em> between parts of code, like methods, classes and modules.</li>
</ul>


<p>To experience a great type system in a Ruby-like language, I recommend <a href="https://crystal-lang.org/">Crystal</a>.</p>

<h2>Jeff Foster, StrangeLoop 2017</h2>

<p><a href="http://www.cs.umd.edu/~jfoster/">Jeff Foster</a> is a professor at the <a href="http://www.umd.edu/">University of Maryland, College Park</a> and works in the <a href="http://www.cs.umd.edu/projects/PL/">programming languages group</a>. Along with his students, he&rsquo;s been exploring Ruby type checkers for <strong>nine years</strong>! This year, he gave a presentation at StrangeLoop, <a href="https://www.youtube.com/watch?v=buY54I7mEjA">Type Checking Ruby</a>.</p>

<p>He described his various avenues of research over the years, and how they influenced one another, leading to a final question:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Talk</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
</span><span class='line'>  <span class="n">belongs_to</span> <span class="ss">:owner</span><span class="p">,</span> <span class="n">class_name</span><span class="p">:</span> <span class="s2">&quot;User&quot;</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">def</span> <span class="nf">owner?</span><span class="p">(</span><span class="n">other_user</span><span class="p">)</span>
</span><span class='line'>    <span class="c1"># QUESTION</span>
</span><span class='line'>    <span class="c1"># How to know the type of `#owner` method at this point?</span>
</span><span class='line'>    <span class="n">owner</span> <span class="o">==</span> <span class="n">other_user</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>His early work revolved around <em>static</em> type checking: annotations in the source code were given to a type checker, which used those annotations to assert that the Ruby code was correct.</p>

<p>This approach had a fundamental limitation: how can dynamically-created methods (like <code>Talk#owner</code> above) be statically annotated?</p>

<p>This drove him and his team to develop <a href="https://github.com/plum-umd/rdl">RDL</a>, a <em>dynamic</em> type checker. In RDL, types are declared using <em>methods</em> instead of annotations, for example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">type</span> <span class="s1">&#39;(Integer, Integer) -&gt; Integer&#39;</span>
</span><span class='line'><span class="k">def</span> <span class="nf">multiply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>  <span class="n">x</span> <span class="o">*</span> <span class="n">y</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>By using methods, it handles metaprogramming in a straightforward way. It hooks into Rails&#8217; <code>.belongs_to</code> and adds annotations for the generated methods, for example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Rails&#39; belongs_to method</span>
</span><span class='line'><span class="k">def</span> <span class="nf">belongs_to</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="n">options</span> <span class="o">=</span> <span class="p">{})</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'>  <span class="c1"># define a reader method, like `Talk#owner` above</span>
</span><span class='line'>  <span class="n">type</span> <span class="s2">&quot;() -&gt; </span><span class="si">#{</span><span class="n">class_name</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>  <span class="n">define_method</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span> <span class="k">do</span>
</span><span class='line'>    <span class="c1"># ...</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>(In reality, RDL uses <a href="https://github.com/plum-umd/rdl#preconditions-and-postconditions">conditions</a>, not monkey-patching, to achieve this.)</p>

<p>In this approach, type information is <em>gathered while the program runs</em>, but the typecheck is deferred until the method is called. At that point, RDL checks the source code (static information) using the runtime data (dynamic information). For this reason, RDL is called &ldquo;Just-in-Time Static Type Checking.&rdquo;</p>

<p>You can learn more about RDL in several places:</p>

<ul>
<li>RDL on GitHub: <a href="https://github.com/plum-umd/rdl">https://github.com/plum-umd/rdl</a></li>
<li>StrangeLoop 2017 talk: <a href="https://www.youtube.com/watch?v=buY54I7mEjA">https://www.youtube.com/watch?v=buY54I7mEjA</a></li>
<li>Academic papers from the folks behind RDL: <a href="https://github.com/plum-umd/rdl#bibliography">https://github.com/plum-umd/rdl#bibliography</a></li>
</ul>


<p>Personally, I can&rsquo;t wait to take RDL for a try. At the conference, Jeff mentioned that <em>type inference</em> was on his radar. That would take RDL to the next level!</p>

<p>Not to read into it too far, but it looks like <a href="https://github.com/plum-umd/rdl/issues/40#issuecomment-329135921">Stripe is exploring RDL</a> 😎.</p>

<h2>Soutaro Matsumoto, RubyKaigi 2017</h2>

<p>Soutaro Matsumoto also has significant academic experience with type checking Ruby, and this year, he presented some of his work at RubyKaigi in <a href="https://youtu.be/JExXdUux024">Type Checking Ruby Programs with Annotations</a>.</p>

<p>He begins with an overview of type checking Ruby, and surveys the previous work in type inference. He also points out how requirements should be relaxed for Ruby:</p>

<ul>
<li><strong><del>Correctness</del> -> Forget correctness</strong> (Allow a mix of typed and untyped code, so that developers can work quickly when they don&rsquo;t want or need types.)</li>
<li><strong><del>Static</del> -> Defer type checking to runtime</strong> (He mentions RDL in this context)</li>
<li><strong><del>No annotations</del> -> Let programmers write types</strong> (<em>Completely</em> inferring types is not possible, so accept some hints from the developers.)</li>
</ul>


<p>Then, he introduces his recent project, <a href="https://github.com/soutaro/steep">Steep</a>.</p>

<p>Steep&rsquo;s approach is familiar, but new to Ruby. It has three steps:</p>

<ul>
<li>Write a <code>.rbi</code> file which describes the types in your program, using a special type language, for example:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Talk</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">owner</span><span class="p">:</span> <span class="p">(</span><span class="no">User</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_Boolean</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li>Add annotations to your Ruby code to connect it to your types:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">Talk</span> <span class="o">&lt;</span> <span class="ss">ActiveRecord</span><span class="p">:</span><span class="ss">:Base</span>
</span><span class='line'>  <span class="n">belongs_to</span> <span class="ss">:owner</span><span class="p">,</span> <span class="n">class_name</span><span class="p">:</span> <span class="s2">&quot;User&quot;</span>
</span><span class='line'>  <span class="c1"># @dynamic owner</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>  Some connections between Ruby source and the <code>.rbi</code> files can be made automatically; others require explicit annotations.</p>

<ul>
<li><p>Run the type checker:</p>

<pre><code>$ steep check app/models/talk.rb
</code></pre></li>
</ul>


<p>It reminds me a bit of the <code>.h</code>/<code>.c</code> files in a C project.</p>

<p>Soutaro is also presenting his work at <a href="http://rubyconf.org/program#session-233">this winter&rsquo;s RubyConf</a>.</p>

<h2>Valentin Fondaratov, RubyKaigi 2017</h2>

<p>Valentin works at JetBrains (creators of <a href="https://www.jetbrains.com/ruby/">RubyMine</a>) and presented his work on type-checking based on <em>runtime</em> data. His presentation, <a href="https://www.youtube.com/watch?v=JS6m2gke0Ic">Automated Type Contracts Generation for Ruby</a>, was really fascinating and offered a promising glimpse of what a Ruby type ecosystem could be.</p>

<p>Valentin started by covering RubyMine&rsquo;s current type checking system:</p>

<ul>
<li>RubyMine tries to resolve identifiers (eg, method names, constant names) to their implementations</li>
<li>But this is hard: given <code>obj.execute</code>, what method does it call?</li>
<li>Developers can provide hints with YARD documentation</li>
<li>RubyMine uses this to support autocomplete, error prediction, and rename refactorings</li>
</ul>


<p>He also pointed out that even code coverage is not enough: 100% code coverage does <em>not</em> guarantee that all <em>possible</em> codepaths were run. For example, any composition of <code>if</code> branches require a cross-product of codepaths, not only that each line is executed once. Besides that, code coverage does <em>not</em> analyze the coverage of your dependencies&#8217; code (ie, RubyGems).</p>

<p>So, Valentin suggests getting <em>more</em> from our unit tests: what if we <em>observed</em> the running program, and kept notes about what values were passed around and how they were used? In this arrangement, that <em>runtime</em> data could be accumulated, then used for type checking.</p>

<p>Impressively, he introduced the implementation of this, first using a <a href="ruby-doc.org/core-2.4.0/TracePoint.html">TracePoint</a>, then digging into the Ruby VM to get even more granular data.</p>

<p>However, the gathered data can be very complicated. For example, how can we understand the input type of <code>String#split</code>?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># A lot of type checking data generated at runtime:</span>
</span><span class='line'><span class="c1"># call                                # Input type</span>
</span><span class='line'><span class="s2">&quot;1,2,,3,4,,&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>               <span class="c1"># (String, nil)</span>
</span><span class='line'><span class="c1"># =&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;]</span>
</span><span class='line'><span class="s2">&quot;1,2,,3,4,,&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>            <span class="c1"># (String, Integer)</span>
</span><span class='line'><span class="c1"># =&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3,4,,&quot;]</span>
</span><span class='line'><span class="s2">&quot;1,2,,3,4,,&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">4</span><span class="p">)</span>           <span class="c1"># (String, Integer)</span>
</span><span class='line'><span class="c1"># =&gt; [&quot;1&quot;, &quot;2&quot;, &quot;&quot;, &quot;3&quot;, &quot;4&quot;, &quot;&quot;, &quot;&quot;]</span>
</span><span class='line'><span class="s2">&quot;1,2,,3,4,,&quot;</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="sr">/\d/</span><span class="p">)</span>              <span class="c1"># (Regexp, nil)</span>
</span><span class='line'><span class="c1"># =&gt; [&quot;&quot;, &quot;,&quot;, &quot;,,&quot;, &quot;,&quot;, &quot;,,&quot;]</span>
</span><span class='line'><span class="c1"># ...</span>
</span></code></pre></td></tr></table></div></figure>


<p>Valentin showed how a classic technique, finite automata, can be used to reduce this information to a useful data structure.</p>

<p>Then, this runtime data can be used to <em>generate</em> type annotations (as YARD docs).</p>

<p>Finally, he imagines a type ecosystem for Ruby:</p>

<ul>
<li>Users contribute their (anonymized) runtime information for their RubyGem depenedencies</li>
<li>This data is pooled into a shared database, merged by RubyGem &amp; version</li>
<li>Users can draw type data <em>from</em> the shared database</li>
</ul>


<p>Personally, I think this is a great future to pursue:</p>

<ul>
<li>Developers can <em>gain</em> type checking without any annotations</li>
<li>Annotations can become very robust because resources are shared</li>
<li><em>Real</em> 100% coverage is possible via community collaboration</li>
</ul>


<p>You can see the project on GitHub: <a href="https://github.com/JetBrains/ruby-type-inference">https://github.com/JetBrains/ruby-type-inference</a></p>

<h2>Summary</h2>

<p>There&rsquo;s a lot of technically-savvy and academically-informed work on type checking Ruby! Many of the techniques preserve Ruby&rsquo;s productivity and dynamism while improving the developer experience and confidence. What makes them unique is their use of <em>runtime</em> data, to observe the program in action, then make assertions about the source code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's new in React-Rails 2.0?]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/04/13/whats-new-in-react-rails-2-dot-0/"/>
    <updated>2017-04-13T11:59:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/04/13/whats-new-in-react-rails-2-dot-0</id>
    <content type="html"><![CDATA[<p>For <a href="http://planning.center">Planning Center</a> free week, I cooked up <a href="https://github.com/reactjs/react-rails"><code>react-rails</code></a> 2.0 🎊.</p>

<!-- more -->


<p>Here are a few highlights. For the full list, see the <a href="https://github.com/reactjs/react-rails/blob/master/CHANGELOG.md">changelog</a>!</p>

<h2>Webpacker support</h2>

<p><a href="https://github.com/rails/webpacker">Webpacker</a> was great to work with. <code>react-rails</code> now supports webpacker for:</p>

<ul>
<li>Mounting components with <code>&lt;%= react_component(...) %&gt;</code> via <code>require</code></li>
<li>Server rendering from a webpacker pack (<code>server_rendering.js</code>)</li>
<li>Loading the unobtrusive JavaScript (UJS)</li>
<li>Installation and component generators</li>
</ul>


<p>A nice advantage of using webpacker is that you can load React.js from NPM instead of the <code>react-rails</code> gem. This way, you aren&rsquo;t bound to the React.js version which is included with the Ruby gem. You can pick any version you want!</p>

<h2>UJS on npm</h2>

<p>To support frontends built with Node.js, <code>react-rails</code>&rsquo;s  UJS driver is available on NPM as <a href="https://www.npmjs.com/package/react_ujs"><code>react_ujs</code></a>. It performs setup during <code>require</code>, so these two are equal:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Sprockets:</span>
</span><span class='line'><span class="c1">//= require react_ujs</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Node, etc:</span>
</span><span class='line'><span class="nx">require</span><span class="p">(</span><span class="s2">&quot;react_ujs&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Request-based prerender context</h2>

<p>If you&rsquo;re prerendering your React components on the server, you can perform setup and teardown in your Rails controller. For example, you might use these hooks to populate a flux store.</p>

<p>First, add the <code>per_request_react_rails_prerenderer</code> helper to your controller:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">PagesController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
</span><span class='line'>  <span class="n">per_request_react_rails_prerenderer</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then, you can access <code>react_rails_prerenderer</code> in the controller action:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">show</span>
</span><span class='line'>  <span class="n">js_context</span> <span class="o">=</span> <span class="n">react_rails_prerenderer</span><span class="o">.</span><span class="n">context</span>
</span><span class='line'>  <span class="n">js_context</span><span class="o">.</span><span class="n">exec</span><span class="p">(</span><span class="n">js_setup_code</span><span class="p">)</span>
</span><span class='line'>  <span class="n">render</span> <span class="ss">:show</span>
</span><span class='line'>  <span class="n">js_context</span><span class="o">.</span><span class="n">exec</span><span class="p">(</span><span class="n">js_teardown_code</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>That way, you can properly prepare &amp; clean up a JS VM for server rendering.</p>

<h2>Re-detect events</h2>

<p>Previously, <code>ReactRailsUJS</code> &ldquo;automatically&rdquo; detected which libraries you were using and hooked up to their events for rendering components.</p>

<p>It still checks for libraries during its initial load, but you can <em>also</em> re-check as needed:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="c1">// Check the global context for libraries like Turbolinks and hook up to them:</span>
</span><span class='line'><span class="nx">ReactRailsUJS</span><span class="p">.</span><span class="nx">detectEvents</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>This function removes previous event handlers, so it&rsquo;s safe to call anytime. (This was added in <code>2.0.2</code>.)</p>

<h2>Other Takeaways</h2>

<p>See the <a href="https://github.com/reactjs/react-rails/blob/master/CHANGELOG.md">changelog</a> for bug fixes and a new default server rendering configuration.</p>

<p>Webpacker is great! Setup was smooth and the APIs were clear and convenient. I&rsquo;m looking forward to using it more.</p>

<p>🍻 Here&rsquo;s to another major version of <code>react-rails</code>!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Watching files during Rails development]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/04/12/watching-files-during-rails-development/"/>
    <updated>2017-04-12T14:09:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/04/12/watching-files-during-rails-development</id>
    <content type="html"><![CDATA[<p>You can tell Ruby on Rails to respond to changes in certain files during development.</p>

<!-- more -->


<p>Rails knows to watch <code>config/routes.rb</code> for changes and reload them when the files change. You can use the same mechanism to watch other files and take action when they change.</p>

<p>I used this feature for <a href="https://github.com/reactjs/react-rails">react-rails</a> server rendering and for <a href="http://graphql.pro">GraphQL::Pro</a> static queries.</p>

<h2>app.reloader</h2>

<p>Every Rails app has <a href="https://github.com/rails/rails/blob/8f59a1dd878f56798f88369fa5b448f17a29679d/railties/lib/rails/application.rb#L135">a <code>@reloader</code></a>, which is a local subclass of <a href="http://api.rubyonrails.org/classes/ActiveSupport/Reloader.html"><code>ActiveSupport::Reloader</code></a>. It&rsquo;s used whenever you call <a href="https://github.com/rails/rails/blob/fe1f4b2ad56f010a4e9b93d547d63a15953d9dc2/railties/lib/rails/console/app.rb#L29-L34"><code>reload!</code> in the Rails console</a>.</p>

<p>It&rsquo;s attached to a <a href="https://github.com/rails/rails/blob/d3c9d808e3e242155a44fd2a89ef272cfade8fe8/railties/lib/rails/application/default_middleware_stack.rb#L51-L53">rack middleware</a> which <a href="https://github.com/rails/rails/blob/d3c9d808e3e242155a44fd2a89ef272cfade8fe8/actionpack/lib/action_dispatch/middleware/executor.rb#L10">calls <code>#run!</code></a> (which, in turn, <a href="https://github.com/rails/rails/blob/291a098c111ff419506094e14c0186389b0020ca/activesupport/lib/active_support/reloader.rb#L57-L63">calls the reload blocks if it detects changes</a>).</p>

<h2>config.to_prepare</h2>

<p>You can add custom preparation hooks with <code>config.to_prepare</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">initializer</span> <span class="ss">:my_custom_preparation</span> <span class="k">do</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span>
</span><span class='line'>  <span class="n">config</span><span class="o">.</span><span class="n">to_prepare</span> <span class="k">do</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;Reloading now ...&quot;</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>When Rails detects a change, this block will be called. It&rsquo;s implemented by <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L53-L55">registering the block with <code>app.reloader</code></a>.</p>

<h2>app.reloaders</h2>

<p>To add <em>new conditions</em> for which Rails should reload, you can add to the <a href="https://github.com/rails/rails/blob/8f59a1dd878f56798f88369fa5b448f17a29679d/railties/lib/rails/application.rb#L126"><code>app.reloaders</code> array</a>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Object responds to `#updated?`</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyWatcher</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">updated?</span>
</span><span class='line'>    <span class="c1"># ...</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># ...</span>
</span><span class='line'>
</span><span class='line'><span class="n">initializer</span> <span class="ss">:my_custom_watch_condition</span> <span class="k">do</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span>
</span><span class='line'>  <span class="c1"># Register custom reloader:</span>
</span><span class='line'>  <span class="n">app</span><span class="o">.</span><span class="n">reloaders</span> <span class="o">&lt;&lt;</span> <span class="no">MyWatcher</span><span class="o">.</span><span class="n">new</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The object&rsquo;s <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L156-L158"><code>updated?</code> method will be called</a> by the reloader. If any reloader returns <code>true</code>, the middleware will run all <code>to_prepare</code> blocks (via the call to <code>@reloader.run!</code>).</p>

<h2>FileUpdateChecker</h2>

<p>Rails includes a goodie for watching files. <a href="http://api.rubyonrails.org/classes/ActiveSupport/FileUpdateChecker.html"><code>ActiveSupport::FileUpdateChecker</code></a> is great for:</p>

<ul>
<li>Watching specific files for changes (<a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/routes_reloader.rb#L41"><code>config/routes.rb</code> is watched this way</a>)</li>
<li>Watching a directory of files for changes, additions and deletions (<a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L164"><code>app/**/*.rb</code> is watched this way</a>)</li>
</ul>


<p>You can create your own <code>FileUpdateChecker</code> and add it to <code>app.reloaders</code> to reload Rails when certain files change:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Watch specific files:</span>
</span><span class='line'><span class="n">app</span><span class="o">.</span><span class="n">reloaders</span> <span class="o">&lt;&lt;</span> <span class="ss">ActiveSupport</span><span class="p">:</span><span class="ss">:FileUpdateChecker</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">[</span><span class="s2">&quot;my_important_file.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;my_other_important_file.txt&quot;</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'><span class="c1"># Watch directory-extension pairs, eg all `.txt` and `.md` files in `app/important_files` and subdirectories:</span>
</span><span class='line'><span class="n">app</span><span class="o">.</span><span class="n">reloaders</span> <span class="o">&lt;&lt;</span> <span class="ss">ActiveSupport</span><span class="p">:</span><span class="ss">:FileUpdateChecker</span><span class="p">(</span><span class="o">[]</span><span class="p">,</span> <span class="p">{</span> <span class="s2">&quot;app/important_files&quot;</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;.md&quot;</span><span class="o">]</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>Some filesystems support an evented file watcher implementation, <a href="http://api.rubyonrails.org/classes/ActiveSupport/EventedFileUpdateChecker.html"><code>ActiveSupport::EventedFileUpdateChecker</code></a>. <code>app.config.file_watcher</code> will return the proper filewatcher class for the current context.</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">app</span><span class="o">.</span><span class="n">reloaders</span> <span class="o">&lt;&lt;</span> <span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">file_watcher</span><span class="p">(</span><span class="o">[</span><span class="s2">&quot;my_important_file.txt&quot;</span><span class="p">,</span> <span class="s2">&quot;my_other_important_file.txt&quot;</span><span class="o">]</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<h2>All Together Now</h2>

<p><code>react-rails</code> maintains a pool of V8 instances for server rendering React components. These instances are initialized with a bunch of JavaScript code, and whenever a developer changes a JavaScript file, we need to reload them with the new code. This requires two steps:</p>

<ul>
<li>Adding a new watcher to <code>app.reloaders</code> to detect changes to JavaScript files</li>
<li>Adding a <code>to_prepare</code> hook to reload the JS instances</li>
</ul>


<p>It looks basically like this:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">initializer</span> <span class="s2">&quot;react_rails.watch_js_files&quot;</span> <span class="k">do</span> <span class="o">|</span><span class="n">app</span><span class="o">|</span>
</span><span class='line'>  <span class="c1"># Watch for changes to javascript files:</span>
</span><span class='line'>  <span class="n">app</span><span class="o">.</span><span class="n">reloaders</span> <span class="o">&lt;&lt;</span> <span class="n">app</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">file_watcher</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="o">[]</span><span class="p">,</span> <span class="p">{</span>
</span><span class='line'>    <span class="c1"># Watch the asset pipeline:</span>
</span><span class='line'>    <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;app/assets/javascripts&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;jsx&quot;</span><span class="p">,</span> <span class="s2">&quot;js&quot;</span><span class="o">]</span><span class="p">,</span>
</span><span class='line'>    <span class="c1"># Watch webpacker:</span>
</span><span class='line'>    <span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;app/javascript&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">to_s</span> <span class="o">=&gt;</span> <span class="o">[</span><span class="s2">&quot;jsx&quot;</span><span class="p">,</span> <span class="s2">&quot;js&quot;</span><span class="o">]</span>
</span><span class='line'>  <span class="p">})</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">config</span><span class="o">.</span><span class="n">to_prepare</span> <span class="k">do</span>
</span><span class='line'>    <span class="ss">React</span><span class="p">:</span><span class="ss">:ServerRendering</span><span class="o">.</span><span class="n">reset_pool</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>The <a href="https://github.com/reactjs/react-rails/blob/bbb1ff10c787ca6a186e39df57fe5b228b37bd7e/lib/react/rails/railtie.rb#L26-L39">full implementation</a> supports some customization. You can see similar (and more complicated) examples with <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L126-L142">routes reloading</a>, <a href="https://github.com/rails/rails/blob/e9abbb700acd8165a8994d8b2a700e507fb3b7ff/activesupport/lib/active_support/i18n_railtie.rb#L59-L74">i18n reloading</a> and <a href="https://github.com/rails/rails/blob/ce97c79445f9ac4b056e34deaaaaf25cadc08b72/railties/lib/rails/application/finisher.rb#L163-L183"><code>.rb</code> reloading</a>.</p>

<p>Happy reloading!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyping a GraphQL Schema From Definition With Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby/"/>
    <updated>2017-03-17T15:49:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby</id>
    <content type="html"><![CDATA[<p>GraphQL 1.5.0 includes a new way to define a schema: from a GraphQL definition.</p>

<!-- more -->


<p>In fact, loading a schema this way has been supported for while, but 1.5.0 adds the ability to specify field resolution behavior.</p>

<h2>GraphQL IDL</h2>

<p>Besides queries, GraphQL has an <em>interface definition language</em> (IDL) for expressing a schema’s structure. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">schema</span> <span class="p">{</span>
</span><span class='line'>  <span class="ss">query</span><span class="p">:</span> <span class="no">Query</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">type</span> <span class="no">Query</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">post</span><span class="p">(</span><span class="nb">id</span><span class="p">:</span> <span class="no">ID</span><span class="o">!</span><span class="p">):</span> <span class="no">Post</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">type</span> <span class="no">Post</span> <span class="p">{</span>
</span><span class='line'>  <span class="ss">title</span><span class="p">:</span> <span class="nb">String</span><span class="o">!</span>
</span><span class='line'>  <span class="ss">comments</span><span class="p">:</span> <span class="o">[</span><span class="no">Comment</span><span class="o">!]</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>You can turn a definition into a schema with <code>Schema.from_definition</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">schema_defn</span> <span class="o">=</span> <span class="s2">&quot;...&quot;</span>
</span><span class='line'><span class="n">schema</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Schema</span><span class="o">.</span><span class="n">from_definition</span><span class="p">(</span><span class="n">schema_defn</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>(By the way, the IDL is technically in <a href="https://github.com/facebook/graphql/pull/90">RFC stage</a>.)</p>

<h2>Resolvers</h2>

<p><code>Schema.from_definition</code> also accepts <code>default_resolve:</code> argument. It expects one of two inputs:</p>

<ul>
<li>A nested hash of type <code>Hash&lt;String =&gt; Hash&lt;String =&gt; #call(obj, args, ctx)&gt;&gt;</code>; or</li>
<li>An object that responds to <code>#call(type, field, obj, args, ctx)</code></li>
</ul>


<h4>Resolving with a Hash</h4>

<p>When you’re using a hash:</p>

<ul>
<li>The first key is a <em>type name</em></li>
<li>The second key is a <em>field name</em></li>
<li>The last value is a <em>resolve function</em> (<code>#call(obj, args, ctx)</code>)</li>
</ul>


<p>To get started, you can write the hash manually:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="s2">&quot;Query&quot;</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="s2">&quot;post&quot;</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="no">Post</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">args</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span> <span class="p">},</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'>  <span class="s2">&quot;Post&quot;</span> <span class="o">=&gt;</span> <span class="p">{</span>
</span><span class='line'>    <span class="s2">&quot;title&quot;</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="n">obj</span><span class="o">.</span><span class="n">title</span> <span class="p">},</span>
</span><span class='line'>    <span class="s2">&quot;body&quot;</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="n">obj</span><span class="o">.</span><span class="n">body</span> <span class="p">},</span>
</span><span class='line'>    <span class="s2">&quot;comments&quot;</span> <span class="o">=&gt;</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="n">obj</span><span class="o">.</span><span class="n">comments</span> <span class="p">},</span>
</span><span class='line'>  <span class="p">},</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>But you can also reduce a lot of boilerplate by using a hash with default values:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># This hash will fall back to default implementation if another value isn&#39;t provided:</span>
</span><span class='line'><span class="n">type_hash</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">h</span><span class="p">,</span> <span class="n">type_name</span><span class="o">|</span>
</span><span class='line'>  <span class="c1"># Each type gets a hash of fields:</span>
</span><span class='line'>  <span class="n">h</span><span class="o">[</span><span class="n">type_name</span><span class="o">]</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">h2</span><span class="p">,</span> <span class="n">field_name</span><span class="o">|</span>
</span><span class='line'>    <span class="c1"># Default resolve behavior is `obj.public_send(field_name, args, ctx)`</span>
</span><span class='line'>    <span class="n">h2</span><span class="o">[</span><span class="n">field_name</span><span class="o">]</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="n">obj</span><span class="o">.</span><span class="n">public_send</span><span class="p">(</span><span class="n">field_name</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">type_hash</span><span class="o">[</span><span class="s2">&quot;Query&quot;</span><span class="o">][</span><span class="s2">&quot;post&quot;</span><span class="o">]</span> <span class="o">=</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="no">Post</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">args</span><span class="o">[</span><span class="ss">:id</span><span class="o">]</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="n">schema</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Schema</span><span class="o">.</span><span class="n">from_definition</span><span class="p">(</span><span class="n">schema_defn</span><span class="p">,</span> <span class="n">default_resolve</span><span class="p">:</span> <span class="n">type_hash</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>Isn’t that a nice way to set up a simple schema?</p>

<h4>Resolving with a Single Function</h4>

<p>You can provide a single callable that responds to <code>#call(type, field, obj, args, ctx)</code>. What a mouthful!</p>

<p>The <em>advantage</em> of that hefty method signature is that it’s enough to specify any resolution behavior you can imagine. For example, you could create a system where type modules were found by name, then methods were called by name:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">module</span> <span class="nn">ExecuteGraphQLByConvention</span>
</span><span class='line'>  <span class="kp">module_function</span>
</span><span class='line'>  <span class="c1"># Find a Ruby module corresponding to `type`,</span>
</span><span class='line'>  <span class="c1"># then call its method corresponding to `field`.</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">call</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
</span><span class='line'>    <span class="n">type_module</span> <span class="o">=</span> <span class="no">Object</span><span class="o">.</span><span class="n">const_get</span><span class="p">(</span><span class="n">type</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
</span><span class='line'>    <span class="n">type_module</span><span class="o">.</span><span class="n">public_send</span><span class="p">(</span><span class="n">field</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">schema</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Schema</span><span class="o">.</span><span class="n">from_definition</span><span class="p">(</span><span class="n">schema_defn</span><span class="p">,</span> <span class="n">default_resolve</span><span class="p">:</span> <span class="no">ExecuteGraphQLByConvention</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, a single function combined with Ruby’s flexibility and power opens a lot of doors!</p>

<p>Doesn’t it remind you a bit of method dispatch? The arguments are:</p>

<table>
<thead>
<tr>
<th>GraphQL Field Resolution </th>
<th> Method Dispatch</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type</code> </td>
<td> class</td>
</tr>
<tr>
<td><code>field</code> </td>
<td> method</td>
</tr>
<tr>
<td><code>obj</code> </td>
<td> receiver</td>
</tr>
<tr>
<td><code>args</code> </td>
<td> method arguments</td>
</tr>
<tr>
<td><code>ctx</code> </td>
<td> runtime state (cf <a href="https://github.com/mruby/mruby/blob/master/include/mruby.h#L257"><code>mrb_state</code></a>, <a href="https://github.com/antirez/redis/blob/unstable/src/modules/INTRO.md"><code>RedisModuleCtx</code></a>, or <a href="http://erlang.org/doc/tutorial/nif.html"><code>ErlNifEnv</code></a>)</td>
</tr>
</tbody>
</table>


<h2>Special Configurations</h2>

<p>Some schemas need other configurations in order to run:</p>

<ul>
<li><code>resolve_type</code> to support union and interface types</li>
<li>schema plugins like <a href="https://rmosolgo.github.io/graphql-ruby/pro/monitoring">monitoring</a> or custom <a href="https://rmosolgo.github.io/graphql-ruby/schema/instrumentation">instrumentation</a></li>
</ul>


<p>To add these to a schema, use <code>.redefine</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Extend the schema with new definitions:</span>
</span><span class='line'><span class="n">schema</span> <span class="o">=</span> <span class="n">schema</span><span class="o">.</span><span class="n">redefine</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">resolve_type</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span> <span class="o">.</span><span class="n">.</span><span class="o">.</span> <span class="p">}</span>
</span><span class='line'>  <span class="n">monitoring</span> <span class="ss">:appsignal</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>What’s Next?</h2>

<p>Rails has proven that “Convention over Configuration” can be a very productive way to start new projects, so I’m interested in exploring convention-based APIs on top of this feature.</p>

<p>In the future, I’d like to add support for schema annotations in the form of directives, for example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">type</span> <span class="no">Post</span> <span class="p">{</span>
</span><span class='line'>  <span class="ss">comments</span><span class="p">:</span> <span class="o">[</span><span class="no">Comment</span><span class="o">!]</span> <span class="vi">@relation</span><span class="p">(</span><span class="ss">hasMany</span><span class="p">:</span> <span class="s2">&quot;comments&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>These could be used to customize resolution behavior. Cool!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tracking Schema Changes with GraphQL-Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby/"/>
    <updated>2017-03-16T20:16:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby</id>
    <content type="html"><![CDATA[<p>One way to keep an eye on your GraphQL schema is to check the definition into source control.</p>

<!-- more -->


<p>When modifying shared code or reconfiguring, it can be hard to tell how the schema will <em>really</em> change. To help with this, set up a <strong>snapshot test</strong> for your GraphQL schema! This way:</p>

<ul>
<li>Changes will be clearly visible in GraphQL IDL</li>
<li>You can keep the IDL up-to-date by adding a test to your suite</li>
</ul>


<p>You can even track the schema from different contexts if you&rsquo;re using <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization framework</a>.</p>

<p>This approach was first described in <a href="https://www.youtube.com/watch?v=Wlu_PWCjc6Y">GraphQL at Shopify</a>.</p>

<h2>Check It In</h2>

<p>Write a <strong>Rake task</strong> to get your schema&rsquo;s definition and write it to a file:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># lib/tasks/graphql.rake</span>
</span><span class='line'><span class="n">rake</span> <span class="n">dump_schema</span><span class="p">:</span> <span class="ss">:environment</span> <span class="k">do</span>
</span><span class='line'>  <span class="c1"># Get a string containing the definition in GraphQL IDL:</span>
</span><span class='line'>  <span class="n">schema_defn</span> <span class="o">=</span> <span class="no">MyAppSchema</span><span class="o">.</span><span class="n">to_definition</span>
</span><span class='line'>  <span class="c1"># Choose a place to write the schema dump:</span>
</span><span class='line'>  <span class="n">schema_path</span> <span class="o">=</span> <span class="s2">&quot;app/graphql/schema.graphql&quot;</span>
</span><span class='line'>  <span class="c1"># Write the schema dump to that file:</span>
</span><span class='line'>  <span class="no">File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">schema_path</span><span class="p">),</span> <span class="n">schema_defn</span><span class="p">)</span>
</span><span class='line'>  <span class="nb">puts</span> <span class="s2">&quot;Updated </span><span class="si">#{</span><span class="n">schema_path</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>You can run it from terminal:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>bundle <span class="nb">exec </span>rake dump_schema
</span><span class='line'>Updated app/graphql/schema.graphql
</span></code></pre></td></tr></table></div></figure>


<p>This updates the file in your repo. Go ahead and <strong>check it in</strong>!</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='sh'><span class='line'><span class="nv">$ </span>git add app/graphql/schema.graphql
</span><span class='line'><span class="nv">$ </span>git commit -m <span class="s2">&quot;Add GraphQL schema dump&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Keep It Up to Date</h2>

<p>Any changes to the Ruby schema code must be reflected in the <code>.graphql</code> file. You can give yourself a reminder by adding a <strong>test case</strong> which asserts that the GraphQL definition is up-to-date:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># test/graphql/my_app_schema_test.rb</span>
</span><span class='line'><span class="nb">require</span> <span class="s2">&quot;test_helper&quot;</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">MyAppSchemaTest</span> <span class="o">&lt;</span> <span class="ss">ActiveSupport</span><span class="p">:</span><span class="ss">:TestCase</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">test_printout_is_up_to_date</span>
</span><span class='line'>    <span class="n">current_defn</span> <span class="o">=</span> <span class="no">MyAppSchema</span><span class="o">.</span><span class="n">to_definition</span>
</span><span class='line'>    <span class="n">printout_defn</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;app/graphql/schema.graphql&quot;</span><span class="p">))</span>
</span><span class='line'>    <span class="n">assert_equal</span><span class="p">(</span><span class="n">current_defn</span><span class="p">,</span> <span class="n">printout_defn</span><span class="p">,</span> <span class="s2">&quot;Update the printed schema with `bundle exec rake dump_schema`&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>If the definition is stale, you&rsquo;ll get a failed test:</p>

<p><img src="http://rmosolgo.github.io/images/tracking_schema/test_failure.png" width="500"></p>

<p>This reminder is helpful in development and <em>essential</em> during code review!</p>

<h2>Review It</h2>

<p>Now that your schema definition is versioned along with your code, you can see changes during <strong>code review</strong>:</p>

<p><img src="http://rmosolgo.github.io/images/tracking_schema/code_review.png" width="600"></p>

<h2>Multiple Schema Dumps</h2>

<p>If your schema looks different to different users, you can track <em>multiple</em> schema dumps. This is helpful if:</p>

<ul>
<li>You&rsquo;re using the <code>:view</code> configuration of <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization</a></li>
<li>You&rsquo;re using <code>only:</code>/ <code>except:</code> to manually filter your schema</li>
</ul>


<p>Just provide the <code>context:</code> argument to <code>Schema.to_definition</code> as if you were running a query. (Also provide <code>only:</code>/<code>except:</code> if you use them.)</p>

<p>Print with a filter from the Rake task:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># lib/tasks/graphql.rake</span>
</span><span class='line'><span class="n">task</span> <span class="n">dump_schema</span><span class="p">:</span> <span class="ss">:environment</span> <span class="k">do</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'>  <span class="n">admin_user</span> <span class="o">=</span> <span class="no">OpenStruct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">admin?</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span>
</span><span class='line'>  <span class="n">admin_schema_dump</span> <span class="o">=</span> <span class="no">MyAppSchema</span><span class="o">.</span><span class="n">to_definition</span><span class="p">(</span><span class="ss">context</span><span class="p">:</span> <span class="p">{</span> <span class="n">current_user</span><span class="p">:</span> <span class="n">admin_user</span> <span class="p">})</span>
</span><span class='line'>  <span class="n">admin_schema_path</span> <span class="o">=</span> <span class="s2">&quot;app/graphql/admin_schema.graphql&quot;</span>
</span><span class='line'>  <span class="no">File</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">admin_schema_path</span><span class="p">),</span> <span class="n">admin_schema_dump</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Test with a filter from the test case:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">test_printout_is_up_to_date</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'>  <span class="n">admin_user</span> <span class="o">=</span> <span class="no">OpenStruct</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">admin?</span><span class="p">:</span> <span class="kp">true</span><span class="p">)</span>
</span><span class='line'>  <span class="n">current_admin_defn</span> <span class="o">=</span> <span class="no">MyAppSchema</span><span class="o">.</span><span class="n">to_definition</span><span class="p">(</span><span class="ss">context</span><span class="p">:</span> <span class="p">{</span> <span class="n">current_user</span><span class="p">:</span> <span class="n">admin_user</span> <span class="p">})</span>
</span><span class='line'>  <span class="n">printout_admin_defn</span> <span class="o">=</span> <span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="no">Rails</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s2">&quot;app/graphql/admin_schema.graphql&quot;</span><span class="p">))</span>
</span><span class='line'>  <span class="n">assert_equal</span><span class="p">(</span><span class="n">current_admin_defn</span><span class="p">,</span> <span class="n">printout_admin_defn</span><span class="p">,</span> <span class="s2">&quot;Update the printed schema with `bundle exec rake dump_schema`&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now you can keep an eye on the schema from several perspectives!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optimizing GraphQL-Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/08/optimizing-graphql-ruby/"/>
    <updated>2017-03-08T08:02:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/08/optimizing-graphql-ruby</id>
    <content type="html"><![CDATA[<p>Soon, <code>graphql-ruby</code> 1.5.0 will be released. Query execution will be ~70% faster than 1.3.0!</p>

<!-- more -->


<p>Let&rsquo;s look at how we reduced the execution time between those two versions. Thanks to <a href="https://github.com/theorygeek">@theorygeek</a> who optimized the middleware chain helped me pinpoint several other bottlenecks!</p>

<h2>The Benchmark</h2>

<p>To track GraphQL execution overhead, I <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/benchmark/run.rb">execute the introspection query</a> on a <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/spec/support/dummy/schema.rb">fixture schema</a> in graphql-ruby&rsquo;s test suite.</p>

<p>On GraphQL 1.3.0, the benchmark ran around 22.5 iterations per second:</p>

<p><img src="http://rmosolgo.github.io/images/optimizing_graphql_ruby/1-3-0-bench.png" width="500"></p>

<p>On <a href="https://github.com/rmosolgo/graphql-ruby/commit/943e68f40a11f3f809ecd8485282eccdd6a6991b">master</a>, it runs around 38 iterations per second:</p>

<p><img src="http://rmosolgo.github.io/images/optimizing_graphql_ruby/1-5-0-bench.png" width="500"></p>

<p>That&rsquo;s almost 1.7x faster!</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="mi">38</span><span class="o">.</span><span class="mi">0</span> <span class="o">/</span> <span class="mi">22</span><span class="o">.</span><span class="mi">5</span>
</span><span class='line'><span class="c1"># =&gt; 1.6888888888888889</span>
</span></code></pre></td></tr></table></div></figure>


<p>So, how&rsquo;d we do it?</p>

<h2>Looking Under the Hood with RubyProf</h2>

<p>To find where time was spent, I turned to <a href="https://github.com/ruby-prof/ruby-prof">ruby-prof</a>. I <a href="https://github.com/rmosolgo/graphql-ruby/pull/579">wrapped GraphQL execution</a> with profiling and inspected the result:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>Thread ID: 70149906635240
</span><span class='line'>Fiber ID: 70149911114440
</span><span class='line'>Total: 0.474618
</span><span class='line'>Sort by: self_time
</span><span class='line'>
</span><span class='line'> %self      total      self      wait     child     calls  name
</span><span class='line'>  4.60      0.074     0.022     0.000     0.052     6893  *Class#new
</span><span class='line'>  3.99      0.019     0.019     0.000     0.000     8715  *GraphQL::Define::InstanceDefinable#ensure_defined
</span><span class='line'>  3.13      0.015     0.015     0.000     0.000    25403   Module#===
</span><span class='line'>  2.64      0.013     0.013     0.000     0.000     8813   Kernel#hash
</span><span class='line'>  2.49      0.074     0.012     0.000     0.063     3496  *GraphQL::Schema::MiddlewareChain#call
</span><span class='line'>  1.85      0.009     0.009     0.000     0.000     4184   GraphQL::Query::Context::FieldResolutionContext#query
</span><span class='line'>  1.78      0.017     0.008     0.000     0.008     2141   #&lt;Module:0x007f9a18de37a8&gt;#type
</span><span class='line'>  1.63      0.008     0.008     0.000     0.000     1960   GraphQL::Query::Context::FieldResolutionContext#initialize
</span><span class='line'>  1.54      0.012     0.007     0.000     0.005     1748   GraphQL::Query#get_field
</span><span class='line'>  1.53      0.014     0.007     0.000     0.006     1748   GraphQL::Query#arguments_for
</span><span class='line'>  1.52      0.007     0.007     0.000     0.000     8356   Kernel#is_a?
</span><span class='line'>  1.51      0.010     0.007     0.000     0.003     7523   Kernel#===
</span><span class='line'>  1.44      0.022     0.007     0.000     0.015     1959   GraphQL::Query::Context::FieldResolutionContext#spawn
</span><span class='line'>  1.32      0.012     0.006     0.000     0.006     1748   GraphQL::Execution::Lazy::LazyMethodMap#get
</span><span class='line'>  1.31      0.010     0.006     0.000     0.003     1748   GraphQL::Execution::FieldResult#value=
</span><span class='line'>  1.29      0.032     0.006     0.000     0.026     1748   GraphQL::Field#resolve
</span><span class='line'>  1.25      0.042     0.006     0.000     0.037     1748   #&lt;Module:0x007f9a18de37a8&gt;#resolve
</span><span class='line'>  1.16      0.015     0.006     0.000     0.010     1748   GraphQL::Execution::FieldResult#initialize
</span><span class='line'>  1.06      0.010     0.005     0.000     0.005     2815   GraphQL::Schema::Warden#visible?
</span><span class='line'>  1.05      0.014     0.005     0.000     0.009     1748   GraphQL::Schema::MiddlewareChain#initialize
</span><span class='line'>  1.03      0.005     0.005     0.000     0.000     2815   &lt;Module::GraphQL::Query::NullExcept&gt;#call
</span><span class='line'>  0.97      0.014     0.005     0.000     0.009      756   Hash#each_value
</span><span class='line'># ... truncated ...
</span></code></pre></td></tr></table></div></figure>


<p>A few things stood out:</p>

<ul>
<li>~5% of time was spent during ~7k calls to <code>Class#new</code>: this is time spent initializing new objects. I think initialization can also trigger garbage collection (if there&rsquo;s not a spot on the free list), so this may include GC time.</li>
<li>~4% of time was spent during ~9k calls to <code>InstanceDefinable#ensure_defined</code>, which is part of graphql-ruby&rsquo;s definition API. It&rsquo;s <em>all</em> overhead to support the definition API, 😿.</li>
<li>Several methods are called <code>1748</code> times. Turns out, this is <em>once per field in the response</em>.</li>
<li>With that in mind, <code>25,403</code> seems like a lot of calls to <code>Module#===</code>!</li>
</ul>


<h2>Reduce GC Pressure</h2>

<p>Since <code>Class#new</code> was the call with the most <code>self</code> time, I thought I&rsquo;d start there. What kind of objects are being allocated? We can filter the profile output:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>~/code/graphql $ cat 130_prof.txt | grep initialize
</span><span class='line'>  1.63      0.008     0.008     0.000     0.000     1960   GraphQL::Query::Context::FieldResolutionContext#initialize
</span><span class='line'>  1.16      0.015     0.006     0.000     0.010     1748   GraphQL::Execution::FieldResult#initialize
</span><span class='line'>  1.05      0.014     0.005     0.000     0.009     1748   GraphQL::Schema::MiddlewareChain#initialize
</span><span class='line'>  0.69      0.006     0.003     0.000     0.002     1833   Kernel#initialize_dup
</span><span class='line'>  0.46      0.002     0.002     0.000     0.000     1768   Array#initialize_copy
</span><span class='line'>  0.30      0.001     0.001     0.000     0.000      419   GraphQL::Execution::SelectionResult#initialize
</span><span class='line'>  0.28      0.001     0.001     0.000     0.000      466   Hash#initialize
</span><span class='line'>  0.17      0.010     0.001     0.000     0.009       92   GraphQL::InternalRepresentation::Selection#initialize
</span><span class='line'>  0.15      0.002     0.001     0.000     0.001      162   Set#initialize
</span><span class='line'>  0.15      0.001     0.001     0.000     0.000       70   GraphQL::InternalRepresentation::Node#initialize
</span><span class='line'>  0.07      0.001     0.000     0.000     0.001       58   GraphQL::StaticValidation::FieldsWillMerge::FieldDefinitionComparison#initialize
</span><span class='line'>  0.04      0.001     0.000     0.000     0.000       64   GraphQL::Query::Arguments#initialize
</span><span class='line'>  0.01      0.000     0.000     0.000     0.000       11   GraphQL::StaticValidation::FragmentsAreUsed::FragmentInstance#initialize
</span><span class='line'>  0.01      0.000     0.000     0.000     0.000        1   GraphQL::Query#initialize
</span><span class='line'># ... truncated ...
</span></code></pre></td></tr></table></div></figure>


<p>Lots of GraphQL internals! That&rsquo;s good news though: those are within scope for optimization.</p>

<p><code>MiddlewareChain</code> was ripe for a refactor. In the old implementation, <em>each</em> field resolution created a middleware chain, then used it and discarded it. However, this was a waste of objects. Middlewares don&rsquo;t change during query execution, so we should be able to reuse the same list of middlewares for each field.</p>

<p>This required a bit of refactoring, since the old implementation modified the array (with <code>shift</code>) as it worked through middlewares. In the end, this improvement was added in <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/5549e0cff288a9aecd676603cbb62628a34b4ec8"><code>5549e0cf</code></a>. As a bonus, the number of created <code>Array</code>s (shown by <code>Array#initialize_copy</code>) also declined tremendously since they were used for <code>MiddlewareChain</code>&rsquo;s internal state. Also, calls to <code>Array#shift</code> were removed, since the array was no longer modified:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>~/code/graphql $ cat 130_prof.txt | grep shift
</span><span class='line'>  0.61      0.003     0.003     0.000     0.000     3496   Array#shift
</span><span class='line'>~/code/graphql $ cat 150_prof.txt | grep shift
</span><span class='line'>~/code/graphql $
</span></code></pre></td></tr></table></div></figure>


<p>🎉 !</p>

<p>The number <code>FieldResult</code> objects was also reduced. <code>FieldResult</code> is used for execution bookkeeping in some edge cases, but is often unneeded. So, we could optimize by removing the <code>FieldResult</code> object when we had a plain value (and therefore no bookkeeping was needed): <a href="https://github.com/rmosolgo/graphql-ruby/commit/07cbfa89031819d3886f220de8256e83ff59f298"><code>07cbfa89</code></a></p>

<p>A very modest optimization was also applied to <code>GraphQL::Arguments</code>, reusing the same object for empty argument lists (<a href="https://github.com/rmosolgo/graphql-ruby/pull/500/commits/4b07c9b46345144c7d88e429e7b55e09b0615517"><code>4b07c9b4</code></a>) and reusing the argument default values on a field-level basis (<a href="https://github.com/rmosolgo/graphql-ruby/pull/500/commits/4956149df0a4ab8a449679bcd9af20b3dad72585"><code>4956149d</code></a>).</p>

<h2>Avoid Duplicate Calculations</h2>

<p>Some elements of a GraphQL schema don&rsquo;t change during execution. As long as this holds true, we can cache the results of some calculations and avoid recalculating them.</p>

<p>A simple caching approach is to use a hash whose keys are the inputs and whose values are the cached outputs:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># Read-through cache for summing two numbers</span>
</span><span class='line'><span class="c1">#</span>
</span><span class='line'><span class="c1"># The first layer of the cache is the left-hand number:</span>
</span><span class='line'><span class="n">read_through_sum</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">hash1</span><span class="p">,</span> <span class="n">left_num</span><span class="o">|</span>
</span><span class='line'>  <span class="c1"># The second layer of the cache is the right-hand number:</span>
</span><span class='line'>  <span class="n">hash1</span><span class="o">[</span><span class="n">num1</span><span class="o">]</span> <span class="o">=</span> <span class="no">Hash</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">hash2</span><span class="p">,</span> <span class="n">right_num</span><span class="o">|</span>
</span><span class='line'>
</span><span class='line'>    <span class="c1"># And finally, the result is stored as a value in the second hash:</span>
</span><span class='line'>    <span class="nb">puts</span> <span class="s2">&quot;Adding </span><span class="si">#{</span><span class="n">left_num</span><span class="si">}</span><span class="s2"> + </span><span class="si">#{</span><span class="n">right_num</span><span class="si">}</span><span class="s2">&quot;</span>
</span><span class='line'>    <span class="n">hash2</span><span class="o">[</span><span class="n">right_num</span><span class="o">]</span> <span class="o">=</span> <span class="n">left_num</span> <span class="o">+</span> <span class="n">right_num</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="n">read_through_sum</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="c1"># &quot;Adding 1 + 2&quot;</span>
</span><span class='line'><span class="c1"># =&gt; 3</span>
</span><span class='line'>
</span><span class='line'><span class="n">read_through_sum</span><span class="o">[</span><span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span>
</span><span class='line'><span class="c1"># =&gt; 3</span>
</span></code></pre></td></tr></table></div></figure>


<p>The first lookup printed a message and returned a value but the second lookup did <em>not</em> print a value. This is because the block wasn&rsquo;t called. Instead, the cached value was returned immediately.</p>

<p>This approach was applied aggressively to <code>GraphQL::Schema::Warden</code>, an object which manages schema visibility on a query-by-query basis. Since the visibility of a schema member would remain constant during the query, we could cache the results of visibility checks: first <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/1a28b10494bf508519f8f9b4a1a589c458837cf7"><code>1a28b104</code></a>, then <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/27b36e89ca24b1dc8ec3e2d27612a6fb99039e54"><code>27b36e89</code></a>.</p>

<p>This was also applied to field lookup in <a href="https://github.com/rmosolgo/graphql-ruby/pull/402/commits/133ed1b1e0577df1db222a892d8afd95082c6d33"><code>133ed1b1e</code></a> and to <code>lazy_resolve</code> handler lookup in <a href="https://github.com/rmosolgo/graphql-ruby/pull/402/commits/283fc19d72eb9890ea6254f7fc79600f3f0bfbeb"><code>283fc19d</code></a>.</p>

<h2>Use <code>yield</code> Instead of <code>&amp;block</code></h2>

<p>Due to the implementation of Ruby&rsquo;s VM, calling a block with <a href="https://github.com/JuanitoFatas/fast-ruby#proccall-and-block-arguments-vs-yieldcode"><code>yield</code> is much faster than <code>block.call</code></a>. <code>@theorygeek</code> migrated <code>MiddlewareChain</code> to use that approach instead in <a href="https://github.com/rmosolgo/graphql-ruby/pull/462/commits/517cec3477097ddb05db0e02b6752be552d2e3dd"><code>517cec34</code></a>.</p>

<h2>Remove Overhead from Lazy Definition API (warning: terrible hack)</h2>

<p>In order to handle circular definitions, graphql-ruby&rsquo;s <code>.define { ... }</code> blocks aren&rsquo;t executed immediately. Instead, they&rsquo;re stored and evaluated only when a definition-dependent value is required. To achieve this, all definition-dependent methods were preceeded by a call to <code>ensure_defined</code>.</p>

<p>Maybe you remember that method from the <em>very top</em> of the profiler output above:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'> %self      total      self      wait     child     calls  name
</span><span class='line'>  4.60      0.074     0.022     0.000     0.052     6893  *Class#new
</span><span class='line'>  3.99      0.019     0.019     0.000     0.000     8715  *GraphQL::Define::InstanceDefinable#ensure_defined
</span></code></pre></td></tr></table></div></figure>


<p>A fact about <code>GraphQL::Schema</code> is that, by the time it is defined, <em>all</em> lazy definitions have been executed. This means that during query execution, calling <code>ensure_defined</code> is <em>always</em> a waste!</p>

<p>I found a way to remove the overhead, but it was a huge hack. It works like this:</p>

<p>When a definition is added (with <code>.define</code>):</p>

<ul>
<li>store the definition block for later</li>
<li><p>find each definition-dependent method definition on the defined object and gather them into an array:</p>

<pre><code class="ruby">@pending_methods = method_names.map { |n| self.class.instance_method(n) }
</code></pre></li>
<li><em>replace</em> those methods with dummy methods which:

<ul>
<li>call <code>ensure_defined</code></li>
<li>re-apply all <code>@pending_methods</code>, overriding the dummy methods</li>
<li>call the <em>real</em> method (which was just re-applied)</li>
</ul>
</li>
</ul>


<p>This way, subsequent calls to definition-dependent methods <em>don&rsquo;t</em> call <code>ensure_defined</code>. <code>ensure_defined</code> removed itself from the class definition after its work was done!</p>

<p>You can see the whole hack in <a href="https://github.com/rmosolgo/graphql-ruby/pull/483/commits/18d73a58314cab96c28a9861506b6ad18c8df3aa"><code>18d73a58</code></a>. For all my teasing, this is something that makes Ruby so powerful: if you can imagine it, you can code it!</p>

<h2>The Final Product</h2>

<p>Two minor releases later, the profile output is looking better! Here&rsquo;s the output on master:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='text'><span class='line'>Thread ID: 70178713115080
</span><span class='line'>Fiber ID: 70178720382840
</span><span class='line'>Total: 0.310395
</span><span class='line'>Sort by: self_time
</span><span class='line'>
</span><span class='line'> %self      total      self      wait     child     calls  name
</span><span class='line'>  4.06      0.013     0.013     0.000     0.000     7644   Kernel#hash
</span><span class='line'>  2.93      0.021     0.009     0.000     0.012     2917  *Class#new
</span><span class='line'>  2.89      0.009     0.009     0.000     0.000     4184   GraphQL::Query::Context::FieldResolutionContext#query
</span><span class='line'>  2.74      0.009     0.009     0.000     0.000    13542   Module#===
</span><span class='line'>  2.60      0.008     0.008     0.000     0.000     1960   GraphQL::Query::Context::FieldResolutionContext#initialize
</span><span class='line'>  2.27      0.013     0.007     0.000     0.006     1748   GraphQL::Query#arguments_for
</span><span class='line'>  2.25      0.010     0.007     0.000     0.003     7523   Kernel#===
</span><span class='line'>  2.14      0.022     0.007     0.000     0.015     1959   GraphQL::Query::Context::FieldResolutionContext#spawn
</span><span class='line'>  2.09      0.007     0.007     0.000     0.000     8260   Kernel#is_a?
</span><span class='line'>  1.87      0.039     0.006     0.000     0.033     1748   GraphQL::Schema::RescueMiddleware#call
</span><span class='line'>  1.75      0.013     0.005     0.000     0.008     1748   GraphQL::Execution::Lazy::LazyMethodMap#get
</span><span class='line'>  1.69      0.005     0.005     0.000     0.000     2259   Kernel#class
</span><span class='line'>  1.68      0.044     0.005     0.000     0.039     3496  *GraphQL::Schema::MiddlewareChain#invoke_core
</span><span class='line'>  1.33      0.004     0.004     0.000     0.000     1747   GraphQL::Query::Context::FieldResolutionContext#schema
</span><span class='line'>  1.31      0.029     0.004     0.000     0.025     1748   &lt;Module::GraphQL::Execution::Execute::FieldResolveStep&gt;#call
</span><span class='line'>  1.20      0.004     0.004     0.000     0.000     1748   GraphQL::Execution::SelectionResult#set
</span><span class='line'>  1.15      0.048     0.004     0.000     0.044     1748   GraphQL::Schema::MiddlewareChain#invoke
</span><span class='line'>  1.14      0.017     0.004     0.000     0.013     1748   GraphQL::Schema#lazy_method_name
</span><span class='line'>  1.07      0.004     0.003     0.000     0.001     1044   Kernel#public_send
</span><span class='line'>  1.05      0.020     0.003     0.000     0.017     1748   GraphQL::Schema#lazy?
</span><span class='line'>  1.02      0.004     0.003     0.000     0.000     1806   GraphQL::InternalRepresentation::Node#definition
</span></code></pre></td></tr></table></div></figure>


<p>Here are the wins:</p>

<ul>
<li>Object allocations reduced by 58%</li>
<li>Method calls to gem code and Ruby built-ins reduced by &hellip; a lot!</li>
<li>Calls to <code>ensure_defined</code> reduced by 100% 😆</li>
</ul>


<p>And, as shown in the benchmark above, 1.7x faster query execution!</p>

<p>There&rsquo;s one caveat: these optimization apply to the GraphQL runtime <em>only</em>. <em>Real</em> GraphQL performance depends on more than that. It includes application-specific details like database access, remote API calls and application code performance.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Parallelism in GraphQL-Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/01/22/parallelism-in-graphql-ruby/"/>
    <updated>2017-01-22T10:23:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/01/22/parallelism-in-graphql-ruby</id>
    <content type="html"><![CDATA[<p>It&rsquo;s possible to get IO operations running in parallel with the <a href="https://github.com/rmosolgo/graphql-ruby"><code>graphql</code> gem</a>.</p>

<!-- more -->


<p>I haven&rsquo;t tried this extensively, but I had to satisfy my curiosity!</p>

<h2>Setup: Long-Running IO</h2>

<p>Let&rsquo;s say we have a GraphQL schema which has long-running IO- or system-bound tasks. Here&rsquo;s a silly example where the long-running task is <code>sleep</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="no">QueryType</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:ObjectType</span><span class="o">.</span><span class="n">define</span> <span class="k">do</span>
</span><span class='line'>  <span class="nb">name</span> <span class="s2">&quot;Query&quot;</span>
</span><span class='line'>  <span class="n">field</span> <span class="ss">:sleep</span><span class="p">,</span> <span class="o">!</span><span class="n">types</span><span class="o">.</span><span class="n">Int</span><span class="p">,</span> <span class="s2">&quot;Sleep for the specified number of seconds&quot;</span> <span class="k">do</span>
</span><span class='line'>    <span class="n">argument</span> <span class="ss">:for</span><span class="p">,</span> <span class="o">!</span><span class="n">types</span><span class="o">.</span><span class="n">Int</span>
</span><span class='line'>    <span class="n">resolve</span> <span class="o">-&gt;</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="nb">sleep</span><span class="p">(</span><span class="n">a</span><span class="o">[</span><span class="s2">&quot;for&quot;</span><span class="o">]</span><span class="p">)</span>
</span><span class='line'>      <span class="n">a</span><span class="o">[</span><span class="s2">&quot;for&quot;</span><span class="o">]</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="no">Schema</span> <span class="o">=</span> <span class="ss">GraphQL</span><span class="p">:</span><span class="ss">:Schema</span><span class="o">.</span><span class="n">define</span> <span class="k">do</span>
</span><span class='line'>  <span class="n">query</span><span class="p">(</span><span class="no">QueryType</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Let&rsquo;s consider a query like this one:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">query_str</span> <span class="o">=</span> <span class="o">&lt;&lt;-</span><span class="no">GRAPHQL</span>
</span><span class='line'><span class="sh">{</span>
</span><span class='line'><span class="sh">  s1: sleep(for: 3)</span>
</span><span class='line'><span class="sh">  s2: sleep(for: 3)</span>
</span><span class='line'><span class="sh">  s3: sleep(for: 3)</span>
</span><span class='line'><span class="sh">}</span>
</span><span class='line'><span class="no">GRAPHQL</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="n">query_str</span>
</span><span class='line'>
</span><span class='line'><span class="nb">puts</span> <span class="no">Benchmark</span><span class="o">.</span><span class="n">measure</span> <span class="p">{</span>
</span><span class='line'>  <span class="no">Schema</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">query_str</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>How long will it take?</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="err">$</span> <span class="n">ruby</span> <span class="n">graphql_parallel</span><span class="o">.</span><span class="n">rb</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="ss">s1</span><span class="p">:</span> <span class="nb">sleep</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>  <span class="ss">s2</span><span class="p">:</span> <span class="nb">sleep</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'>  <span class="ss">s3</span><span class="p">:</span> <span class="nb">sleep</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="mi">3</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>  <span class="mi">0</span><span class="o">.</span><span class="mo">000000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">000000</span>   <span class="mi">0</span><span class="o">.</span><span class="mo">000000</span> <span class="p">(</span>  <span class="mi">9</span><span class="o">.</span><span class="mo">00</span><span class="mi">9428</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>About 9 seconds: three <code>sleep(3)</code> calls in a row.</p>

<h2>Working in Another Thread</h2>

<p>The <a href="https://github.com/ruby-concurrency/concurrent-ruby"><code>concurrent-ruby</code> gem</a> includes <code>Concurrent::Future</code>, which runs a block in another thread:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">future</span> <span class="o">=</span> <span class="ss">Concurrent</span><span class="p">:</span><span class="ss">:Future</span><span class="o">.</span><span class="n">execute</span> <span class="k">do</span>
</span><span class='line'>  <span class="c1"># This will be run in another thread</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="n">future</span><span class="o">.</span><span class="n">value</span>
</span><span class='line'><span class="c1"># =&gt; waits for the return value of the block</span>
</span><span class='line'><span class="c1">#    and returns it</span>
</span></code></pre></td></tr></table></div></figure>


<p>We can use it to put our <code>sleep(3)</code> calls in different threads. There are two steps.</p>

<p>First, use a <code>Concurrent::Future</code> in the resolve function:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'><span class="gd">- sleep(a[&quot;for&quot;])</span>
</span><span class='line'><span class="gd">- a[&quot;for&quot;]</span>
</span><span class='line'><span class="gi">+ Concurrent::Future.execute {</span>
</span><span class='line'><span class="gi">+  sleep(a[&quot;for&quot;])</span>
</span><span class='line'><span class="gi">+  a[&quot;for&quot;]</span>
</span><span class='line'><span class="gi">+ }</span>
</span></code></pre></td></tr></table></div></figure>


<p>Then, tell the Schema to handle <code>Concurrent::Future</code>s by calling <code>#value</code> on them:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'> Schema = GraphQL::Schema.define do
</span><span class='line'>   query(QueryType)
</span><span class='line'><span class="gi">+  lazy_resolve(Concurrent::Future, :value)</span>
</span><span class='line'> end
</span></code></pre></td></tr></table></div></figure>


<p>Finally, run the same query again:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='diff'><span class='line'>$ ruby graphql_parallel.rb
</span><span class='line'>{
</span><span class='line'>  s1: sleep(for: 3)
</span><span class='line'>  s2: sleep(for: 3)
</span><span class='line'>  s3: sleep(for: 3)
</span><span class='line'>}
</span><span class='line'>  0.000000   0.000000   0.010000 (  3.011735)
</span></code></pre></td></tr></table></div></figure>


<p>🎉 Three seconds! Since the <code>sleep(3)</code> calls were in different threads, they were executed in parallel.</p>

<h2>Real Uses</h2>

<p>Ruby can run IO operations in parallel. This includes filesystem operations and socket reads (eg, HTTP requests and database operations).</p>

<p>So, you could make external requests inside a <code>Concurrent::Future</code>, for example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">Concurrent</span><span class="p">:</span><span class="ss">:Future</span><span class="o">.</span><span class="n">execute</span> <span class="p">{</span>
</span><span class='line'>  <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;http://wikipedia.org&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Or, make a long-running database call inside a <code>Concurrent::Future</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="ss">Concurrent</span><span class="p">:</span><span class="ss">:Future</span><span class="o">.</span><span class="n">execute</span> <span class="p">{</span>
</span><span class='line'>  <span class="no">DB</span><span class="o">.</span><span class="n">exec</span><span class="p">(</span><span class="n">long_running_sql_query</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<h2>Caveats</h2>

<p>Switching threads incurs some overhead, so multithreading won&rsquo;t be worth it for very fast IO operations.</p>

<p>GraphQL doesn&rsquo;t know which resolvers will finish first. Instead, it starts each one, then blocks until the first one is finished. This means that subsequent long-running fields may have to wait longer than they &ldquo;really&rdquo; need to. For example, consider this query:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="p">{</span>
</span><span class='line'>  <span class="nb">sleep</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="mi">5</span><span class="p">)</span>
</span><span class='line'>  <span class="n">nestedSleep</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">sleep</span><span class="p">(</span><span class="k">for</span><span class="p">:</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>  <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>Even with multithreading, this would take about 7 seconds to execute. First, GraphQL would wait for <code>sleep(for: 5)</code>, then it would get to <code>nestedSleep(for: 2)</code>, which would have already finished, then it would execute <code>sleep(for: 2)</code>.</p>

<h2>Conclusion</h2>

<p>If your GraphQL schema is wrapping pre-existing HTTP APIs, using a technique like this could reduce your GraphQL response time.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Introducing GraphQL::Pro]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/01/09/introducing-graphql-pro/"/>
    <updated>2017-01-09T09:47:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/01/09/introducing-graphql-pro</id>
    <content type="html"><![CDATA[<p><code>graphql-ruby</code> is almost two years old! Today, I&rsquo;m adding a new element to the project, <a href="http://graphql.pro"><code>GraphQL::Pro</code></a>.</p>

<!-- more -->


<p>I have three goals with <code>GraphQL::Pro</code>:</p>

<ol>
<li>Provide robust, easy-to-use integrations with third-party tools</li>
<li>Open a formal feedback loop with teams using GraphQL</li>
<li>Prevent open-source burnout</li>
</ol>


<p>Additionally, I&rsquo;m starting a <a href="http://tinyletter.com/graphql-ruby">GraphQL Ruby newsletter</a>.</p>

<h2>Integrations</h2>

<p>Today, <code>GraphQL::Pro</code> provides some integrations with third-party tools:</p>

<ul>
<li><a href="http://rmosolgo.github.io/graphql-ruby/pro/authorization">Authorization plugins</a> for Pundit and CanCan (or custom auth)</li>
<li>Improved <a href="http://rmosolgo.github.io/graphql-ruby/pro/cursors">connections for ActiveRecord</a></li>
<li><a href="http://rmosolgo.github.io/graphql-ruby/pro/monitoring">Instrumentation for app monitoring</a> platforms (New Relic, Scout and Skylight).</li>
</ul>


<p>As time goes on, I&rsquo;ll keep an eye out for other integrations that could be included in <code>GraphQL::Pro</code>. (If you have a suggestion, I&rsquo;d love to hear it!)</p>

<h2>Feedback Loop</h2>

<p>Some teams adopt GraphQL as a foundational element of their application. I&rsquo;d like to provide them service (and peace of mind) as they build on that investment. <code>GraphQL::Pro</code> customers have my ear for any performance issues, bugs or feature requests. They also have an assurance that I&rsquo;ll continue to maintain and improve <code>graphql-ruby</code>.</p>

<h2>Prevent Burnout</h2>

<p>I really enjoy working on <code>graphql-ruby</code> and I&rsquo;m excited about the work to be done in 2017. But it&rsquo;s no secret that open-source work can become an unrewarding, thankless grind. Charging money for <code>GraphQL::Pro</code> provides me with a simple, concrete &ldquo;reward&rdquo; to continue the work. I hope this will be good for me, for the project, and for others who are invested in the project.</p>

<h2>Buying GraphQL::Pro</h2>

<p>If any of this sounds good to you, you can buy <code>GraphQL::Pro</code> at <a href="http://graphql.pro">http://graphql.pro</a> !</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raising Exceptions is Bad]]></title>
    <link href="http://rmosolgo.github.io/blog/2016/11/23/raising-exceptions-is-bad/"/>
    <updated>2016-11-23T10:34:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2016/11/23/raising-exceptions-is-bad</id>
    <content type="html"><![CDATA[<p>In general, <a href="http://wiki.c2.com/?DontUseExceptionsForFlowControl">raising exceptions for control flow</a> makes code hard to understand. However, there are other cases when an exception is the right choice.</p>

<!-- more -->


<h2>Raise vs Return</h2>

<p><code>raise</code> is <code>return</code>&rsquo;s evil twin.</p>

<p>They <strong>both</strong> stop the execution of the current method. After a <code>return</code>, nothing else is executed. After a <code>raise</code>, nothing else is executed &hellip; <em>maybe</em>. The method may have a <code>rescue</code> or <code>ensure</code> clause which is executed after the <code>raise</code>, so a reader must check for those.</p>

<p>They <strong>both</strong> change flow of control. <code>return</code> gives control back to the caller. <code>raise</code> may give control <em>anywhere</em> on the call stack, depending on the specific error and <code>rescue</code> clauses. If all you see is a <code>raise</code>, you can&rsquo;t guess where it will be rescued!</p>

<p>They <strong>both</strong> send values to their new destination. <code>return</code> provides the given value to the caller, who may capture the return value in a local variable. <code>raise</code> provides the error object to the <code>rescue</code>-er. <code>return</code> can send any kind of value, but <code>raise</code> can only send error objects.</p>

<p>They <strong>both</strong> create coupling across call stack frames. <code>return</code> couples two adjacent call stack frames: caller depends on the return value. <code>raise</code> → <code>rescue</code> couples far-removed stack frames: they may be adjacent, or they may be several frames removed from one another.</p>

<h2>Raise → Rescue is Unpredictable</h2>

<p>Sending values through a program by calling methods and <code>return</code>-ing values is very predictable. If you return a different value, the caller will get a different value. To see where return values &ldquo;go&rdquo;, simply search for calls to that method.</p>

<p>Finding where <code>raise</code>&rsquo;d errors go is a bit more challenging. For example, this change:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># From:</span>
</span><span class='line'><span class="k">def</span> <span class="nf">do_something</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'>  <span class="k">raise</span> <span class="s2">&quot;Something went wrong&quot;</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># To:</span>
</span><span class='line'><span class="k">class</span> <span class="nc">MyCustomError</span> <span class="o">&lt;</span> <span class="no">StandardError</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">def</span> <span class="nf">do_something</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'>  <span class="k">raise</span> <span class="no">MyCustomError</span><span class="p">,</span> <span class="s2">&quot;Oops!&quot;</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>How can you tell if this is a safe refactor? Here are some considerations:</p>

<ul>
<li>Instead of looking for callers of this method, you have to find <em>entire call stacks</em> which include this method, since any upstream calls may also have expectations about this error.</li>
<li>When searching for <code>rescue</code>s, you have to keep the error&rsquo;s ancestry in mind, finding bare <code>rescue</code>s, superclass-tagged <code>rescue</code>s and class-tagged <code>rescue</code>s.</li>
<li>Some <code>rescue</code>s may <em>consume</em> the error object itself. For example, they may read its <code>#message</code> or other attached data. If you change any properties of the error object, you may break the assumptions of those <code>rescue</code>s.</li>
<li>If you find that the new error will be <code>rescue</code>&rsquo;d differently, you must also consider how execution flow will change in other methods. For example, some methods may be cut short because previously-<code>rescue</code>&rsquo;d errors now propagate through them. Other methods which <em>used</em> to be cut short may now continue running, since errors are rescued in child method calls.</li>
</ul>


<p>If your <code>raise</code> is located in a Ruby gem, these problems are even harder, because <code>rescue</code> clauses may exist in your users&#8217; code.</p>

<p>If your error patterns are well documented, <code>༼ つ ◕_◕ ༽つ 🏆</code>. Bravo, just don&rsquo;t break your public API. Users might still make assumptions <em>beyond</em> the documentation, such as error ancestry or message values. Additionally, they could be monkey-patching library methods and applying <code>rescue</code>-related assumptions to those patches.</p>

<p>If your error patterns aren&rsquo;t documented, <code>💩 ノ༼ ◕_◕ ノ ༽</code>. You have no idea what assumptions users make about those errors! You can&rsquo;t be sure your changes won&rsquo;t break their code.</p>

<h2>Use Return Instead</h2>

<p><code>raise</code> can be replaced by <code>return</code>. However, if you&rsquo;re using <code>raise</code> to traverse many levels of the call stack, the refactor will be intense. Take heart: previously you were hacking your way back up the call stack, now you&rsquo;re creating a predictable, explicit flow through your program!</p>

<p>It&rsquo;s worth repeating, <a href="http://wiki.c2.com/?DontUseExceptionsForFlowControl">don&rsquo;t use exceptions for flow control</a>.</p>

<p>Here are some techniques for expressing failures with <code>return</code>.</p>

<ul>
<li><strong>Return errors</strong> instead of raising them. Ruby errors are objects, like everything else. You can return them to the caller and let the caller check whether the returned value is an error or not.  For example, to return an error:</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">def</span> <span class="nf">do_something</span>
</span><span class='line'>  <span class="n">calculation</span> <span class="o">=</span> <span class="no">SomeCalculation</span><span class="o">.</span><span class="n">new</span> <span class="c1"># ...</span>
</span><span class='line'>
</span><span class='line'>  <span class="k">if</span> <span class="n">calculation</span><span class="o">.</span><span class="n">something_went_wrong?</span>
</span><span class='line'>    <span class="c1"># Let the caller handle this error</span>
</span><span class='line'>    <span class="no">MyCustomError</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="s2">&quot;oops!&quot;</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="c1"># Return the result to the caller</span>
</span><span class='line'>    <span class="n">calculation</span><span class="o">.</span><span class="n">result</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><strong>Use success and failure objects</strong>. Instead of returning a raw <code>StandardError</code> instance to the caller, use a <code>Failure</code> class to communicate failure. Additionally, use a <code>Success</code> class to communicate success. (This is similar to the &ldquo;monad&rdquo; technique, eg <a href="http://dry-rb.org/gems/dry-monads/"><code>dry-monads</code> gem</a>.)</li>
</ul>


<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="k">class</span> <span class="nc">ConvertSuccess</span>
</span><span class='line'>  <span class="kp">attr_reader</span> <span class="ss">:old_file</span><span class="p">,</span> <span class="ss">:new_file</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">old_file</span><span class="p">:,</span> <span class="n">new_file</span><span class="p">:)</span>
</span><span class='line'>    <span class="c1"># ...</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="k">class</span> <span class="nc">ConvertFailure</span>
</span><span class='line'>  <span class="kp">attr_reader</span> <span class="ss">:old_file</span><span class="p">,</span> <span class="ss">:error</span>
</span><span class='line'>  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">old_file</span><span class="p">:,</span> <span class="ss">error</span><span class="p">:)</span>
</span><span class='line'>    <span class="c1"># ...</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Try to convert this file, returning either a</span>
</span><span class='line'><span class="c1"># ConvertSuccess or ConvertFailure)</span>
</span><span class='line'><span class="k">def</span> <span class="nf">convert_file</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># ...</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">error_message</span><span class="o">.</span><span class="n">nil?</span>
</span><span class='line'>    <span class="no">ConvertSuccess</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">old_file</span><span class="p">:</span> <span class="n">file</span><span class="p">,</span> <span class="n">new_file</span><span class="p">:</span> <span class="n">converted_file</span><span class="p">)</span>
</span><span class='line'>  <span class="k">else</span>
</span><span class='line'>    <span class="no">ConvertFailure</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">old_file</span><span class="p">:</span> <span class="n">file</span><span class="p">,</span> <span class="ss">error</span><span class="p">:</span> <span class="n">error_message</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">end</span>
</span><span class='line'>
</span><span class='line'><span class="c1"># Try to convert a file,</span>
</span><span class='line'><span class="c1"># then specify behavior</span>
</span><span class='line'><span class="c1"># for failure case &amp; success case:</span>
</span><span class='line'><span class="n">conversion</span> <span class="o">=</span> <span class="n">convert_file</span><span class="p">(</span><span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>
</span><span class='line'>
</span><span class='line'><span class="k">case</span> <span class="n">conversion</span>
</span><span class='line'><span class="k">when</span> <span class="no">ConvertSuccess</span>
</span><span class='line'>  <span class="c1"># Do something with the new file</span>
</span><span class='line'><span class="k">when</span> <span class="no">ConvertFailure</span>
</span><span class='line'>  <span class="c1"># Notify the user of the failure</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<ul>
<li><p>As a last resort, <strong>return <code>nil</code></strong>. Using <code>nil</code> as an expression of failure has some downsides:</p>

<ul>
<li><code>nil</code> can&rsquo;t hold a message or any extra data</li>
<li>sometimes, <code>nil</code> is a valid value</li>
</ul>


<p>But, for simple operations, using <code>nil</code> may be sufficient. Since it will be communicated via <code>return</code>, refactoring it will be straightforward in the future!</p></li>
</ul>


<h2>Sometimes, Raise is Okay</h2>

<p><code>raise</code> has its purposes.</p>

<p><code>raise</code> is a great way to signal that the program has reached a completely unexpected state and that it should exit. For example, in the <code>convert_file</code> example above, we could use <code>raise</code> to assert that we don&rsquo;t receive an unexpected value from <code>convert_file</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="n">conversion</span> <span class="o">=</span> <span class="n">convert_file</span><span class="p">(</span><span class="no">File</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_path</span><span class="p">))</span>
</span><span class='line'><span class="k">case</span> <span class="n">conversion</span>
</span><span class='line'><span class="k">when</span> <span class="no">ConvertSuccess</span>
</span><span class='line'>  <span class="c1"># Do something with the new file</span>
</span><span class='line'><span class="k">when</span> <span class="no">ConvertFailure</span>
</span><span class='line'>  <span class="c1"># Notify the user of the failure</span>
</span><span class='line'><span class="k">else</span>
</span><span class='line'>  <span class="k">raise</span><span class="p">(</span><span class="s2">&quot;convert_file didn&#39;t return a ConvertSuccess or ConvertFailure, it returned: </span><span class="si">#{</span><span class="n">conversion</span><span class="o">.</span><span class="n">inspect</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>Now, if the method ever returns some unexpected value, we&rsquo;ll receive a loud failure. Some people use <code>fail</code> in this case, which is also fine. However, the need to disambiguate <code>raise</code> and <code>fail</code> is a code smell: stop using <code>raise</code> for non-emergencies!</p>

<p><code>raise</code> is also helpful for re-raising other errors. For example, if your library needs to log something when an error happens, it might need to capture the error, then re-raise it. For example:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='ruby'><span class='line'><span class="c1"># This method yields to a user-provided block, eg</span>
</span><span class='line'><span class="c1"># `handle_converted_file(old_file) { |f| push_to_s3(f) }`</span>
</span><span class='line'><span class="k">def</span> <span class="nf">handle_converted_file</span><span class="p">(</span><span class="n">old_file</span><span class="p">)</span>
</span><span class='line'>  <span class="n">conversion</span> <span class="o">=</span> <span class="n">convert_file</span><span class="p">(</span><span class="n">old_file</span><span class="p">)</span>
</span><span class='line'>  <span class="k">if</span> <span class="n">conversion</span><span class="o">.</span><span class="n">is_a?</span><span class="p">(</span><span class="no">ConvertSuccess</span><span class="p">)</span>
</span><span class='line'>    <span class="k">yield</span><span class="p">(</span><span class="n">conversion</span><span class="o">.</span><span class="n">new_file</span><span class="p">)</span>
</span><span class='line'>  <span class="k">end</span>
</span><span class='line'><span class="k">rescue</span> <span class="no">StandardError</span> <span class="o">=&gt;</span> <span class="n">err</span>
</span><span class='line'>  <span class="c1"># Make a log entry for the library:</span>
</span><span class='line'>  <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;User error from handle_converted_file&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
</span><span class='line'>  <span class="c1"># Let the user handle this error:</span>
</span><span class='line'>  <span class="k">raise</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
</span><span class='line'><span class="k">end</span>
</span></code></pre></td></tr></table></div></figure>


<p>This way, you can respond to the error without disrupting user code.</p>

<h2>raise SharpKnifeError</h2>

<p>In my own work, I&rsquo;m transitioning <em>away</em> from raising errors and <em>towards</em> communicating failure by return values. This pattern is ubiquitous in languages like Go and Elixir. In Node.js, callbacks communicate errors in a similar way (callback arguments). I think Ruby code can benefit from this practice as well.</p>
]]></content>
  </entry>
  
</feed>
