<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Programming | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/programming/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2020-07-27T16:05:47-04:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Ruby Type Checking Roundup]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/10/06/ruby-type-checking-roundup/"/>
    <updated>2017-10-06T09:00:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/10/06/ruby-type-checking-roundup</id>
    <content type="html"><![CDATA[<p>This fall, several people presented their work on Ruby type checkers. So let&rsquo;s take a look: what&rsquo;s the big deal, and what have they been up to?</p>

<!-- more -->


<h2>Why Type Check?</h2>

<p>Part of Ruby&rsquo;s appeal is to be <em>free</em> of the cruft of its predecessors. So why is there so much interest in <em>adding</em> types to Ruby?</p>

<ul>
<li>Large, sprawling projects are becoming more common. At Ruby&rsquo;s inception, there were no 10-year-old Rails apps which people struggled to maintain, only greenfield Ruby scripts for toy projects.</li>
<li>Programmers have experienced excellent type systems in other languages, and want those benefits in Ruby.</li>
<li><em>Optional</em>, gradual type systems have been introduced to Python and JavaScript and they&rsquo;re big successes.</li>
</ul>


<p>What are the benefits?</p>

<ul>
<li><strong>Correctness</strong>: Type checking, like testing, is a way to be confident that your codebase is functioning properly. Employing a type checker can help you find bugs during development and prevent those bugs from going to production.</li>
<li><strong>Confidence</strong>: Since an incorrect program won&rsquo;t pass type checking, developers can refactor with more confidence. Common errors such as typos and argument errors can be caught by the type checker.</li>
<li><strong>Design</strong>: The type system gives you a way to think about the program. Specifically, types document and define the <em>boundaries</em> between parts of code, like methods, classes and modules.</li>
</ul>


<p>To experience a great type system in a Ruby-like language, I recommend <a href="https://crystal-lang.org/">Crystal</a>.</p>

<h2>Jeff Foster, StrangeLoop 2017</h2>

<p><a href="http://www.cs.umd.edu/~jfoster/">Jeff Foster</a> is a professor at the <a href="http://www.umd.edu/">University of Maryland, College Park</a> and works in the <a href="http://www.cs.umd.edu/projects/PL/">programming languages group</a>. Along with his students, he&rsquo;s been exploring Ruby type checkers for <strong>nine years</strong>! This year, he gave a presentation at StrangeLoop, <a href="https://www.youtube.com/watch?v=buY54I7mEjA">Type Checking Ruby</a>.</p>

<p>He described his various avenues of research over the years, and how they influenced one another, leading to a final question:</p>

<pre><code class="ruby">class Talk &lt; ActiveRecord::Base
  belongs_to :owner, class_name: "User"

  def owner?(other_user)
    # QUESTION
    # How to know the type of `#owner` method at this point?
    owner == other_user
  end
end
</code></pre>

<p>His early work revolved around <em>static</em> type checking: annotations in the source code were given to a type checker, which used those annotations to assert that the Ruby code was correct.</p>

<p>This approach had a fundamental limitation: how can dynamically-created methods (like <code>Talk#owner</code> above) be statically annotated?</p>

<p>This drove him and his team to develop <a href="https://github.com/plum-umd/rdl">RDL</a>, a <em>dynamic</em> type checker. In RDL, types are declared using <em>methods</em> instead of annotations, for example:</p>

<pre><code class="ruby">type '(Integer, Integer) -&gt; Integer'
def multiply(x, y)
  x * y
end
</code></pre>

<p>By using methods, it handles metaprogramming in a straightforward way. It hooks into Rails' <code>.belongs_to</code> and adds annotations for the generated methods, for example:</p>

<pre><code class="ruby"># Rails' belongs_to method
def belongs_to(name, options = {})
  # ...
  # define a reader method, like `Talk#owner` above
  type "() -&gt; #{class_name}"
  define_method(name) do
    # ...
  end
end
</code></pre>

<p>(In reality, RDL uses <a href="https://github.com/plum-umd/rdl#preconditions-and-postconditions">conditions</a>, not monkey-patching, to achieve this.)</p>

<p>In this approach, type information is <em>gathered while the program runs</em>, but the typecheck is deferred until the method is called. At that point, RDL checks the source code (static information) using the runtime data (dynamic information). For this reason, RDL is called &ldquo;Just-in-Time Static Type Checking.&rdquo;</p>

<p>You can learn more about RDL in several places:</p>

<ul>
<li>RDL on GitHub: <a href="https://github.com/plum-umd/rdl">https://github.com/plum-umd/rdl</a></li>
<li>StrangeLoop 2017 talk: <a href="https://www.youtube.com/watch?v=buY54I7mEjA">https://www.youtube.com/watch?v=buY54I7mEjA</a></li>
<li>Academic papers from the folks behind RDL: <a href="https://github.com/plum-umd/rdl#bibliography">https://github.com/plum-umd/rdl#bibliography</a></li>
</ul>


<p>Personally, I can&rsquo;t wait to take RDL for a try. At the conference, Jeff mentioned that <em>type inference</em> was on his radar. That would take RDL to the next level!</p>

<p>Not to read into it too far, but it looks like <a href="https://github.com/plum-umd/rdl/issues/40#issuecomment-329135921">Stripe is exploring RDL</a> 😎.</p>

<h2>Soutaro Matsumoto, RubyKaigi 2017</h2>

<p>Soutaro Matsumoto also has significant academic experience with type checking Ruby, and this year, he presented some of his work at RubyKaigi in <a href="https://youtu.be/JExXdUux024">Type Checking Ruby Programs with Annotations</a>.</p>

<p>He begins with an overview of type checking Ruby, and surveys the previous work in type inference. He also points out how requirements should be relaxed for Ruby:</p>

<ul>
<li><strong><del>Correctness</del> -> Forget correctness</strong> (Allow a mix of typed and untyped code, so that developers can work quickly when they don&rsquo;t want or need types.)</li>
<li><strong><del>Static</del> -> Defer type checking to runtime</strong> (He mentions RDL in this context)</li>
<li><strong><del>No annotations</del> -> Let programmers write types</strong> (<em>Completely</em> inferring types is not possible, so accept some hints from the developers.)</li>
</ul>


<p>Then, he introduces his recent project, <a href="https://github.com/soutaro/steep">Steep</a>.</p>

<p>Steep&rsquo;s approach is familiar, but new to Ruby. It has three steps:</p>

<ul>
<li>Write a <code>.rbi</code> file which describes the types in your program, using a special type language, for example:</li>
</ul>


<pre><code class="ruby">class Talk {
  def owner: (User) -&gt; _Boolean
}
</code></pre>

<ul>
<li>Add annotations to your Ruby code to connect it to your types:</li>
</ul>


<pre><code class="ruby">class Talk &lt; ActiveRecord::Base
  belongs_to :owner, class_name: "User"
  # @dynamic owner
end
</code></pre>

<p>  Some connections between Ruby source and the <code>.rbi</code> files can be made automatically; others require explicit annotations.</p>

<ul>
<li><p>Run the type checker:</p>

<pre><code>$ steep check app/models/talk.rb
</code></pre></li>
</ul>


<p>It reminds me a bit of the <code>.h</code>/<code>.c</code> files in a C project.</p>

<p>Soutaro is also presenting his work at <a href="http://rubyconf.org/program#session-233">this winter&rsquo;s RubyConf</a>.</p>

<h2>Valentin Fondaratov, RubyKaigi 2017</h2>

<p>Valentin works at JetBrains (creators of <a href="https://www.jetbrains.com/ruby/">RubyMine</a>) and presented his work on type-checking based on <em>runtime</em> data. His presentation, <a href="https://www.youtube.com/watch?v=JS6m2gke0Ic">Automated Type Contracts Generation for Ruby</a>, was really fascinating and offered a promising glimpse of what a Ruby type ecosystem could be.</p>

<p>Valentin started by covering RubyMine&rsquo;s current type checking system:</p>

<ul>
<li>RubyMine tries to resolve identifiers (eg, method names, constant names) to their implementations</li>
<li>But this is hard: given <code>obj.execute</code>, what method does it call?</li>
<li>Developers can provide hints with YARD documentation</li>
<li>RubyMine uses this to support autocomplete, error prediction, and rename refactorings</li>
</ul>


<p>He also pointed out that even code coverage is not enough: 100% code coverage does <em>not</em> guarantee that all <em>possible</em> codepaths were run. For example, any composition of <code>if</code> branches require a cross-product of codepaths, not only that each line is executed once. Besides that, code coverage does <em>not</em> analyze the coverage of your dependencies' code (ie, RubyGems).</p>

<p>So, Valentin suggests getting <em>more</em> from our unit tests: what if we <em>observed</em> the running program, and kept notes about what values were passed around and how they were used? In this arrangement, that <em>runtime</em> data could be accumulated, then used for type checking.</p>

<p>Impressively, he introduced the implementation of this, first using a <a href="ruby-doc.org/core-2.4.0/TracePoint.html">TracePoint</a>, then digging into the Ruby VM to get even more granular data.</p>

<p>However, the gathered data can be very complicated. For example, how can we understand the input type of <code>String#split</code>?</p>

<pre><code class="ruby"># A lot of type checking data generated at runtime:
# call                                # Input type
"1,2,,3,4,,".split(",")               # (String, nil)
# =&gt; ["1", "2", "", "3", "4"]
"1,2,,3,4,,".split(",", 4)            # (String, Integer)
# =&gt; ["1", "2", "", "3,4,,"]
"1,2,,3,4,,".split(",", -4)           # (String, Integer)
# =&gt; ["1", "2", "", "3", "4", "", ""]
"1,2,,3,4,,".split(/\d/)              # (Regexp, nil)
# =&gt; ["", ",", ",,", ",", ",,"]
# ...
</code></pre>

<p>Valentin showed how a classic technique, finite automata, can be used to reduce this information to a useful data structure.</p>

<p>Then, this runtime data can be used to <em>generate</em> type annotations (as YARD docs).</p>

<p>Finally, he imagines a type ecosystem for Ruby:</p>

<ul>
<li>Users contribute their (anonymized) runtime information for their RubyGem depenedencies</li>
<li>This data is pooled into a shared database, merged by RubyGem &amp; version</li>
<li>Users can draw type data <em>from</em> the shared database</li>
</ul>


<p>Personally, I think this is a great future to pursue:</p>

<ul>
<li>Developers can <em>gain</em> type checking without any annotations</li>
<li>Annotations can become very robust because resources are shared</li>
<li><em>Real</em> 100% coverage is possible via community collaboration</li>
</ul>


<p>You can see the project on GitHub: <a href="https://github.com/JetBrains/ruby-type-inference">https://github.com/JetBrains/ruby-type-inference</a></p>

<h2>Summary</h2>

<p>There&rsquo;s a lot of technically-savvy and academically-informed work on type checking Ruby! Many of the techniques preserve Ruby&rsquo;s productivity and dynamism while improving the developer experience and confidence. What makes them unique is their use of <em>runtime</em> data, to observe the program in action, then make assertions about the source code.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Raising Exceptions is Bad]]></title>
    <link href="http://rmosolgo.github.io/blog/2016/11/23/raising-exceptions-is-bad/"/>
    <updated>2016-11-23T10:34:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2016/11/23/raising-exceptions-is-bad</id>
    <content type="html"><![CDATA[<p>In general, <a href="http://wiki.c2.com/?DontUseExceptionsForFlowControl">raising exceptions for control flow</a> makes code hard to understand. However, there are other cases when an exception is the right choice.</p>

<!-- more -->


<h2>Raise vs Return</h2>

<p><code>raise</code> is <code>return</code>&rsquo;s evil twin.</p>

<p>They <strong>both</strong> stop the execution of the current method. After a <code>return</code>, nothing else is executed. After a <code>raise</code>, nothing else is executed &hellip; <em>maybe</em>. The method may have a <code>rescue</code> or <code>ensure</code> clause which is executed after the <code>raise</code>, so a reader must check for those.</p>

<p>They <strong>both</strong> change flow of control. <code>return</code> gives control back to the caller. <code>raise</code> may give control <em>anywhere</em> on the call stack, depending on the specific error and <code>rescue</code> clauses. If all you see is a <code>raise</code>, you can&rsquo;t guess where it will be rescued!</p>

<p>They <strong>both</strong> send values to their new destination. <code>return</code> provides the given value to the caller, who may capture the return value in a local variable. <code>raise</code> provides the error object to the <code>rescue</code>-er. <code>return</code> can send any kind of value, but <code>raise</code> can only send error objects.</p>

<p>They <strong>both</strong> create coupling across call stack frames. <code>return</code> couples two adjacent call stack frames: caller depends on the return value. <code>raise</code> → <code>rescue</code> couples far-removed stack frames: they may be adjacent, or they may be several frames removed from one another.</p>

<h2>Raise → Rescue is Unpredictable</h2>

<p>Sending values through a program by calling methods and <code>return</code>-ing values is very predictable. If you return a different value, the caller will get a different value. To see where return values &ldquo;go&rdquo;, simply search for calls to that method.</p>

<p>Finding where <code>raise</code>&rsquo;d errors go is a bit more challenging. For example, this change:</p>

<pre><code class="ruby"># From:
def do_something
  # ...
  raise "Something went wrong"
end

# To:
class MyCustomError &lt; StandardError
end

def do_something
  # ...
  raise MyCustomError, "Oops!"
end
</code></pre>

<p>How can you tell if this is a safe refactor? Here are some considerations:</p>

<ul>
<li>Instead of looking for callers of this method, you have to find <em>entire call stacks</em> which include this method, since any upstream calls may also have expectations about this error.</li>
<li>When searching for <code>rescue</code>s, you have to keep the error&rsquo;s ancestry in mind, finding bare <code>rescue</code>s, superclass-tagged <code>rescue</code>s and class-tagged <code>rescue</code>s.</li>
<li>Some <code>rescue</code>s may <em>consume</em> the error object itself. For example, they may read its <code>#message</code> or other attached data. If you change any properties of the error object, you may break the assumptions of those <code>rescue</code>s.</li>
<li>If you find that the new error will be <code>rescue</code>&rsquo;d differently, you must also consider how execution flow will change in other methods. For example, some methods may be cut short because previously-<code>rescue</code>&rsquo;d errors now propagate through them. Other methods which <em>used</em> to be cut short may now continue running, since errors are rescued in child method calls.</li>
</ul>


<p>If your <code>raise</code> is located in a Ruby gem, these problems are even harder, because <code>rescue</code> clauses may exist in your users' code.</p>

<p>If your error patterns are well documented, <code>༼ つ ◕_◕ ༽つ 🏆</code>. Bravo, just don&rsquo;t break your public API. Users might still make assumptions <em>beyond</em> the documentation, such as error ancestry or message values. Additionally, they could be monkey-patching library methods and applying <code>rescue</code>-related assumptions to those patches.</p>

<p>If your error patterns aren&rsquo;t documented, <code>💩 ノ༼ ◕_◕ ノ ༽</code>. You have no idea what assumptions users make about those errors! You can&rsquo;t be sure your changes won&rsquo;t break their code.</p>

<h2>Use Return Instead</h2>

<p><code>raise</code> can be replaced by <code>return</code>. However, if you&rsquo;re using <code>raise</code> to traverse many levels of the call stack, the refactor will be intense. Take heart: previously you were hacking your way back up the call stack, now you&rsquo;re creating a predictable, explicit flow through your program!</p>

<p>It&rsquo;s worth repeating, <a href="http://wiki.c2.com/?DontUseExceptionsForFlowControl">don&rsquo;t use exceptions for flow control</a>.</p>

<p>Here are some techniques for expressing failures with <code>return</code>.</p>

<ul>
<li><strong>Return errors</strong> instead of raising them. Ruby errors are objects, like everything else. You can return them to the caller and let the caller check whether the returned value is an error or not.  For example, to return an error:</li>
</ul>


<pre><code class="ruby">def do_something
  calculation = SomeCalculation.new # ...

  if calculation.something_went_wrong?  
    # Let the caller handle this error
    MyCustomError.new("oops!")
  else
    # Return the result to the caller
    calculation.result
  end
end
</code></pre>

<ul>
<li><strong>Use success and failure objects</strong>. Instead of returning a raw <code>StandardError</code> instance to the caller, use a <code>Failure</code> class to communicate failure. Additionally, use a <code>Success</code> class to communicate success. (This is similar to the &ldquo;monad&rdquo; technique, eg <a href="http://dry-rb.org/gems/dry-monads/"><code>dry-monads</code> gem</a>.)</li>
</ul>


<pre><code class="ruby">class ConvertSuccess
  attr_reader :old_file, :new_file
  def initialize(old_file:, new_file:)
    # ...
  end
end

class ConvertFailure
  attr_reader :old_file, :error
  def initialize(old_file:, error:)
    # ...
  end
end

# Try to convert this file, returning either a
# ConvertSuccess or ConvertFailure)
def convert_file(file)
  # ...
  if error_message.nil?
    ConvertSuccess.new(old_file: file, new_file: converted_file)
  else
    ConvertFailure.new(old_file: file, error: error_message)
  end
end

# Try to convert a file,
# then specify behavior
# for failure case &amp; success case:
conversion = convert_file(File.read(file_path))

case conversion
when ConvertSuccess
  # Do something with the new file
when ConvertFailure
  # Notify the user of the failure
end   
</code></pre>

<ul>
<li><p>As a last resort, <strong>return <code>nil</code></strong>. Using <code>nil</code> as an expression of failure has some downsides:</p>

<ul>
<li><code>nil</code> can&rsquo;t hold a message or any extra data</li>
<li>sometimes, <code>nil</code> is a valid value</li>
</ul>


<p>But, for simple operations, using <code>nil</code> may be sufficient. Since it will be communicated via <code>return</code>, refactoring it will be straightforward in the future!</p></li>
</ul>


<h2>Sometimes, Raise is Okay</h2>

<p><code>raise</code> has its purposes.</p>

<p><code>raise</code> is a great way to signal that the program has reached a completely unexpected state and that it should exit. For example, in the <code>convert_file</code> example above, we could use <code>raise</code> to assert that we don&rsquo;t receive an unexpected value from <code>convert_file</code>:</p>

<pre><code class="ruby">conversion = convert_file(File.read(file_path))
case conversion
when ConvertSuccess
  # Do something with the new file
when ConvertFailure
  # Notify the user of the failure
else
  raise("convert_file didn't return a ConvertSuccess or ConvertFailure, it returned: #{conversion.inspect}")
end   
</code></pre>

<p>Now, if the method ever returns some unexpected value, we&rsquo;ll receive a loud failure. Some people use <code>fail</code> in this case, which is also fine. However, the need to disambiguate <code>raise</code> and <code>fail</code> is a code smell: stop using <code>raise</code> for non-emergencies!</p>

<p><code>raise</code> is also helpful for re-raising other errors. For example, if your library needs to log something when an error happens, it might need to capture the error, then re-raise it. For example:</p>

<pre><code class="ruby"># This method yields to a user-provided block, eg
# `handle_converted_file(old_file) { |f| push_to_s3(f) }`
def handle_converted_file(old_file)
  conversion = convert_file(old_file)
  if conversion.is_a?(ConvertSuccess)
    yield(conversion.new_file)
  end
rescue StandardError =&gt; err
  # Make a log entry for the library:
  logger.log("User error from handle_converted_file", err)
  # Let the user handle this error:
  raise(err)
end
</code></pre>

<p>This way, you can respond to the error without disrupting user code.</p>

<h2>raise SharpKnifeError</h2>

<p>In my own work, I&rsquo;m transitioning <em>away</em> from raising errors and <em>towards</em> communicating failure by return values. This pattern is ubiquitous in languages like Go and Elixir. In Node.js, callbacks communicate errors in a similar way (callback arguments). I think Ruby code can benefit from this practice as well.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Ruby Class, meet Elixir Module]]></title>
    <link href="http://rmosolgo.github.io/blog/2016/05/01/ruby-class-meet-elixir-module/"/>
    <updated>2016-05-01T11:10:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2016/05/01/ruby-class-meet-elixir-module</id>
    <content type="html"><![CDATA[<p>Elixir modules offer some valuable insight into designing Ruby classes.</p>

<!-- more -->


<p>Ruby classes combine <em>data</em> and <em>behavior</em> in a typically object-oriented way:</p>

<ul>
<li><strong>data:</strong> instances of the class hold state in instance variables</li>
<li><strong>behavior:</strong> methods on the class alter state.</li>
</ul>


<p>Elixir modules also combine data and behavior:</p>

<ul>
<li><strong>data:</strong> the module&rsquo;s eponymous struct defines an immutable data structure</li>
<li><strong>behavior:</strong> the module&rsquo;s functions define state transformations, often taking the struct as input</li>
</ul>


<p>Perhaps we can combine these ideas to gain some functional-style benefits in Ruby!</p>

<h2>Data: Problem</h2>

<p>Ruby&rsquo;s mutable values open the door to errors caused by out-of-sight state changes. Here&rsquo;s a simple example:</p>

<pre><code class="ruby"># mutate the passed-in array 😈
def cause_mayhem(array)
  array &lt;&lt; nil
end

top_scores = [98, 95, 89]
cause_mayhem(top_scores)
top_scores.max # ArgumentError: comparison of Fixnum with nil failed
</code></pre>

<p>Unbeknownst to the user, <code>cause_mayhem</code> <em>altered</em> the array. It wasn&rsquo;t equal to its original value anymore! This is possible with many common objects in Ruby programming , eg <code>String</code>, <code>Hash</code>, <code>ActiveRecord::Base</code>, <code>ActiveRecord::Relation</code> and <code>ActionController::Params</code>.</p>

<p>When you pass a value to another method, you have <em>no way</em> to know how your value will be affected. Maybe it will be changed under your feet!</p>

<p>Elixir&rsquo;s immutable values offer a solution to this pitfall. When you pass a value to a function, your value won&rsquo;t be changed because it&rsquo;s <em>impossible</em> to change it!</p>

<pre><code class="elixir">cause_mayhem = fn(list) -&gt; [99999 | list] end

top_scores = [98, 95, 89]
cause_mayhem.(top_scores) # =&gt; [99999, 98, 95, 89]
Enum.max(top_scores)      # =&gt; 98
</code></pre>

<p>Although <code>cause_mayhem</code> returned a <em>new</em> list, it didn&rsquo;t alter the existing list. Changing the value of an existing item is impossible with Elixir! Because of this, you never have to worry about passing your value to another function. It <em>can&rsquo;t</em> mess up existing code!</p>

<h2>Data: Solution</h2>

<p>The Ruby solution is to write classes whose state is immutable.</p>

<p>A <em>mutable</em> class is one whose instance variables change during its lifetime. An <em>immutable</em> class is one whose instance variables <em>never</em> change during its lifetime.</p>

<p>Here&rsquo;s an example of refactoring a mutable class to be immutable.</p>

<p>First, a mutable <code>Counter</code>:</p>

<pre><code class="ruby">class MutableCounter
  attr_reader :count

  def initialize
    @count = 0
  end

  # Adds one to the internal value
  def increment
    @count += 1
  end
end
</code></pre>

<p>Now, here&rsquo;s the problem with this class. It leads to unpredictable code:</p>

<pre><code class="ruby">counter = MutableCounter.new
counter.count         # =&gt; 0
counter.increment
counter.count         # =&gt; 1
cause_mayhem(counter)
counter.count         # =&gt; ????
</code></pre>

<p>It could be mutated by <code>cause_mayhem</code>&hellip; but we have no idea!</p>

<p>Next, an immutable <code>Counter</code> class</p>

<pre><code class="ruby">class ImmutableCounter
  attr_reader :count

  def initialize(count: 0)
    @count = count
  end

  # Return a _new_ ImmutableCounter with an incremented count
  def increment
    self.class.new(count: @count + 1)
  end
end
</code></pre>

<p>No matter how you call methods on that object, its <code>@count</code> will not change after initialization.</p>

<p>Here&rsquo;s our problem code again:</p>

<pre><code class="ruby">counter = ImmutableCounter.new
counter.count         # =&gt; 0
counter = counter.increment
counter.count         # =&gt; 1
cause_mayhem(counter)
counter.count         # =&gt; 1 🎊  
</code></pre>

<p>There&rsquo;s no way <code>cause_mayhem</code> could alter our counter!</p>

<p><strong>But,</strong> what if you <em>want</em> to alter the value by some other method?</p>

<p>Easy: just make the method <em>return</em> the value you want to use. Here&rsquo;s a modified example:</p>

<pre><code class="ruby"># Increment the counter three times and return the new one
def modify_counter(counter)
  counter = counter.increment
  counter = counter.increment
  counter = counter.increment
  counter
end

# usage:

counter = ImmutableCounter.new
counter.count             # =&gt; 0
# store the old counter, just for example:
previous_counter = counter
# reassign the counter
counter = modify_counter(counter)
# counter has the new value:
counter.count           # =&gt; 3
# previous_counter was unchanged:
previous_counter.count  # =&gt; 0
</code></pre>

<p>In this case, the caller must <em>explicitly</em> receive the new value from the function. This makes it obvious to the reader that the function returned a new, useful value!</p>

<h2>Behavior: Problem</h2>

<p>In Ruby, classes express <em>behavior</em> by exposing public methods. These methods may alter internal state (like <code>MutableCounter#increment</code>). Shared code may be DRYed up by being relocated to a private method.</p>

<p>Here&rsquo;s an example:</p>

<pre><code class="ruby">class BaseballTeam
  # ...
  def add_player(player)
    @players &lt;&lt; player
    # reset cached averages, etc:
    update_team_aggregates
  end
end
</code></pre>

<p>The problem is that state changes are scattered throughout the code. Some are visible inline, some are out-of-sight. This makes <code>BaseballTeam</code> harder to understand.</p>

<p>To learn the behavior of <code>add_player</code>, must also know the behavior of <code>update_team_aggregates</code>. <em>Any</em> part of the <code>BaseballTeam</code>&rsquo;s internal state could have been altered in any way! At the end of the method body, there&rsquo;s no guarantee that <code>@players</code> contains the same objects it at the start of the method body. 😢.</p>

<p>In Elixir, any behavior that <em>would</em> mutate an object actually creates a <em>new</em> object. The analogous code is:</p>

<pre><code class="elixir">defmodule BaseballTeam do
  def add_player(team, player) do
    players = [player | team.players]
    [avg_batting_avg, avg_salary, avg_pitching_record] = calculate_aggregates(players)
    %{team | players: players, avg_batting_avg: avg_batting_avg, avg_salary: avg_salary, avg_pitching_record: avg_pitching_record}
  end
end
</code></pre>

<p>In this case, it&rsquo;s clear exactly which keys of the <code>BaseballTeam</code> struct are updated when a players is added. It&rsquo;s impossible for <code>calculate_aggregates</code> to alter any other part of the <code>team</code>!</p>

<h2>Behavior: Solution</h2>

<p>The Ruby solution is to write methods as pure functions, that is, methods which use their arguments as their <em>only</em> input (no accessing <code>self</code>) and provide a return value as their <em>only</em> output (no side-effects).</p>

<p>Here&rsquo;s a rewritten Ruby example:</p>

<pre><code class="ruby">class BaseballTeam
  # ...
  def add_player(player)
    @players &lt;&lt; player
    @avg_batting_avg, @avg_salary, @avg_pitching_record = calculate_aggregates(@players)
  end
end
</code></pre>

<p>In this case, it&rsquo;s obvious which members of the <code>team</code>&rsquo;s internal state will be modified by <code>add_player</code>. However, a developer <em>could</em> break the purely functional contract of <code>calculate_aggregates</code>.</p>

<p>To avoid that, refactor <code>BaseballTeam</code> to be a composition of <code>@players</code> and <code>@aggregates</code>:</p>

<pre><code class="ruby">class BaseballTeam
  class AggregateStats
    def initialize(players)
     # ...
    end
    # ...
  end
  # ...
  def add_player(player)
    @players &lt;&lt; player
    @aggregates = AggregateStats.new(@players)
  end

  # Aggregate methods delegate to the AggregateStats object:
  def avg_salary
    @aggregates.avg_salary
  end
end  
</code></pre>

<p>Further defensive techniques could be taken, such as:</p>

<ul>
<li>Creating a <em>new</em> <code>@players</code> array instead of mutating the existing one.</li>
<li>Freezing <code>@players</code> to prevent other code from changing it</li>
</ul>


<p>Those measures would guarantee correct state, but they may be &ldquo;overkill&rdquo; for some uses!</p>

<h2>Conclusion</h2>

<p>I can&rsquo;t magically transform my Ruby app into an Elixir app, but I <em>can</em> take some of the lessons learned from Elixir and apply them to Ruby code! Plus, Ruby gives us the ability to mutate state when necessary (for example, when performance is critical).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How many assertions per test case?]]></title>
    <link href="http://rmosolgo.github.io/blog/2015/10/08/how-many-assertions-per-test-case/"/>
    <updated>2015-10-08T21:12:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2015/10/08/how-many-assertions-per-test-case</id>
    <content type="html"><![CDATA[<p>This question is too hard. Instead, ask, &ldquo;how many behaviors per test case?&rdquo; and answer, &ldquo;one.&rdquo;</p>

<!-- more -->


<p>I presented at Full Stack about unit testing but what I really like is behavior-driven development.</p>

<h2>A Behavior</h2>

<p>You can think of a code base as a collection of behaviors: given some inputs (data, events), it makes some outputs (more data, more events). In this perspective, the code itself is an implementation detail. As long as it takes the inputs and creates the outputs, it makes little difference what classes, methods, functions etc, implement that behavior.</p>

<p>This kind of thinking is recursive: each behavior is composed of smaller behaviors. For example, in a web application:</p>

<pre><code>Behavior:
  - A request with a valid username &amp; password is allowed to take Action X

    Is composed of:
      - The user info is stored in the session
      - The user's `last_logged_in_at` is updated
      - Value Y is written to the database
</code></pre>

<p>Each subsequent level of behavior may have an implementation of its own.</p>

<h2>Testing a behavior</h2>

<p>In a web application, unauthorized requests:</p>

<ul>
<li>Return meaningful HTTP responses, including a status and a body; and</li>
<li>do not execute the requested action</li>
</ul>


<p>I would specify that as two <em>behaviors</em>:</p>

<pre><code class="ruby">describe "an unauthorized request" do
  it "responds as not authorized" do
    http_response = make_create_request # makes a unauthorized_request
    assert_equal(403, http_response.status)
    assert_equal("Not Authorized", http_response.body)
  end

  it "doesn't write to the database" do
    http_response = make_create_request # makes a unauthorized_request
    assert_equal(0, Posts.count)
  end  
end
</code></pre>

<p>(using <a href="https://github.com/seattlerb/minitest#specs">minitest/spec</a>)</p>

<p>Notice that the first test made <em>two</em> assertions. You could split that into three test cases but I don&rsquo;t think it&rsquo;s worth the trouble. What&rsquo;s the case where <code>403</code> and <code>"Not Authorized"</code> are not part of the same behavior?</p>

<h2>Multiple Assertions is a Code Smell</h2>

<p>If your test case has many assertions, your code may be telling you that you&rsquo;re specifying multiple behaviors at once. Ask yourself:</p>

<ul>
<li>Is there a smaller unit of work to extract?</li>
<li>Can I make this a two-step process, where step one&rsquo;s result is passed to step two?</li>
<li>Can I break each test case (and its corresponding code) into a distinct <a href="http://c2.com/cgi/wiki?StrategyPattern">strategy</a>?</li>
<li>Am I testing business logic <em>and</em> interaction with an external service (eg, your database or an HTTP service)? Can I separate the two actions?</li>
<li>Am I transforming data, then acting based on the result? Can I separate those two?</li>
<li>Are there assertions that are shared between multiple test cases? Is there an underlying behavior there?</li>
</ul>


<h2>Other People on The Internet</h2>

<p>Here&rsquo;s some more dignified reading on the topic:</p>

<ul>
<li><strong><a href="http://dannorth.net/introducing-bdd/">&ldquo;Introducing BDD,&rdquo; Dan North</a></strong>. I especially agree with his point that behavior-driving thinking helps you focus your design and implementation.</li>
<li><strong><a href="http://blog.jayfields.com/2007/06/testing-one-assertion-per-test.html">&ldquo;Testing One Assertion Per Test,&rdquo; Jay Fields</a></strong>. I basically agree with him: &ldquo;Tests that focus on one behavior of the system are almost always easier to write and to comprehend at a later date.&rdquo; But I disagree with his assumption that one behavior equals one assertion.</li>
<li><strong><a href="http://programmers.stackexchange.com/a/7829">&ldquo;Is it OK to have multiple asserts in a single unit test?&rdquo;, random Stack Overflow people</a></strong>. &ldquo;Yeah, but try not to.&rdquo;</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crystal First Impressions]]></title>
    <link href="http://rmosolgo.github.io/blog/2015/09/27/crystal-first-impressions/"/>
    <updated>2015-09-27T21:47:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2015/09/27/crystal-first-impressions</id>
    <content type="html"><![CDATA[<p>The <a href="http://crystal-lang.org/">Crystal programming language</a> combines Ruby-like syntax with a really powerful compiler. As a result, it&rsquo;s fun to write, fast to run, and hard to screw up!</p>

<!-- more -->


<p>My Crystal experience so far:</p>

<ul>
<li><a href="https://github.com/danott">danott</a> mentioned it in our Slack a few weeks ago</li>
<li>I read the great <a href="http://crystal-lang.org/docs/">Crystal docs</a></li>
<li>I cobbled together <a href="https://github.com/rmosolgo/crythtal">a lisp (barely)</a></li>
</ul>


<p>I&rsquo;d say it&rsquo;s a combination of:</p>

<ul>
<li>a more-stable-Ruby (like Elixir, but without Erlang)</li>
<li>a developer-friendly, life-embetter-ing type system (like Elm, but &hellip; not JavaScript)</li>
<li>a real compiler! (like C, but fun to read and write)</li>
</ul>


<p>Um, what else could you want?! (See last paragraph 😛)</p>

<h2>Crystal Syntax</h2>

<p>Crystal brings the best of Ruby:</p>

<ul>
<li><strong>Concise literals</strong>, just like Ruby (take it for granted until you use regexps in Python 🙀)</li>
<li><strong>Great OO support</strong>, classes &amp; modules just like Ruby</li>
<li><strong>Attractive syntax</strong> thanks to blocks, operator overloading and optional parens</li>
<li><strong>consistent</strong>, predictable standard library (like Ruby)</li>
</ul>


<p>Plus, some improvements over Ruby:</p>

<ul>
<li><strong>Method overloading</strong></li>
<li>Python-like <strong>keyword args</strong>: must have default value, may be passed as kwargs or positional args (I could go either way on this since Ruby 2.1, but it beats <code>options={}</code>)</li>
<li>More robust <strong>Proc literals</strong>, reminded me of Elixir</li>
<li>Convention: <strong><code>?</code> methods return maybe-nil types</strong>, while their counterparts raise on nil</li>
<li>First-class <strong>enums</strong> &amp; <strong>tuples</strong></li>
<li><strong>Immutable strings</strong>, like Ruby 3 will have (?)</li>
</ul>


<p>For completeness, you lose some things from Ruby:</p>

<ul>
<li>Runtime <strong>code creation</strong>, like <code>define_method</code> &amp; friends</li>
<li>Runtime <strong>code evaluation</strong>, like <code>eval</code> &amp; friends</li>
</ul>


<p>Crystal offers a powerful <strong>macro system</strong> that makes up for the loss of runtime metaprogramming. Unlike C preprossing, Crystal macros are awesome. You basically define functions which are called at compile-time, then generate code with liquid-like syntax.</p>

<h2>Crystal Typing</h2>

<h3>Inferring Types</h3>

<p>Crystal infers types from your code, so these are OK:</p>

<pre><code class="ruby">my_string = "Hello World"
# String
my_hash = {key: "value", key2: "value2"}
# Hash(Symbol, String)
my_array = [1,2,3]
# Array(Int32)
</code></pre>

<p>When types mix, Crystal automatically unions them. It will ensure any usages of the variable in question are valid for both types. For example:</p>

<pre><code class="ruby">my_variable = "string"
my_variable = 1
# String | Int32

# Ok, because String &amp; Int32 both implement #to_f
my_variable.to_f

# You can add runtime checks to call type-specific methods
if my_variable.is_a?(String)
  my_variable.upcase
end
</code></pre>

<p>There are some times you need to define types to help the compiler. For example, there aren&rsquo;t any values here to tell the compiler what to expect:</p>

<pre><code class="ruby">some_array =  [] of Int32
# You can use custom types, too
some_hash =   {} of Symbol =&gt; SomeCustomClass
</code></pre>

<h3>Goodbye, NoMethodErrors</h3>

<p>If you&rsquo;re like me, you hate this:</p>

<pre><code>undefined method `whatever' for nil:NilClass
</code></pre>

<p>Something somehow became nil. 😢</p>

<p>Instead, Crystal reads your code, and if there&rsquo;s somewhere a value could be nil, it throws a compile error:</p>

<pre><code>in ./src/lisp/binding.cr:55: undefined method 'find_owner' for Nil

      @parent.find_owner(key)
              ^~~~~~~~~~
</code></pre>

<p>You have two options:</p>

<ul>
<li>Add an explicit not-nil check (<code>if object.is_a?(String) ...</code>) so the compiler knows it will be safe</li>
<li>Refactor so the value won&rsquo;t be nil</li>
</ul>


<p>Of course, the first one seems better at the start, but I hope to get better at the second one 😁.</p>

<h2>What&rsquo;s Missing?</h2>

<p>Crystal really shows its youth. Its shortcomings all fall in that vein:</p>

<ul>
<li><strong>Poorly documented</strong>, which isn&rsquo;t so bad if you&rsquo;re coming from Ruby</li>
<li><strong>Few projects</strong> out there (I think the <a href="http://crystalshards.herokuapp.com/">package repository is a free Heroku app</a>)</li>
<li>Standard library has <strong>some kinks</strong>, they say it is still changing</li>
</ul>


<p>One example of a standard library kink is the handling of <code>break</code>, <code>next</code> and <code>return</code> in blocks. If you want to exit a block early, you have to choose one of those three. The problem is that, to choose the right one, you have to know whether the method captures the block into a proc or simply yields values to it. It&rsquo;s a drag to have to know a method&rsquo;s implementation to call it! (IRL, I didn&rsquo;t run into this and I suspect it would be easy enough to work around it.)</p>

<h2>Now What?</h2>

<p>I really liked Crystal and I hope I can work with it more!</p>
]]></content>
  </entry>
  
</feed>
