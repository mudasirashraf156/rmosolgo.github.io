<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: GraphQL | Robert Mosolgo]]></title>
  <link href="http://rmosolgo.github.io/blog/categories/graphql/atom.xml" rel="self"/>
  <link href="http://rmosolgo.github.io/"/>
  <updated>2020-07-27T16:05:47-04:00</updated>
  <id>http://rmosolgo.github.io/</id>
  <author>
    <name><![CDATA[Robert Mosolgo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[A New Runtime in GraphQL-Ruby 1.9]]></title>
    <link href="http://rmosolgo.github.io/blog/2019/01/29/a-new-runtime-in-graphql-ruby-1-dot-9/"/>
    <updated>2019-01-29T07:22:00-05:00</updated>
    <id>http://rmosolgo.github.io/blog/2019/01/29/a-new-runtime-in-graphql-ruby-1-dot-9</id>
    <content type="html"><![CDATA[<p>GraphQL-Ruby 1.9.0 introduces a new runtime called <code>GraphQL::Execution::Interpreter</code>. It offers better performance and some new features.</p>

<!-- more -->


<p>In <a href="https://github.com/rmosolgo/graphql-ruby/issues/861#issuecomment-458533219">isolated benchmarks</a>, the new runtime is about 50% faster. We saw about a 10% speedup in GitHub when we migrated.</p>

<p>You can opt in by adding to your schema:</p>

<pre><code class="ruby">class MySchema &lt; GraphQL::Schema
  # To use the new runtime
  use GraphQL::Execution::Interpreter
  # To skip preprocessing (you can use the interpreter without adding this)
  use GraphQL::Analysis::AST
end
</code></pre>

<p>But why rewrite?</p>

<h2>Problem 1: per-field context objects</h2>

<p>Previously, each field evaluated by GraphQL-Ruby got its own instance of <code>GraphQL::Query::Context::FieldResolutionContext</code>. This was introduced so that fields using <code>graphql-batch</code>-style Promises could reliably access context values (like <code>ctx.path</code>) <em>after</em> returning from the resolver (ie, when the promise was synced.)</p>

<p>The problem was, the bigger the response, the more <code>ctx</code> objects would be created &ndash; and most of the time (for example, plain scalar fields), they were never <em>used</em> by application code. So, we allocated, initialized, then GCed these objects for nothing!</p>

<p>In fact, it wasn&rsquo;t for <em>nothing</em>. As time passed, I started using those context objects inside execution code. For example, null propagation was implemented by climbing <em>up</em> the tree of context objects. So you couldn&rsquo;t just <em>stop</em> creating them &ndash; the runtime depended on them.</p>

<h3>Solution: one mutable context</h3>

<p>To remove this performance issue, I went <em>back</em> to creating a single <code>Query::Context</code> object and passing it to resolvers. If you&rsquo;re using the new class-based API, you might have noticed that <code>self.context</code> is a <code>Query::Context</code>, not a <code>Query::Context::FieldResolutionContext</code>. I did it this way to pave the way for removing this bottleneck.</p>

<p>But what about access to runtime information?</p>

<h3>Solution: explicit requests for runtime info</h3>

<p>For fields that <em>want</em> runtime info (like <code>path</code> or <code>ast_node</code>), they can opt into it with <code>extras: [...]</code>, for example:</p>

<pre><code class="ruby">field :items, ..., extras: [:path]
</code></pre>

<p>By adding that configuration, the requested value will be injected into the resolver:</p>

<pre><code class="ruby">def items(path:)
  # ...
end
</code></pre>

<p><code>path</code> will be a frozen Array describing the current point in the GraphQL response.</p>

<h3>Solution: reimplementing the runtime</h3>

<p>Finally, since <code>FieldResolutionContext</code>s aren&rsquo;t necessary for user code, we can rewrite execution to <em>not</em> create or use them anymore. Under the hood, <code>GraphQL::Execution::Interpreter</code> doesn&rsquo;t create those <code>ctx</code> objects. Instead, null propagation is implemented manually and all necessary values are passed from method to method.</p>

<h2>Problem 2: inefficient preprocessing</h2>

<p>Years ago, someone requested the feature of <em>rejecting a query before running it</em>. They wanted to analyze the incoming query, and if it was too big or too complicated, reject it.</p>

<p>How could this be implemented? You could provide user access to the AST, but that would leave some difficult processing to user code, for example, merging fragments on interfaces.</p>

<p>So, I added <code>GraphQL::InternalRepresentation</code> as a normalized, pre-processed query structure. Before running a query, the AST was transformed into a tree of <code>irep_node</code>s. Users could analyze that structure and reject queries if desired.</p>

<p>In execution code, why throw away the result of that preprocessing? The runtime also used <code>irep_node</code>s to save re-calculating fragment merging.</p>

<p>In fact, even <em>static validation</em> used the <code>irep_node</code> tree. At some point, rather than re-implement fragment merging, I decided to hook into that rewritten tree to implement <code>FragmentsWillMerge</code>. After all, why throw away that work?</p>

<p>(As it turns out, someone should fire the GraphQL-Ruby maintainer. These layers of code were <em>not</em> well-isolated!!)</p>

<h3>Problem 2.1: Preparing the <code>irep_node</code>s was slow and often a waste</h3>

<p>Since the <code>irep_node</code> tree was built for <em>analysis</em>, it generated branches for <em>every</em> possible combination of interfaces, objects, and unions. This meant that, even for a query returning very simple data, the pre-processing step might be <em>very</em> complex.</p>

<p>To make matters worse, the complexity of this preprocessing would grow as the schema grew. The more implementers an interface has, the longer it takes to calculate the possible branches in a fragment.</p>

<h3>Problem 2.2: Runtime features were implemented during preprocessing</h3>

<p>Not only was the work complex, but it also couldn&rsquo;t be cached. This is because, while building the <code>irep_node</code> tree, <code>@skip</code> and <code>@include</code> would be evaluated with the current query variables. If nodes were skipped, they were left out of the <code>irep_node</code> tree.</p>

<p>This means that, for the <em>same</em> query in your code base, you <em>couldn&rsquo;t</em> reuse the <code>irep_node</code> tree, since the values for those query variables might be different from one execution to the next. Boo, hiss!</p>

<h3>Problem 2.3: A wacky preprocessing step is hard to understand</h3>

<p>I want to empower people to use GraphQL-Ruby in creative ways, but throwing a wacky, custom data structure in the mix doesn&rsquo;t make it easy. I think an easier execution model will encourage people to learn how it works and build cool new stuff!</p>

<h3>Solution: No preprocessing</h3>

<p>The new runtime evaluates the AST directly. Runtime features (<code>@skip</code> and <code>@include</code>, for example) are implemented at, well, <em>runtime</em>!</p>

<h3>Solution: AST Analyzers</h3>

<p>Since you can&rsquo;t use the <code>irep_node</code> tree for analysis anymore, the library includes a new module, <code>GraphQL::Analysis::AST</code>, for preprocessing queries. Shout out to <a href="https://github.com/xuorig">@xuorig</a> for this module!</p>

<h3>Solution: Moving ahead-of-time checks to runtime</h3>

<p>For GitHub, we moved a lot of analyzer behavior to runtime. We did this because it&rsquo;s easier to maintain and requires less GraphQL-specific knowledge to understand and modify. Although the client experience is <em>slightly</em> different, it&rsquo;s still good.</p>

<p>For example, we had an analyzer to check that pagination parameters (eg <code>first</code> and <code>last</code>) were valid. We moved this to runtime, adding it to our connection tooling.</p>

<h3>Solution: <code>GraphQL::Execution::Lookahead</code></h3>

<p><code>irep_node</code>s <em>were</em> useful for looking ahead in a query to see what fields would be selected next. (Honestly, they weren&rsquo;t <em>that good</em>, but they were the only thing we had, beside using the AST directly).</p>

<p>To support that use, we now have <code>extras: [:lookahead]</code> which will inject an instance of <code>GraphQL::Execution::Lookahead</code>, with an API <em>explicitly for</em> checking fields later in the query.</p>

<h2>Other considerations</h2>

<h3>Resolve procs are out</h3>

<p>As part of the change with removing <code>FieldResolutionContext</code>, the new runtime doesn&rsquo;t support proc-style resolvers <code>-&gt;(obj, args, ctx) {...}</code>. Besides <code>ctx</code>, the <code>args</code> objects (<code>GraphQL::Query::Arguments</code>) are not created by the interpreter either. Instead, the interpreter uses plain hashes.</p>

<p>Instead of procs, methods on Object type classes should be used.</p>

<p>This means that proc-based features are also not supported. Field instrumenters and middlewares won&rsquo;t be called; a new feature called field extensions should be used instead.</p>

<h3><code>.to_graphql</code> is <em>almost</em> out</h3>

<p>When the class-based schema API was added to GraphQL-Ruby, there was a little problem. The class-based API was great for developers, but the execution API expected legacy-style objects. The bridge was crossed via a compatibility layer: each type class had a <code>def self.to_graphql</code> method which returned a legacy-style object based on that class. Internally, the class and legacy object were cached together.</p>

<p>The interpreter <em>doesn&rsquo;t</em> use those legacy objects, only classes. So, any type extensions that you&rsquo;ve built will have to be supported on those <em>classes</em>.</p>

<p>The catch is, I&rsquo;m not <em>100% sure</em> that uses of legacy objects have all been migrated. In GitHub, we transitioned by delegating methods from the legacy objects to their source classes, and I haven&rsquo;t removed those delegations yet. So, there might still be uses of legacy objects 😅.</p>

<p>In a future version, I want to remove the use of those objects <em>completely</em>!</p>

<h1>Conclusion</h1>

<p>I hope this post has clarified some of the goals and approaches toward adding the new runtime. I&rsquo;m already building new features for it, like custom directives and better subscription support. If you have a question or concern, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> to discuss!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Updating GitHub to GraphQL 1.8.0]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0/"/>
    <updated>2018-04-09T09:52:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/04/09/updating-github-to-graphql-1-dot-8-0</id>
    <content type="html"><![CDATA[<p>GraphQL 1.8.0 was designed and built largely as a part of my work at GitHub. Besides designing the <a href="http://graphql-ruby.org/schema/class_based_api">new Schema definition API</a>, I migrated our codebase to use it. Here are some field notes from my migration.</p>

<!-- more -->


<p>If you want to know more about the motivations behind this work, check out this <a href="/blog/2018/03/25/why-a-new-schema-definition-api/">previous post</a>.</p>

<p>Below, I&rsquo;ll cover:</p>

<ul>
<li>The Process: in general, how I went about migrating our code</li>
<li>The Upgrader: how to run it and roughly how it&rsquo;s organized</li>
<li>Custom Transforms: extensions I made for the upgrader to work on GitHub-specific code</li>
<li>Fixes By Hand: bits of code that needed more work (some of these could be automated, but aren&rsquo;t yet!)</li>
<li>Porting Relay Types: using the class-based API for connections and edges</li>
<li>Migrating DSL extensions: how to support custom GraphQL extension in the new API</li>
</ul>


<h2>The Process</h2>

<p>GitHub&rsquo;s type definitions are separated into folders by type, for example: <code>objects/</code>, <code>unions/</code>, <code>enums/</code> (and <code>mutations/</code>). I worked through them one folder at a time. The <code>objects/</code> folder was big, so I did it twenty or thirty files at a time.</p>

<p>I had to do <code>interfaces/</code> last because of the nature of the new class-based schema. Interfaces modules' methods can&rsquo;t be added to legacy-style GraphQL object types. So, by doing interfaces last, I didn&rsquo;t have to worry about this compatibility issue.</p>

<p>Now that I remember it, I did the schema <em>first</em>, and by hand. It was a pretty easy upgrade.</p>

<p>When I started each section, I created a base class by hand. (There is some automated support for this, but I didn&rsquo;t use it.) Then, I ran the upgrader on some files and tried to run the test suite. There were usually two kinds of errors:</p>

<ul>
<li>Parse- or load-time errors which prevented the app from booting</li>
<li>Runtime errors which resulted in unexpected behavior or raised errors</li>
</ul>


<p>More on these errors below.</p>

<p>After upgrading a section of the schema, I opened a PR for review from the team. This was crucial: since I was working at such a large scale, it was easy for me to miss the trees for the forest. My teammates caught a lot of things during the process!</p>

<p>After a review, the PR would be merged into master. Since GraphQL 1.8.0 supports incremental migration, I could work through the code in chunks without a long running branch or feature flags.</p>

<h2>About the Upgrader</h2>

<p>Here&rsquo;s an overview of how the upgrader works. After reading the overview, if you want some specific examples, check out the <a href="https://github.com/rmosolgo/graphql-ruby/blob/master/lib/graphql/upgrader/member.rb">source code</a>.</p>

<h3>Running The Upgrader</h3>

<p>The gem includes an auto-upgrader, spearheaded by the folks at <a href="https://hackerone.com">HackerOne</a> and refined during my use of it. It&rsquo;s encapsulated in a class, <code>GraphQL::Upgrader::Member</code>.</p>

<p>To use the upgrader, I added a Ruby script to the code base called <code>graphql-update.rb</code>:</p>

<pre><code class="ruby"># Usage:
#   ruby graphql-update.rb path/to/type_definition.rb
#
# Example:
#   # Upgrade `BlameRange`
#   ruby graphql-update.rb lib/platform/objects/blame_range.rb
#
#   # Upgrade based on a pattern (use quotes)
#   ruby graphql-update.rb "lib/platform/objects/blob_\*.rb"
#
#   # Upgrade one more file in this pattern (use quotes)
#   ruby graphql-update.rb 1 "lib/platform/objects/**.rb"

# Load the upgrader from local code, for easier trial-and-error development
# require "~/code/graphql-ruby/lib/graphql/upgrader/member"
# Load the upgrader from the Gem:
require "graphql/upgrader/member"

# Accept two arguments: next_files (optional), file_pattern (required)
file_pattern = ARGV[0]
if file_pattern =~ /\d+/
  next_files = file_pattern.to_i
  next_files_pattern = ARGV[1]
  "Upgrading #{next_files} more files in #{next_files_pattern}"
  filenames = Dir.glob(next_files_pattern)
else
  filenames = Dir.glob(file_pattern)
  next_files = nil
  puts "Upgrading #{filenames.join(", ")}"
end

# ...
# Lots of custom rules here, see below
# ...

CUSTOM_TRANSFORMS = {
  type_transforms: type_transforms,
  field_transforms: field_transforms,
  clean_up_transforms: clean_up_transforms,
  skip: CustomSkip,
}

upgraded = []
filenames.each do |filename|
  puts "Begin (#{filename})"
  # Read the file into a string
  original_text = File.read(filename)
  # Create an Upgrader with the set of custom transforms
  GraphQL::Upgrader::Member.new(original_text, **CUSTOM_TRANSFORMS)
  # Generate updated text
  transformed_text = upgrader.upgrade
  if transformed_text == original_text
    # No upgrade was performed
  else
    # If the upgrade was successful, update the source file
    File.write(filename, transformed_text)
    upgraded &lt;&lt; filename
  end
  puts "Done (#{filename})"
  if next_files &amp;&amp; upgraded.size &gt;= next_files
    # We've upgraded as many as we said we would
    break
  end
end
puts "Upgraded #{upgraded.size} files: \n#{upgraded.join("\n")}"
</code></pre>

<p>This script has two basic parts:</p>

<ul>
<li>Using <code>GraphQL::Upgrader::Member</code> with a set of custom transformations</li>
<li>Supporting code: accepting input, counting files, logging, etc</li>
</ul>


<p>In your own script, you can write whatever supporting code you want. The key part from GraphQL-Ruby is:</p>

<pre><code class="ruby"># Create an Upgrader with the set of custom transforms
GraphQL::Upgrader::Member.new(original_text, **CUSTOM_TRANSFORMS)
# Generate updated text
transformed_text = upgrader.upgrade
</code></pre>

<h3>The Pipeline</h3>

<p>The upgrader is structured as a pipeline: each step accepts a big string of input and returns a big string of output. Sometimes, a step does nothing and so its returned string is the same as the input string. In general, the transforms consist of two steps:</p>

<ul>
<li>Check whether the transform applies to the given input</li>
<li>If it does, copy the string and apply a find-and-replace to it (sometimes using RegExp, other times using the excellent <code>parser</code> gem.)</li>
</ul>


<p>You have a few options for customizing the transformation pipeline:</p>

<ul>
<li>Write new transforms and add them to the pipeline</li>
<li>Remove transforms from the pipeline</li>
<li>Re-use the built-in transforms, but give them different parameters, then replace the built-in one with your custom instance</li>
</ul>


<p>(The &ldquo;pipeline&rdquo; is just an array of instances or subclasses of <code>GraphQL::Upgrader::Transform</code>.)</p>

<p>We&rsquo;ll see cases of each below.</p>

<h3>Kinds of Transforms</h3>

<p>The upgrader accepts several types of transform pipelines:</p>

<pre><code class="ruby">CUSTOM_TRANSFORMS = {
  type_transforms: type_transforms,
  field_transforms: field_transforms,
  clean_up_transforms: clean_up_transforms,
  skip: CustomSkip,
}
</code></pre>

<ul>
<li><code>type_transforms</code> are run first, on the <em>entire</em> file.</li>
<li><code>field_transforms</code> are run second, but they receive <em>parts</em> of the type definition. They receive calls to <code>field</code>, <code>connection</code>, <code>return_field</code>, <code>input_field</code>, and <code>argument</code>. Fine-grained changes to field definition or argument definition go here.</li>
<li><code>clean_up_transforms</code> are run last, on the <em>entire</em> file. For example, there&rsquo;s a built-in <code>RemoveExcessWhitespaceTransform</code> which cleans up trailing spaces after other transforms have run.</li>
<li><code>skip:</code> has a special function: its <code>#skip?(input)</code> method is called and if it returns true, the text is not transformed at all. This allows the transformer to be idempotent: by default, if you run it on the same file over and over, it will update the file only <em>once</em>.</li>
</ul>


<h2>Custom Transforms</h2>

<p>Here are some custom transforms applied to our codebase.</p>

<h3>Handle a custom type-definition DSL</h3>

<p>We had a wrapper around <code>ObjectType.define</code> which attached metadata, linking the object type to a specific Rails model. The helper was called <code>define_active_record_type</code>. I wanted to take this:</p>

<pre><code class="ruby">module Platform
  module Objects
    Issue = define_active_record_type(-&gt; { ::Issue }) do
      # ...
    end
  end
end
</code></pre>

<p>And make it this:</p>

<pre><code class="ruby">module Platform
  module Objects
    class Issue &lt; Platform::Objects::Base
      model_name "Issue"
      # ...
    end
  end
end
</code></pre>

<p>Fortunately, this can be done with a pretty straightforward regular expression substitution. Here&rsquo;s the transform:</p>

<pre><code class="ruby"># Create a custom transform for our `define_active_record_type` factory:
class ActiveRecordTypeToClassTransform &lt; GraphQL::Upgrader::Transform
  # Capture: leading whitespace, type name, model name
  FIND_PATTERN = /^( +)([a-zA-Z_0-9:]*) = define_active_record_type\(-&gt; ?\{ ?:{0,2}([a-zA-Z_0-9:]*) ?\} ?\) do/
  # Restructure as a class, using the leading whitespace and adding the `model_name` DSL
  REPLACE_PATTERN = "\\1class \\2 &lt; Platform::Objects::Base\n\\1  model_name \"\\3\""

  def apply(input_text)
    # It's safe to apply this transform to _all_ input,
    # since it's a no-op if `FIND_PATTERN` is missing.
    input_text.sub(FIND_PATTERN, REPLACE_PATTERN)
  end
end
</code></pre>

<p>Then, in <code>graphql-update.rb</code>, this transform was put <em>first</em> in the list:</p>

<pre><code class="ruby"># graphql-update.rb
type_transforms = GraphQL::Upgrader::Member::DEFAULT_TYPE_TRANSFORMS.dup
type_transforms.unshift(ActiveRecordTypeToClassTransform)
</code></pre>

<p>Also, for this to work, I added the <code>def self.model_name(name)</code> helper to the base class.</p>

<h3>Renaming a Custom Field Method</h3>

<p>We have a helper for adding URL fields called <code>define_url_field</code>. I decided to rename this to <code>url_fields</code>, since these days it creates <em>two</em> fields.</p>

<p>The arguments are the same, so it was a simple substitution:</p>

<pre><code class="ruby">class UrlFieldTransform &lt; GraphQL::Upgrader::Transform
  def apply(input_text)
    # Capture the leading whitespace and the rest of the line,
    # then insert the new name where the old name used to be
    input_text.gsub(/^( +)define_url_field( |\()/, "\\1url_fields\\2")
  end
end
</code></pre>

<p>This transform didn&rsquo;t interact with any other transforms, so I added it to <code>clean_up_transforms</code>, so it would run last:</p>

<pre><code class="ruby"># Make a copy of the built-in arry
clean_up_transforms = GraphQL::Upgrader::Member::DEFAULT_CLEAN_UP_TRANSFORMS.dup
# Add my custom transform to the end of the array
clean_up_transforms.push(UrlFieldTransform)
</code></pre>

<h3>Moving DSL methods to keywords</h3>

<p>We have a few DSL methods that, at the time, were easier to implement as keyword arguments. (Since then, the API has changed a bit. You can implement DSL methods on your fields by extending <code>GraphQL::Schema::Field</code> and setting that class as <code>field_class</code> on your base Object, Interface and Mutation classes.)</p>

<p>I wanted to transform:</p>

<pre><code class="ruby">field :secretStuff, types.String do
  visibility :secret
end
</code></pre>

<p>To:</p>

<pre><code class="ruby">field :secretStuff, types.String, visibility: :secret
</code></pre>

<p>(Later, a built-in upgrader would change <code>secretStuff</code> to <code>secret_stuff</code> and <code>types.String</code> to <code>String, null: true</code>.)</p>

<p>To accomplish this, I reused a built-in transform, <code>ConfigurationToKwargTransform</code>, adding it to <code>field_transforms</code>:</p>

<pre><code class="ruby"># Make a copy of the built-in list of defaults
field_transforms = GraphQL::Upgrader::Member::DEFAULT_FIELD_TRANSFORMS.dup
# Put my custom transform at the beginning of the list
field_transforms.unshift(GraphQL::Upgrader::ConfigurationToKwargTransform.new(kwarg: "visibility"))
</code></pre>

<p>In fact, there were several configuration methods moved this way.</p>

<h3>Custom Skip</h3>

<p>As I was working through the code, some files were tougher than others. So, I decided to skip them. I decided that a magic comment:</p>

<pre><code class="ruby"># @skip-auto-upgrade
</code></pre>

<p>would cause a file to be skipped. To implement this, I made a custom skip class:</p>

<pre><code class="ruby">class CustomSkip &lt; GraphQL::Upgrader::SkipOnNullKeyword
  def skip?(input_text)
    super(input_text) || input_text.include?("@skip-auto-upgrade")
  end
end
</code></pre>

<p>And passed it as <code>skip:</code> to the upgrader. Then, later, I removed the comment and tried again. (Fortunately, my procrastination paid off because the upgrader was improved in the meantime!)</p>

<h2>Fixes by Hand</h2>

<p>As I worked, I improved the upgrader to cover as many cases as I could, but there are still a few cases that I had to upgrade by hand. I&rsquo;ll list them here. If you&rsquo;re really dragged down by them, consider opening an issue on GraphQL-Ruby to talk about fixing them. I&rsquo;m sure they <em>can</em> be fixed, I just didn&rsquo;t get to it!</p>

<p>If you want to fix one of these issues, try to replicate the issue by adding to an example <code>spec/fixtures/upgrader</code> and then getting a failing test. Then, you could update the upgrader code to fix that broken test.</p>

<h3>Accessing Arguments By Method</h3>

<p>Arguments could be accessed by method to avoid typos. However, now, since arguments are a Ruby keyword hash, they don&rsquo;t have methods corresponding to their keys.</p>

<p>Unfortunately, the upgrader doesn&rsquo;t do anything about this, it just leaves them there and you get a <code>NoMethodError</code> on <code>Hash</code>.</p>

<p>This could almost certainly be fixed by improving this find-and-replace in <code>ResolveProcToMethodTransform</code>:</p>

<pre><code class="ruby"># Update Argument access to be underscore and symbols
# Update `args[...]` and `args.key?`
method_body = method_body.gsub(/#{args_arg_name}(?&lt;method_begin&gt;\.key\?\(?|\[)["':](?&lt;arg_name&gt;[a-zA-Z0-9_]+)["']?(?&lt;method_end&gt;\]|\))?/) do
 # ...
end
</code></pre>

<p>It only updates a few methods on <code>args</code>, but I bet a similar find-and-replace could replace <em>other</em> method calls, too.</p>

<h3>Argument Usages Outside of Type Definitions</h3>

<p>Sometimes, we take GraphQL arguments and pass them to helper methods:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  Some::Helper.call(obj, args)
}
</code></pre>

<p>However when this was transformed to:</p>

<pre><code class="ruby">def do_stuff(**arguments)
  Some::Helper.call(@object, arguments)
end
</code></pre>

<p>It would break, because the new <code>arguments</code> value is a Ruby hash with underscored, symbol keys. So, if <code>Some::Helper</code> was using camelized strings to get values, it would stop working.</p>

<p>The upgrader can&rsquo;t really do anything there, since it&rsquo;s not analyzing the codebase. In my case, these were readily apparent because of failing tests, so I went and fixed them.</p>

<h3>context.add_error</h3>

<p>We have some fields that add to the <code>"errors"</code> key <em>and</em> return values, they used <code>ctx.add_error</code> to do so:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  begin
    obj.count_things
  rescue BackendIsBrokenError
    ctx.add_error(GraphQL::ExecutionError.new("Not working!"))
    0
  end
}
</code></pre>

<p>When upgraded, it doesn&rsquo;t work quite right:</p>

<pre><code class="ruby">def count_things
  begin
    @object.count_things
  rescue BackendIsBrokenError
    @context.add_error(GraphQL::ExecutionError.new("Not working!"))
    0
  end
end
</code></pre>

<p>(If you don&rsquo;t have to return a value, use <code>raise</code> instead, then you can stop reading this part!)</p>

<p>The problem is that <code>@context</code> is not a <em>field-specific</em> context anymore. Instead, it&rsquo;s the query-level context. (This is downside of the new API: we don&rsquo;t have a great way to pass in the field context anymore.)</p>

<p>To address this kind of issues, <code>field</code> accepts a keyword called <code>extras:</code>, which contains a array of symbols. In the case above, we could use <code>:execution_errors</code>:</p>

<pre><code class="ruby">field :count_things, Integer, null: false, extras: [:execution_errors]
def count_things(execution_errors:)
  @object.count_things
rescue BackendIsBrokenError
  execution_errors.add("Not working!")
  0
end
</code></pre>

<p>So, <code>execution_errors</code> was injected into the field as a keyword. It <em>is</em> field-level, so adding errors there works as before.</p>

<p>Other extras are <code>:irep_node</code>, <code>:parent</code>, <code>:ast_node</code>, and <code>:arguments</code>. It&rsquo;s a bit of a hack, but we need <em>something</em> for this!</p>

<h3>Accessing Connection Arguments</h3>

<p>By default, connection arguments (like <code>first</code>, <code>after</code>, <code>last</code>, <code>before</code>) are <em>not</em> passed to the Ruby methods for implementing fields. This is because they&rsquo;re generally used by the automagical (😖) connection wrappers, not the resolve functions.</p>

<p>But, sometimes you just <em>need</em> those old arguments!</p>

<p>If you use <code>extras: [:arguments]</code>, the legacy-style arguments will be injected as a keyword:</p>

<pre><code class="ruby"># `arguments` is the legacy-style Query::Arguments instance
# `field_arguments` is a Ruby hash with symbol, underscored keys.
def things(arguments:, **field_arguments)
  arguments[:first] # =&gt; 5
  # ...
end
</code></pre>

<h3>Fancy String Descriptions</h3>

<p>The upgrader does fine when the description is a <code>"..."</code> or <code>'...'</code> string. But in other cases, it was a bit wacky.</p>

<p>Strings built up with <code>+</code> or <code>\</code> always broke. I had to go back by hand and join them into one string.</p>

<p>Heredoc strings often <em>worked</em>, but only by chance. For example:</p>

<pre><code class="ruby">field :stuff, types.Int do
  description &lt;&lt;~MD
    Here's the stuff
  MD
end
</code></pre>

<p>Would be transformed to:</p>

<pre><code class="ruby">field :stuff, Integer, description: &lt;&lt;~MD, null: true
    Here's the stuff
  MD
</code></pre>

<p>This is valid Ruby, but a bit tricky. This could definitely be improved: since I started my project, GraphQL 1.8 was extended to support <code>description</code> as a <em>method</em> as well as a keyword. So, the upgrader could be improved to leave descriptions in place if they&rsquo;re fancy strings.</p>

<h3>Removed Comments From the Start of Resolve Proc</h3>

<p>I hacked around with the <code>parser</code> gem to transform <code>resolve</code> procs into instance methods, but there&rsquo;s a bug. A proc like this:</p>

<pre><code class="ruby">resolve -&gt;(obj, args, ctx) {
  # Do stuff
  obj.do_stuff { stuff }
}
</code></pre>

<p>Will be transformed to:</p>

<pre><code class="ruby">def stuff
  @object.do_stuff { stuff }
end
</code></pre>

<p>Did you see how the comment was removed? I think I&rsquo;ve somehow wrongly detected the start of the proc body, so that the comment was left out.</p>

<p>In my case, I re-added those comments by hand. But it could probably be fixed in <code>GraphQL::Upgrader::ResolveProcToMethodTransform</code>.</p>

<h3>Hash Reformating?</h3>

<p>I&rsquo;m not sure why, but sometimes a hash of arguments like:</p>

<pre><code class="ruby">obj.do_stuff(
  a: 1,
  b: 2,
  c: 3,
  d: 4,
)
</code></pre>

<p>would be reorganized to</p>

<pre><code class="ruby">obj.do_stuff(
  a: 1,
  b: 2, c: 3, d: 4,
)
</code></pre>

<p>I have no idea why, and I didn&rsquo;t look into it, I just fixed it by hand.</p>

<h3>Issues with Connection DSL</h3>

<p>We have a DSL for making connections, like:</p>

<pre><code class="ruby">Connections.define(Objects::Issue)
</code></pre>

<p>Sometimes, when this connection was inside a proc, it would be wrongly transformed to:</p>

<pre><code class="ruby">field :issues, Connections.define(Objects::Issue) }, ,null: true
</code></pre>

<p>This was invalid Ruby, so the app wouldn&rsquo;t boot, and I would fix it by hand.</p>

<h2>Porting Relay Types</h2>

<p>Generating connection and edge types with the <code>.connection_type</code>/<code>.define_connection</code> and <code>.edge_type</code>/<code>.define_edge</code> methods will work fine with the new API, but if you want to migrate them to classes, you can do it.</p>

<p>It&rsquo;s on my radar because I want to remove our DSL extensions, and that requires updating our custom connection edge types.</p>

<p>Long story, short, it Just Work™ed with the class-based API. The approach was:</p>

<ul>
<li>Add a base class inheriting from our <code>BaseObject</code></li>
<li>Use the new base class&rsquo;s <code>def self.inherited</code> hook to add connection- and edge-related behaviors</li>
<li>Run the upgrader on edge and connection types, then go back and do some manual find-and-replaces to make them work right</li>
</ul>


<p>So, I will share my base classes in case that helps. Sometime it will be nice to upstream this to GraphQL-Ruby, but I&rsquo;m not sure how to do it now.</p>

<p>Base connection class:</p>

<pre><code class="ruby">module Platform
  module Connections
    class Base &lt; Platform::Objects::Base
      # For some reason, these are needed, they call through to the underlying connection wrapper.
      extend Forwardable
      def_delegators :@object, :cursor_from_node, :parent

      # When this class is extended, add the default connection behaviors.
      # This adds a new `graphql_name` and description, and searches
      # for a corresponding edge type.
      # See `.edge_type` for how the fields are added.
      def self.inherited(child_class)
        # We have a convention that connection classes _don't_ end in `Connection`, which
        # is a bit confusing and results in naming conflicts.
        # To avoid a GraphQL conflict, override `graphql_name` to end in `Connection`.
        type_name = child_class.name.split("::").last
        child_class.graphql_name("#{type_name}Connection")

        # Use `require_dependency` so that the types will be loaded, if they exist.
        # Otherwise, `const_get` may reach a top-level constant (eg, `::Issue` model instead of `Platform::Objects::Issue`).
        # That behavior is removed in Ruby 2.5, then we can remove these require_dependency calls too.
        begin
          # Look for a custom edge whose name matches this connection's name
          require_dependency "lib/platform/edges/#{type_name.underscore}"
          wrapped_edge_class = Platform::Edges.const_get(type_name)
          wrapped_node_class = wrapped_edge_class.fields["node"].type
        rescue LoadError =&gt; err
          # If the custom edge file doesn't exist, look for an object
          begin
            require_dependency "lib/platform/objects/#{type_name.underscore}"
            wrapped_node_class = Platform::Objects.const_get(type_name)
            wrapped_edge_class = wrapped_node_class.edge_type
          rescue LoadError =&gt; err
            # Assume that `edge_type` will be called later
          end
        end

        # If a default could be found using constant lookups, generate the fields for it.
        if wrapped_edge_class
          if wrapped_edge_class.is_a?(GraphQL::ObjectType) || (wrapped_edge_class.is_a?(Class) &amp;&amp; wrapped_edge_class &lt; Platform::Edges::Base)
            child_class.edge_type(wrapped_edge_class, node_type: wrapped_node_class)
          else
            raise TypeError, "Missed edge type lookup, didn't find a type definition: #{type_name.inspect} =&gt; #{wrapped_edge_class.inspect}"
          end
        end
      end

      # Configure this connection to return `edges` and `nodes` based on `edge_type_class`.
      #
      # This method will use the inputs to create:
      # - `edges` field
      # - `nodes` field
      # - description
      #
      # It's called when you subclass this base connection, trying to use the
      # class name to set defaults. You can call it again in the class definition
      # to override the default (or provide a value, if the default lookup failed).
      def self.edge_type(edge_type_class, edge_class: GraphQL::Relay::Edge, node_type: nil)
        # Add the edges field, can be overridden later
        field :edges, [edge_type_class, null: true],
          null: true,
          description: "A list of edges.",
          method: :edge_nodes,
          edge_class: edge_class

        # Try to figure out what the node type is, if it wasn't provided:
        if node_type.nil?
          if edge_type_class.is_a?(Class)
            node_type = edge_type_class.fields["node"].type
          elsif edge_type_class.is_a?(GraphQL::ObjectType)
            # This was created with `.edge_type`
            node_type = Platform::Objects.const_get(edge_type_class.name.sub("Edge", ""))
          else
            raise ArgumentError, "Can't get node type from edge type: #{edge_type_class}"
          end
        end

        # If it's a non-null type, remove the wrapper
        if node_type.respond_to?(:of_type)
          node_type = node_type.of_type
        end

        # Make the `nodes` shortcut field, which can be overridden later
        field :nodes, [node_type, null: true],
          null: true,
          description: "A list of nodes."

        # Make a nice description
        description("The connection type for #{node_type.graphql_name}.")
      end

      field :page_info, GraphQL::Relay::PageInfo, null: false, description: "Information to aid in pagination."

      # By default this calls through to the ConnectionWrapper's edge nodes method,
      # but sometimes you need to override it to support the `nodes` field
      def nodes
        @object.edge_nodes
      end
    end
  end
end
</code></pre>

<p>Base edge class:</p>

<pre><code class="ruby">module Platform
  module Edges
    class Base &lt; Platform::Objects::Base
      # A description which is inherited and may be overridden
      description "An edge in a connection."

      def self.inherited(child_class)
        # We have a convention that edge classes _don't_ end in `Edge`,
        # which is a little bit confusing, and would result in a naming conflict by default.
        # Avoid the naming conflict by overriding `graphql_name` to include `Edge`
        wrapped_type_name = child_class.name.split("::").last
        child_class.graphql_name("#{wrapped_type_name}Edge")
        # Add a default `node` field, assuming the object type name matches.
        # If it doesn't match, you can override this in subclasses
        child_class.field :node, "Platform::Objects::#{wrapped_type_name}", null: true, description: "The item at the end of the edge."
      end

      # A cursor field which is inherited
      field :cursor, String,
        null: false,
        description: "A cursor for use in pagination."
    end
  end
end
</code></pre>

<h2>Migrating DSL Extensions</h2>

<p>We have several extensions to the GraphQL-Ruby <code>.define</code> DSL, for example, <code>visibility</code> controls who can see certain types and fields and <code>scopes</code> maps OAuth scopes to GraphQL types.</p>

<p>The difficulty in porting extensions comes from the implementation details of the new API. For now, definition classes are factories for legacy-style type instances. Each class has a <code>.to_graphql</code> method which is called <em>once</em> to return a legacy-style definition. To maintain compatibility, you have to either:</p>

<ul>
<li>Modify the derived legacy-style definition to reflect configurations on the class-based definition; OR</li>
<li>Update your runtime code to <em>stop</em> checking for configurations on the legacy-style definition and <em>start</em> checking for configurations on the class-based definition.</li>
</ul>


<p>Eventually, legacy-style definitions will be phased out of GraphQL-Ruby, but for now, they both exist in this way in order to maintain backwards compatibility and gradual adoptability.</p>

<p>In the mean time, you can go between class-based and legacy-style definitions using <code>.graphql_defintion</code> and <code>.metadata[:type_class]</code>, for example:</p>

<pre><code class="ruby">class Project &lt; BaseObject
  # ...
end

legacy_type = Project.graphql_definition
# #&lt;GraphQL::ObjectType&gt; instance
legacy_type.metadata[:type_class]
# `Project` class
</code></pre>

<h3>The Easy Way: <code>.redefine</code></h3>

<p>The easiest way to retain compatibility is to:</p>

<ul>
<li>Add a class method to your base classes which accept some configuration and put it in instance variables</li>
<li>Override <code>.to_graphql</code> to call super, and then pass the configuration to <code>defn.redefine(...)</code>, then return the redefined type.</li>
</ul>


<p>After my work on our code, I extracted this into a <a href="http://graphql-ruby.org/type_definitions/extensions.html#customization-compatibility">backport of <code>accepts_definition</code></a></p>

<p>You can take that approach for a try, for example:</p>

<pre><code class="ruby">class BaseObject &lt; GraphQL::Schema::Object
  # Add a configuration method
  def self.visibility(level)
    @visibility = level
  end

  # Re-apply the configuration
  def self.to_graphql
    type_defn = super
    # Call through to the old extension:
    type_defn = type_defn.redefine(visibilty: @visibility)
    # Return the redefined type:
    type_defn
  end
end

# Then, use it in type definitions:
class Post &lt; BaseObject
  visibility(:secret)
end
</code></pre>

<h3>The Hard Way: <code>.metadata[:type_class]</code></h3>

<p>An approach I haven&rsquo;t tried yet, but I will soon, is to move the &ldquo;source of truth&rdquo; to the the class-based definition. The challenge here is that class-based definitions are not really used during validation and execution, so how can you reach configuration values on those classes?</p>

<p>The answer is that if a legacy-style type was derived from a class, that class is stored as <code>metadata[:type_class]</code>. For example:</p>

<pre><code class="ruby">class Project &lt; BaseObject
  # ...
end
legacy_defn = Project.graphql_definition # Instance of GraphQL::ObjectType, just like `.define`
legacy_defn.metadata[:type_class] # `Project` class from above
</code></pre>

<p>So, you could update runtime code to read configurations from <code>type_defn.metadata[:type_class]</code>.</p>

<p>Importantly, <code>metadata[:type_class]</code> will be <code>nil</code> if the type <em>wasn&rsquo;t</em> derived from a class, so this approach is tough to use if some definitions are still using the <code>.define</code> API.</p>

<p>I haven&rsquo;t implemented this yet, but I will be doing it in the next few weeks so we can simplify our extensions and improve boot time.</p>

<h2>The End</h2>

<p>I&rsquo;m still wrapping up some loose ends in the codebase, but I thought I&rsquo;d share these notes in case they help you in your upgrade. If you run into trouble on anything mentioned here, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> on GraphQL-Ruby! I really want to support a smooth transition to this new API.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Why a New Schema Definition API?]]></title>
    <link href="http://rmosolgo.github.io/blog/2018/03/25/why-a-new-schema-definition-api/"/>
    <updated>2018-03-25T13:59:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2018/03/25/why-a-new-schema-definition-api</id>
    <content type="html"><![CDATA[<p>GraphQL-Ruby <code>1.8.0</code> will have a new class-based API for defining your schema. Let&rsquo;s investigate the design choices in the new API.</p>

<!-- more -->


<p>The new API is backwards-compatible and can coexist with type definitions in the old format. See <a href="https://github.com/rmosolgo/graphql-ruby/blob/1.8-dev/guides/schema/class_based_api.md#compatibility--migration-overview">the docs</a> for details. <code>1.8.0.pre</code> versions are available on RubyGems now and are very stable &ndash; that&rsquo;s what we&rsquo;re running at GitHub!</p>

<h2>Problems Worth Fixing</h2>

<p>Since starting at GitHub last May, I&rsquo;ve entered into the experience of a huge-scale GraphQL system. Huge scale in lots of ways: huge schema, huge volume, and huge developer base. One of the problems that stood out to me (and to lots of us) was that GraphQL-Ruby simply <em>didn&rsquo;t help</em> us be productive. Elements of schema definition hindered us rather than helped us.</p>

<p>So, our team set out on remaking the GraphQL-Ruby schema definition API. We wanted to address a few specific issues:</p>

<ul>
<li><strong>Familiarity</strong>. GraphQL-Ruby&rsquo;s schema definition API reflected GraphQL and JavaScript more than it reflected Ruby. (The JavaScript influence comes from <code>graphql-js</code>, the reference implementation.) Ruby developers couldn&rsquo;t bring their usual practices into schema development; instead, they had to learn a bunch of new APIs and figure out how to work them together.</li>
<li><strong>Rails Compatibility</strong>, especially constant loading. A good API would work seamlessly with Rails development configurations, but the current API has some gotchas regarding circular dependencies and reloading.</li>
<li><strong>Hackability</strong>. Library code is fine <em>until it isn&rsquo;t</em>, and one of the best (and worst) things about Ruby is that all code is open to extension (or monkey-patching 🙈). At best, this means that library users can customize the library code in straightforward ways to better suit their use cases. However, GraphQL-Ruby didn&rsquo;t support this well: to support special use cases, customizations had to be hacked in in odd ways that were hard to maintain and prone to breaking during gem updates.</li>
</ul>


<p>Besides all that, we needed a <em>safe</em> transition, so it had to support a gradual adoption.</p>

<p>After trying a few different possibilities, the team decided to take a class-based approach to defining GraphQL schemas. I&rsquo;m really thankful for their support in the design process, and I&rsquo;m indebted to the folks at Shopify, who used a class-based schema definition system from the start (as a layer on top of GraphQL-Ruby) and <a href="https://www.youtube.com/watch?v=Wlu_PWCjc6Y">presented their work</a> early on.</p>

<h2>The new API, from 10,000 feet</h2>

<p>In short, GraphQL types used to be singleton instances, built with a <a href="https://twitter.com/krainboltgreene/status/971797438070599680">block-based API</a>:</p>

<pre><code class="ruby">Types::Post = GraphQL::ObjectType.define {
  # ...
}
</code></pre>

<p>Now, GraphQL types are classes, with a DSL implemented as class methods:</p>

<pre><code class="ruby">class Types::Post
  # ...
end
</code></pre>

<p>Field resolution was previously defined using Proc literals:</p>

<pre><code class="ruby">field :comments, types[Types::Comments] do
  argument :orderBy, Types::CommentOrder
  resolve -&gt;(obj, args, ctx) {
    obj.comments.order(args[:orderBy])
  }
end
</code></pre>

<p>Now, field resolution is defined with an instance method:</p>

<pre><code class="ruby">field :comments, [Types::Comments], null: true do
  argument :order_by, Types::CommentOrder, required: false
end

def comments(order_by: nil)
  object.comments.order(order_by)
end
</code></pre>

<p>How does this address the issues listed above?</p>

<h2>More Familiarity</h2>

<p>First, using classes reduces the &ldquo;WTF&rdquo; factor of GraphQL definition code. A seasoned Ruby developer might (rightly) smell foul play and reject GraphQL-Ruby on principle. (I was not seasoned enough to detect this when I designed the API!)</p>

<p>Proc literals are rare in Ruby, but common in GraphQL-Ruby&rsquo;s <code>.define { ... }</code> API. Their lexical scoping rules are different than method scoping rules, making it hard to remember what <em>was</em> and <em>wasn&rsquo;t</em> in scope during field resolution (for example, what was <code>self</code>?). To make matters worse, <em>some</em> of the blocks in the <code>.define</code> API were <code>instance_eval</code>&rsquo;d, so their <code>self</code> would be overridden. Practically, this meant that typos in development resulted in strange <code>NoMethodError</code>s.</p>

<p>Proc literals also have performance downsides: they&rsquo;re not optimized by CRuby, so they&rsquo;re <a href="https://gist.github.com/rmosolgo/6c6a7d787e0f1666f4c6d858c8402a01#gistcomment-1843329">slower than method calls</a>. Since they capture a lexical scope, they may also have <a href="https://github.com/github/graphql-client/pull/139">unexpected impacts on memory footprint</a> (any local variable may be retained, since it might be accessed by the proc). The solutions here are simple: just use methods, the way Ruby wants you to! 😬</p>

<p>In the new class-based API, there are no proc literals (although they&rsquo;re supported for compatibility&rsquo;s sake). There are some <code>instance_eval</code>&rsquo;d blocks (<code>field(...) { }</code>, for example), but field resolution is <em>just an instance method</em> and the type definition is a normal class, so module scoping works normally. (Contrast that with the constant assignment in <code>Types::Post = GraphQL::ObjectType.define { ... }</code>, where no module scope is used). Several hooks that were previously specified as procs are now class methods, such as <code>resolve_type</code> and <code>coerce_input</code> (for scalars).</p>

<p>Overriding <code>!</code> is another particular no-no I&rsquo;m correcting. At the time, I thought, &ldquo;what a cool way to bring a GraphQL concept into Ruby!&rdquo; This is because GraphQL non-null types are expressed with <code>!</code>:</p>

<pre><code class="ruby"># This field always returns a User, never `null`
author: User!
</code></pre>

<p>So, why not express the concept with Ruby&rsquo;s <code>!</code> method (which is usually used for negation)?</p>

<pre><code class="ruby">field :author, !User
</code></pre>

<p>As it turns out, there are several good reasons for <em>why not</em>!</p>

<ul>
<li>Overriding <code>!</code> breaks the negation operator. ActiveSupport&rsquo;s <code>.present?</code> didn&rsquo;t work with type objects, because <code>!</code> didn&rsquo;t return <code>false</code>, it returned a non-null type.</li>
<li>Overriding the <code>!</code> operator throws people off. When a newcomer sees GraphQL-Ruby sample code, they have a WTF moment, followed by the dreadful memory (or discovery) that Ruby allows you to override <code>!</code>.</li>
<li>There&rsquo;s very little value in importing GraphQL concepts into Ruby. GraphQL-Ruby developers are generally seasoned Ruby developers who are just learning GraphQL, so they don&rsquo;t gain anything by the similarity to GraphQL.</li>
</ul>


<p>So, overriding <code>!</code> didn&rsquo;t deliver any value, but it did present a roadblock to developers and break some really essential code.</p>

<p>In the new API, nullability is expressed with the options <code>null:</code> and <code>required:</code> instead of with <code>!</code>. (But, you can re-activate that override for compatibility while you transition to the new API.)</p>

<p>By switching to Ruby&rsquo;s happy path of classes and methods, we can help Ruby developers feel more at home in GraphQL definitions. Additionally, we avoid some unfamiliar gotchas of procs and clear a path for removing the <code>!</code> override.</p>

<h2>Rails Compatibility</h2>

<p>Rails' automatic constant loading is wonderful &hellip; until it&rsquo;s <em>not</em>! GraphQL-Ruby didn&rsquo;t play well with Rails' constant loading especially when it came to cyclical dependencies, and here&rsquo;s why.</p>

<p>Imagine a typical <code>.define</code>-style type definition, like this:</p>

<pre><code class="ruby">Types::T = GraphQL::ObjectType.define { ... }
</code></pre>

<p>We&rsquo;re assigning the constant <code>Types::T</code> to the return value of <code>.define { ... }</code>. Consequently, the constant is not defined <em>until</em> <code>.define</code> returns.</p>

<p>Let&rsquo;s expand the example to two type definitions:</p>

<pre><code class="ruby">Types::T1 = GraphQL::ObjectType.define { ... }
Types::T2 = GraphQL::ObjectType.define { ... }
</code></pre>

<p>If <code>T1</code> depends on <code>T2</code>, <em>and</em> <code>T2</code> depends on <code>T1</code>, how can this work? (For example, imagine a <code>Post</code> type whose <code>author</code> field returns a <code>User</code>, and a <code>User</code> type whose <code>posts</code> field returns a list of <code>Post</code>s. This kind of cyclical dependency is common!) GraphQL-Ruby&rsquo;s solution was to adopt a JavaScriptism, a <em>thunk</em>. (Technically, I guess it&rsquo;s a functional programming-ism, but I got it from <code>graphql-js</code>.) A <em>thunk</em> is an anonymous function used to defer the resolution of a value. For example, if we have code like this:</p>

<pre><code class="ruby">field :author, Types::User
# NameError: uninitialized constant Types::User
</code></pre>

<p>GraphQL-Ruby would accept this:</p>

<pre><code class="ruby">field :author, -&gt; { Types::User }
# Thanks for the function, I will call it later to get the value!
</code></pre>

<p>Later, GraphQL-Ruby would <code>.call</code> the proc and get the value. At that type, <code>Types::User</code> would properly resolve to the correct type. This <em>worked</em> but it had two big downsides:</p>

<ul>
<li>It added an unfamiliar construct (<code>Proc</code>) in an unfamiliar context (a method argument), so it was frustrating and disorienting.</li>
<li>It added visual noise to the source code.</li>
</ul>


<p>How does switching to classes resolve this issue? To ask the same question, how come we don&rsquo;t experience this problem with normal Rails models?</p>

<p>Part of the answer has to do with <em>how classes are evaluated</em>. Consider two classes in two different files:</p>

<pre><code class="ruby"># app/graphql/types/post.rb
module Types
  class Post &lt; BaseObject
    field :author, Types::User, null: false
  end
end
# app/graphql/types/user.rb
module Types
  class User &lt; BaseObject
    field :posts, [Types::Post], null: false
  end
end
</code></pre>

<p>Notice that <code>Post</code> depends on <code>User</code>, and <code>User</code> depends on <code>Post</code>. The difference is how these lines are evaluated, and when the constants become defined. Here&rsquo;s the same code, with numbering to indicate the order that lines are evaluated:</p>

<pre><code class="ruby"># Let's assume that `Post` is loaded first.
# app/graphql/types/post.rb
module Types                                  # 1, evaluation starts here
  class Post &lt; BaseObject                     # 2, and naturally flows here, constant `Types::Post` is initialized as a class extending BaseObject
    field :author, Types::User, null: false   # 3, but when evaluating `Types::User`, jumps down below
  end                                         # 9, execution resumes here after loading `Types::User`
end                                           # 10
# app/graphql/types/user.rb
module Types                                  # 4, Rails opens this file looking for `Types::User`
  class User &lt; BaseObject                     # 5, constant `Types::User` is initialized
    field :posts, [Types::Post], null: false  # 6, this line finishes without jumping, because `Types::Post` is _already_ initialized (see `# 2` above)
  end                                         # 7
end                                           # 8
</code></pre>

<p>Since <code>Types::Post</code> is <em>initialized</em> first, then built-up by the following lines of code, it&rsquo;s available to <code>Types::User</code> in the case of a circular dependency. As a result, the thunk is not necessary.</p>

<p>This approach isn&rsquo;t a silver bullet &ndash; <code>Types::Post</code> is not fully initialized by the time <code>Types::User</code> needs it &ndash; but it reduces visual friction and generally plays nice with Rails out of the box.</p>

<h2>Hackability</h2>

<p>I&rsquo;ve used a naughty word here, but in fact, I&rsquo;m talking about something very good. Have you ever been stuck with some dependency that didn&rsquo;t quite fit your application? (Or, maybe you were stuck on an old version, or your app needed a new feature that wasn&rsquo;t quite supported by the library.) Like it or not, sometimes the only way forward in a case like that is to hack it: reopen classes, redefine methods, mess with the inheritance chain, etc. Yes, those choices come with maintenance downsides, but sometimes they&rsquo;re really the best way forward.</p>

<p>On the other hand, really flexible libraries are <em>ready</em> for you to come and extend them. For example, they might provide base classes for you to extend, with the assumption that you&rsquo;ll override and implement certain methods. In that case, the same hacking techniques listed above have found their time to shine.</p>

<p><code>ActiveRecord::Base</code> is a great example of both cases: plenty of libraries hack methods right into the built-in class (for example, <code>acts_as_{whatever}</code>), and also, lots of Rails apps use an <code>ApplicationRecord</code> class for their application-specific customizations.</p>

<p>Since GraphQL-Ruby didn&rsquo;t use the familiar arrangement of classes and methods, it was closed to this kind of extension. (Ok, you <em>could</em> do it, but it was a lot of work! And who wants to do that!?) In place of this, GraphQL-Ruby had yet-another-API for extending its DSL. Yet another thing to learn, with more Proc literals 😪.</p>

<p>Using classes simplifies this process because you can use familiar Ruby techniques to build your GraphQL schema. For example, if you want to share code between field resolvers, you can <code>include</code> a module and call its methods. If you want to make shorthands for common cases in your app, you can use your <code>Base</code> type classes. If you want to add special configuration to your types, you can use class methods. And, whenever that day should come, when you need to monkey-patch GraphQL-Ruby internals, I hope you&rsquo;ll be able to find the right spot to do it!</p>

<h2>Stay Classy</h2>

<p>GraphQL-Ruby is three years old now, and I&rsquo;ve learned a LOT during that time! I&rsquo;m really thankful for the opportunity to focus on <em>developer productivity</em> in the last few months, learning how I&rsquo;ve prevented it and working on ways to improve it. I hope to keep working on topics like this &ndash; how to make GraphQL more productive for Ruby developers &ndash; in the next year, especially, so if you have feedback on this new API, please <a href="https://github.com/rmosolgo/graphql-ruby/issues/new">open an issue</a> to share it!</p>

<p>I&rsquo;m excited to see how this new API changes the way people think about GraphQL in Ruby, and I hope it will foster more creativity and stability.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prototyping a GraphQL Schema From Definition With Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby/"/>
    <updated>2017-03-17T15:49:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/17/prototyping-a-graphql-schema-from-definition-with-ruby</id>
    <content type="html"><![CDATA[<p>GraphQL 1.5.0 includes a new way to define a schema: from a GraphQL definition.</p>

<!-- more -->


<p>In fact, loading a schema this way has been supported for while, but 1.5.0 adds the ability to specify field resolution behavior.</p>

<h2>GraphQL IDL</h2>

<p>Besides queries, GraphQL has an <em>interface definition language</em> (IDL) for expressing a schema’s structure. For example:</p>

<pre><code class="ruby">schema {
  query: Query
}

type Query {
  post(id: ID!): Post
}

type Post {
  title: String!
  comments: [Comment!]
}
</code></pre>

<p>You can turn a definition into a schema with <code>Schema.from_definition</code>:</p>

<pre><code class="ruby">schema_defn = "..."
schema = GraphQL::Schema.from_definition(schema_defn)
</code></pre>

<p>(By the way, the IDL is technically in <a href="https://github.com/facebook/graphql/pull/90">RFC stage</a>.)</p>

<h2>Resolvers</h2>

<p><code>Schema.from_definition</code> also accepts <code>default_resolve:</code> argument. It expects one of two inputs:</p>

<ul>
<li>A nested hash of type <code>Hash&lt;String =&gt; Hash&lt;String =&gt; #call(obj, args, ctx)&gt;&gt;</code>; or</li>
<li>An object that responds to <code>#call(type, field, obj, args, ctx)</code></li>
</ul>


<h4>Resolving with a Hash</h4>

<p>When you’re using a hash:</p>

<ul>
<li>The first key is a <em>type name</em></li>
<li>The second key is a <em>field name</em></li>
<li>The last value is a <em>resolve function</em> (<code>#call(obj, args, ctx)</code>)</li>
</ul>


<p>To get started, you can write the hash manually:</p>

<pre><code class="ruby">{
  "Query" =&gt; {
    "post" =&gt; -&gt;(obj, args, ctx) { Post.find(args[:id]) },
  },
  "Post" =&gt; {
    "title" =&gt; -&gt;(obj, args, ctx) { obj.title },
    "body" =&gt; -&gt;(obj, args, ctx) { obj.body },
    "comments" =&gt; -&gt;(obj, args, ctx) { obj.comments },
  },
}
</code></pre>

<p>But you can also reduce a lot of boilerplate by using a hash with default values:</p>

<pre><code class="ruby"># This hash will fall back to default implementation if another value isn't provided:
type_hash = Hash.new do |h, type_name|
  # Each type gets a hash of fields:
  h[type_name] = Hash.new do |h2, field_name|
    # Default resolve behavior is `obj.public_send(field_name, args, ctx)`
    h2[field_name] = -&gt;(obj, args, ctx) { obj.public_send(field_name, args, ctx) }
  end
end

type_hash["Query"]["post"] = -&gt;(obj, args, ctx) { Post.find(args[:id]) }

schema = GraphQL::Schema.from_definition(schema_defn, default_resolve: type_hash)
</code></pre>

<p>Isn’t that a nice way to set up a simple schema?</p>

<h4>Resolving with a Single Function</h4>

<p>You can provide a single callable that responds to <code>#call(type, field, obj, args, ctx)</code>. What a mouthful!</p>

<p>The <em>advantage</em> of that hefty method signature is that it’s enough to specify any resolution behavior you can imagine. For example, you could create a system where type modules were found by name, then methods were called by name:</p>

<pre><code class="ruby">module ExecuteGraphQLByConvention
  module_function
  # Find a Ruby module corresponding to `type`,
  # then call its method corresponding to `field`.
  def call(type, field, obj, args, ctx)
    type_module = Object.const_get(type.name)
    type_module.public_send(field.name, obj, args, ctx)
  end
end

schema = GraphQL::Schema.from_definition(schema_defn, default_resolve: ExecuteGraphQLByConvention)
</code></pre>

<p>So, a single function combined with Ruby’s flexibility and power opens a lot of doors!</p>

<p>Doesn’t it remind you a bit of method dispatch? The arguments are:</p>

<table>
<thead>
<tr>
<th>GraphQL Field Resolution </th>
<th> Method Dispatch</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>type</code> </td>
<td> class</td>
</tr>
<tr>
<td><code>field</code> </td>
<td> method</td>
</tr>
<tr>
<td><code>obj</code> </td>
<td> receiver</td>
</tr>
<tr>
<td><code>args</code> </td>
<td> method arguments</td>
</tr>
<tr>
<td><code>ctx</code> </td>
<td> runtime state (cf <a href="https://github.com/mruby/mruby/blob/master/include/mruby.h#L257"><code>mrb_state</code></a>, <a href="https://github.com/antirez/redis/blob/unstable/src/modules/INTRO.md"><code>RedisModuleCtx</code></a>, or <a href="http://erlang.org/doc/tutorial/nif.html"><code>ErlNifEnv</code></a>)</td>
</tr>
</tbody>
</table>


<h2>Special Configurations</h2>

<p>Some schemas need other configurations in order to run:</p>

<ul>
<li><code>resolve_type</code> to support union and interface types</li>
<li>schema plugins like <a href="https://rmosolgo.github.io/graphql-ruby/pro/monitoring">monitoring</a> or custom <a href="https://rmosolgo.github.io/graphql-ruby/schema/instrumentation">instrumentation</a></li>
</ul>


<p>To add these to a schema, use <code>.redefine</code>:
```ruby</p>

<h1>Extend the schema with new definitions:</h1>

<p>schema = schema.redefine {
  resolve_type ->(obj, ctx) { &hellip; }
  monitoring :appsignal
}
```</p>

<h2>What’s Next?</h2>

<p>Rails has proven that “Convention over Configuration” can be a very productive way to start new projects, so I’m interested in exploring convention-based APIs on top of this feature.</p>

<p>In the future, I’d like to add support for schema annotations in the form of directives, for example:</p>

<pre><code class="ruby">type Post {
  comments: [Comment!] @relation(hasMany: "comments")
}
</code></pre>

<p>These could be used to customize resolution behavior. Cool!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tracking Schema Changes with GraphQL-Ruby]]></title>
    <link href="http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby/"/>
    <updated>2017-03-16T20:16:00-04:00</updated>
    <id>http://rmosolgo.github.io/blog/2017/03/16/tracking-schema-changes-with-graphql-ruby</id>
    <content type="html"><![CDATA[<p>One way to keep an eye on your GraphQL schema is to check the definition into source control.</p>

<!-- more -->


<p>When modifying shared code or reconfiguring, it can be hard to tell how the schema will <em>really</em> change. To help with this, set up a <strong>snapshot test</strong> for your GraphQL schema! This way:</p>

<ul>
<li>Changes will be clearly visible in GraphQL IDL</li>
<li>You can keep the IDL up-to-date by adding a test to your suite</li>
</ul>


<p>You can even track the schema from different contexts if you&rsquo;re using <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization framework</a>.</p>

<p>This approach was first described in <a href="https://www.youtube.com/watch?v=Wlu_PWCjc6Y">GraphQL at Shopify</a>.</p>

<h2>Check It In</h2>

<p>Write a <strong>Rake task</strong> to get your schema&rsquo;s definition and write it to a file:</p>

<pre><code class="ruby"># lib/tasks/graphql.rake
rake dump_schema: :environment do
  # Get a string containing the definition in GraphQL IDL:
  schema_defn = MyAppSchema.to_definition
  # Choose a place to write the schema dump:
  schema_path = "app/graphql/schema.graphql"
  # Write the schema dump to that file:
  File.write(Rails.root.join(schema_path), schema_defn)
  puts "Updated #{schema_path}"
end
</code></pre>

<p>You can run it from terminal:</p>

<pre><code class="sh">$ bundle exec rake dump_schema
Updated app/graphql/schema.graphql
</code></pre>

<p>This updates the file in your repo. Go ahead and <strong>check it in</strong>!</p>

<pre><code class="sh">$ git add app/graphql/schema.graphql
$ git commit -m "Add GraphQL schema dump"
</code></pre>

<h2>Keep It Up to Date</h2>

<p>Any changes to the Ruby schema code must be reflected in the <code>.graphql</code> file. You can give yourself a reminder by adding a <strong>test case</strong> which asserts that the GraphQL definition is up-to-date:</p>

<pre><code class="ruby"># test/graphql/my_app_schema_test.rb
require "test_helper"

class MyAppSchemaTest &lt; ActiveSupport::TestCase
  def test_printout_is_up_to_date
    current_defn = MyAppSchema.to_definition
    printout_defn = File.read(Rails.root.join("app/graphql/schema.graphql"))
    assert_equal(current_defn, printout_defn, "Update the printed schema with `bundle exec rake dump_schema`")
  end
end
</code></pre>

<p>If the definition is stale, you&rsquo;ll get a failed test:</p>

<p><img src="/images/tracking_schema/test_failure.png" width="500"></p>

<p>This reminder is helpful in development and <em>essential</em> during code review!</p>

<h2>Review It</h2>

<p>Now that your schema definition is versioned along with your code, you can see changes during <strong>code review</strong>:</p>

<p><img src="/images/tracking_schema/code_review.png" width="600"></p>

<h2>Multiple Schema Dumps</h2>

<p>If your schema looks different to different users, you can track <em>multiple</em> schema dumps. This is helpful if:</p>

<ul>
<li>You&rsquo;re using the <code>:view</code> configuration of <a href="https://rmosolgo.github.io/graphql-ruby/pro/authorization"><code>GraphQL::Pro</code>&rsquo;s authorization</a></li>
<li>You&rsquo;re using <code>only:</code>/ <code>except:</code> to manually filter your schema</li>
</ul>


<p>Just provide the <code>context:</code> argument to <code>Schema.to_definition</code> as if you were running a query. (Also provide <code>only:</code>/<code>except:</code> if you use them.)</p>

<p>Print with a filter from the Rake task:</p>

<pre><code class="ruby"># lib/tasks/graphql.rake
task dump_schema: :environment do
  # ...
  admin_user = OpenStruct.new(admin?: true)
  admin_schema_dump = MyAppSchema.to_definition(context: { current_user: admin_user })
  admin_schema_path = "app/graphql/admin_schema.graphql"
  File.write(Rails.root.join(admin_schema_path), admin_schema_dump)
end
</code></pre>

<p>Test with a filter from the test case:</p>

<pre><code class="ruby">def test_printout_is_up_to_date
  # ...
  admin_user = OpenStruct.new(admin?: true)
  current_admin_defn = MyAppSchema.to_definition(context: { current_user: admin_user })
  printout_admin_defn = File.read(Rails.root.join("app/graphql/admin_schema.graphql"))
  assert_equal(current_admin_defn, printout_admin_defn, "Update the printed schema with `bundle exec rake dump_schema`")
end
</code></pre>

<p>Now you can keep an eye on the schema from several perspectives!</p>
]]></content>
  </entry>
  
</feed>
